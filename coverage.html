
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>argus: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/agilira/argus/argus.go (95.2%)</option>
				
				<option value="file1">github.com/agilira/argus/audit.go (93.9%)</option>
				
				<option value="file2">github.com/agilira/argus/boreaslite.go (93.5%)</option>
				
				<option value="file3">github.com/agilira/argus/config.go (78.6%)</option>
				
				<option value="file4">github.com/agilira/argus/parser_structured.go (97.0%)</option>
				
				<option value="file5">github.com/agilira/argus/parser_text.go (97.9%)</option>
				
				<option value="file6">github.com/agilira/argus/parsers.go (94.3%)</option>
				
				<option value="file7">github.com/agilira/argus/utilities.go (87.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// argus: Ultra-lightweight configuration
//
// Core Philosophy:
// - Minimal dependencies (AGILira ecosystem only: go-errors, go-timecache)
// - Polling-based approach for maximum OS portability
// - Intelligent caching to minimize os.Stat() syscalls (like go-timecache)
// - Thread-safe atomic operations
// - Zero allocations in hot paths
// - Configurable polling intervals
//
// Example Usage:
//   watcher := argus.New(argus.Config{
//       PollInterval: 5 * time.Second,
//       CacheTTL:     2 * time.Second,
//   })
//
//   watcher.Watch("config.json", func(event argus.ChangeEvent) {
//       // Handle configuration change
//       newConfig, err := LoadConfig(event.Path)
//       if err == nil {
//           atomicLevel.SetLevel(newConfig.Level)
//       }
//   })
//
//   watcher.Start()
//   defer watcher.Stop()
//
// Copyright (c) 2025 AGILira
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "context"
        "os"
        "path/filepath"
        "sync"
        "sync/atomic"
        "time"

        "github.com/agilira/go-errors"
        "github.com/agilira/go-timecache"
)

// fileStat caches file metadata to minimize os.Stat() calls
// Using value types instead of pointers to avoid use-after-free in concurrent access

// Error codes for Argus operations
const (
        ErrCodeInvalidConfig  = "ARGUS_INVALID_CONFIG"
        ErrCodeFileNotFound   = "ARGUS_FILE_NOT_FOUND"
        ErrCodeWatcherStopped = "ARGUS_WATCHER_STOPPED"
        ErrCodeWatcherBusy    = "ARGUS_WATCHER_BUSY"
)

// ChangeEvent represents a file change notification
type ChangeEvent struct {
        Path     string    // File path that changed
        ModTime  time.Time // New modification time
        Size     int64     // New file size
        IsCreate bool      // True if file was created
        IsDelete bool      // True if file was deleted
        IsModify bool      // True if file was modified
}

// UpdateCallback is called when a watched file changes
type UpdateCallback func(event ChangeEvent)

// ErrorHandler is called when errors occur during file watching or parsing
// It receives the error and the file path where the error occurred
type ErrorHandler func(err error, filepath string)

// OptimizationStrategy defines how BoreasLite should optimize performance
type OptimizationStrategy int

const (
        // OptimizationAuto automatically chooses the best strategy based on file count
        // - 1-3 files: SingleEvent strategy (ultra-low latency)
        // - 4-20 files: SmallBatch strategy (balanced)
        // - 21+ files: LargeBatch strategy (high throughput)
        OptimizationAuto OptimizationStrategy = iota

        // OptimizationSingleEvent optimizes for 1-2 files with ultra-low latency
        // - Fast path for single events (24ns)
        // - Minimal batching overhead
        // - Aggressive spinning for immediate processing
        OptimizationSingleEvent

        // OptimizationSmallBatch optimizes for 3-20 files with balanced performance
        // - Small batch sizes (2-8 events)
        // - Moderate spinning with short sleeps
        // - Good balance between latency and throughput
        OptimizationSmallBatch

        // OptimizationLargeBatch optimizes for 20+ files with high throughput
        // - Large batch sizes (16-64 events)
        // - Zephyros-style 4x unrolling
        // - Focus on maximum throughput over latency
        OptimizationLargeBatch
)

// Config configures the Argus watcher behavior
type Config struct {
        // PollInterval is how often to check for file changes
        // Default: 5 seconds (good balance of responsiveness vs overhead)
        PollInterval time.Duration

        // CacheTTL is how long to cache os.Stat() results
        // Should be &lt;= PollInterval for effectiveness
        // Default: PollInterval / 2
        CacheTTL time.Duration

        // MaxWatchedFiles limits the number of files that can be watched
        // Default: 100 (generous for config files)
        MaxWatchedFiles int

        // Audit configuration for security and compliance
        // Default: Enabled with secure defaults
        Audit AuditConfig

        // ErrorHandler is called when errors occur during file watching/parsing
        // If nil, errors are logged to stderr (backward compatible)
        // Example: func(err error, path string) { metrics.Increment("config.errors") }
        ErrorHandler ErrorHandler

        // OptimizationStrategy determines how BoreasLite optimizes performance
        // - OptimizationAuto: Automatically choose based on file count (default)
        // - OptimizationSingleEvent: Ultra-low latency for 1-2 files
        // - OptimizationSmallBatch: Balanced for 3-20 files
        // - OptimizationLargeBatch: High throughput for 20+ files
        OptimizationStrategy OptimizationStrategy

        // BoreasLiteCapacity sets the ring buffer size (must be power of 2)
        // - Auto/SingleEvent: 64 (minimal memory)
        // - SmallBatch: 128 (balanced)
        // - LargeBatch: 256+ (high throughput)
        // Default: 0 (auto-calculated based on strategy)
        BoreasLiteCapacity int64
}

// fileStat represents cached file statistics
type fileStat struct {
        modTime  time.Time
        size     int64
        exists   bool
        cachedAt int64 // Use timecache nano timestamp for zero-allocation timing
}

// isExpired checks if the cached stat is expired using timecache for zero-allocation timing
func (fs *fileStat) isExpired(ttl time.Duration) bool <span class="cov8" title="1">{
        now := timecache.CachedTimeNano()
        return (now - fs.cachedAt) &gt; int64(ttl)
}</span>

// watchedFile represents a file under observation
type watchedFile struct {
        path     string
        callback UpdateCallback
        lastStat fileStat
}

// Watcher monitors configuration files for changes
// ULTRA-OPTIMIZED: Uses BoreasLite MPSC ring buffer + lock-free cache for maximum performance
type Watcher struct {
        config  Config
        files   map[string]*watchedFile
        filesMu sync.RWMutex

        // LOCK-FREE CACHE: Uses atomic.Pointer for zero-contention reads
        statCache atomic.Pointer[map[string]fileStat]

        // ZERO-ALLOCATION POLLING: Reusable slice to avoid allocations in pollFiles
        filesBuffer []*watchedFile

        // BOREAS LITE: Ultra-fast MPSC ring buffer for file events (DEFAULT)
        eventRing *BoreasLite

        // AUDIT SYSTEM: Comprehensive security and compliance logging
        auditLogger *AuditLogger

        running   atomic.Bool
        stopCh    chan struct{}
        stoppedCh chan struct{}
        ctx       context.Context
        cancel    context.CancelFunc
}

// New creates a new Argus file watcher with BoreasLite integration
func New(config Config) *Watcher <span class="cov8" title="1">{
        cfg := config.WithDefaults()
        ctx, cancel := context.WithCancel(context.Background())

        // Initialize audit logger
        auditLogger, err := NewAuditLogger(cfg.Audit)
        if err != nil </span><span class="cov8" title="1">{
                // Fallback to disabled audit if setup fails
                auditLogger, _ = NewAuditLogger(AuditConfig{Enabled: false})
        }</span>

        <span class="cov8" title="1">watcher := &amp;Watcher{
                config:      *cfg,
                files:       make(map[string]*watchedFile),
                auditLogger: auditLogger,
                stopCh:      make(chan struct{}),
                stoppedCh:   make(chan struct{}),
                ctx:         ctx,
                cancel:      cancel,
        }

        // Initialize lock-free cache
        initialCache := make(map[string]fileStat)
        watcher.statCache.Store(&amp;initialCache)

        // Initialize BoreasLite MPSC ring buffer with configured strategy
        watcher.eventRing = NewBoreasLite(
                watcher.config.BoreasLiteCapacity,
                watcher.config.OptimizationStrategy,
                watcher.processFileEvent,
        )

        return watcher</span>
}

// processFileEvent processes events from the BoreasLite ring buffer
// This method is called by BoreasLite for each file change event
func (w *Watcher) processFileEvent(fileEvent *FileChangeEvent) <span class="cov8" title="1">{
        // Convert BoreasLite event back to standard ChangeEvent
        event := ConvertFileEventToChangeEvent(*fileEvent)

        // Find the corresponding watched file and call its callback
        w.filesMu.RLock()
        if wf, exists := w.files[event.Path]; exists </span><span class="cov8" title="1">{
                // Call the user's callback function
                wf.callback(event)

                // Log basic file change to audit system
                w.auditLogger.LogFileWatch("file_changed", event.Path)
        }</span>
        <span class="cov8" title="1">w.filesMu.RUnlock()</span>
}

// Watch adds a file to the watch list
func (w *Watcher) Watch(path string, callback UpdateCallback) error <span class="cov8" title="1">{
        if callback == nil </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "callback cannot be nil")
        }</span>

        <span class="cov8" title="1">absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, ErrCodeInvalidConfig, "invalid file path").
                        WithContext("path", path)
        }</span>

        // AUDIT: Log file watch start
        <span class="cov8" title="1">w.auditLogger.LogFileWatch("watch_start", absPath)

        w.filesMu.Lock()
        defer w.filesMu.Unlock()

        if len(w.files) &gt;= w.config.MaxWatchedFiles </span><span class="cov0" title="0">{
                // AUDIT: Log security event for limit exceeded
                w.auditLogger.LogSecurityEvent("watch_limit_exceeded", "Maximum watched files exceeded",
                        map[string]interface{}{
                                "path":          absPath,
                                "max_files":     w.config.MaxWatchedFiles,
                                "current_files": len(w.files),
                        })
                return errors.New(ErrCodeInvalidConfig, "maximum watched files exceeded").
                        WithContext("max_files", w.config.MaxWatchedFiles).
                        WithContext("current_files", len(w.files))
        }</span>

        // Get initial file stat
        <span class="cov8" title="1">initialStat, err := w.getStat(absPath)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov8" title="1">{
                return errors.Wrap(err, ErrCodeFileNotFound, "failed to stat file").
                        WithContext("path", absPath)
        }</span>

        <span class="cov8" title="1">w.files[absPath] = &amp;watchedFile{
                path:     absPath,
                callback: callback,
                lastStat: initialStat,
        }

        // Adapt BoreasLite strategy based on file count (if Auto mode)
        if w.eventRing != nil </span><span class="cov8" title="1">{
                w.eventRing.AdaptStrategy(len(w.files))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Unwatch removes a file from the watch list
func (w *Watcher) Unwatch(path string) error <span class="cov8" title="1">{
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, ErrCodeInvalidConfig, "invalid file path").
                        WithContext("path", path)
        }</span>

        <span class="cov8" title="1">w.filesMu.Lock()
        defer w.filesMu.Unlock()

        delete(w.files, absPath)

        // Adapt BoreasLite strategy based on updated file count (if Auto mode)
        if w.eventRing != nil </span><span class="cov8" title="1">{
                w.eventRing.AdaptStrategy(len(w.files))
        }</span>

        // Clean up cache entry atomically
        <span class="cov8" title="1">w.removeFromCache(absPath)

        return nil</span>
}

// Start begins watching files for changes
func (w *Watcher) Start() error <span class="cov8" title="1">{
        if !w.running.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                return errors.New(ErrCodeWatcherBusy, "watcher is already running")
        }</span>

        // Start BoreasLite event processor in background
        <span class="cov8" title="1">go w.eventRing.RunProcessor()

        // Start main polling loop
        go w.watchLoop()
        return nil</span>
}

// Stop stops the watcher and waits for cleanup
func (w *Watcher) Stop() error <span class="cov8" title="1">{
        if !w.running.CompareAndSwap(true, false) </span><span class="cov8" title="1">{
                return errors.New(ErrCodeWatcherStopped, "watcher is not running")
        }</span>

        <span class="cov8" title="1">w.cancel()
        close(w.stopCh)
        &lt;-w.stoppedCh

        // Stop BoreasLite event processor
        w.eventRing.Stop()

        // CRITICAL FIX: Close audit logger to prevent resource leaks
        if w.auditLogger != nil </span><span class="cov8" title="1">{
                _ = w.auditLogger.Close()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsRunning returns true if the watcher is currently running
func (w *Watcher) IsRunning() bool <span class="cov8" title="1">{
        return w.running.Load()
}</span>

// Close is an alias for Stop() for better resource management patterns
// Implements the common Close() interface for easy integration with defer statements
func (w *Watcher) Close() error <span class="cov8" title="1">{
        return w.Stop()
}</span>

// WatchedFiles returns the number of currently watched files
func (w *Watcher) WatchedFiles() int <span class="cov8" title="1">{
        w.filesMu.RLock()
        defer w.filesMu.RUnlock()
        return len(w.files)
}</span>

// getStat returns cached file statistics or performs os.Stat if cache is expired
// LOCK-FREE: Uses atomic.Pointer for zero-contention cache access with value types
func (w *Watcher) getStat(path string) (fileStat, error) <span class="cov8" title="1">{
        // Fast path: atomic read of cache (ZERO locks!)
        cacheMap := *w.statCache.Load()
        if cached, exists := cacheMap[path]; exists </span><span class="cov8" title="1">{
                // Check expiration without any locks
                if !cached.isExpired(w.config.CacheTTL) </span><span class="cov8" title="1">{
                        return cached, nil
                }</span>
        }

        // Slow path: cache miss or expired - perform actual os.Stat()
        <span class="cov8" title="1">info, err := os.Stat(path)
        stat := fileStat{
                cachedAt: timecache.CachedTimeNano(), // Use timecache for zero-allocation timestamp
                exists:   err == nil,
        }

        if err == nil </span><span class="cov8" title="1">{
                stat.modTime = info.ModTime()
                stat.size = info.Size()
        }</span>

        // Update cache atomically (copy-on-write)
        <span class="cov8" title="1">w.updateCache(path, stat)

        // Return by value (no pointer, no use-after-free risk)
        return stat, err</span>
}

// updateCache atomically updates the cache using copy-on-write (no pool, value types)
func (w *Watcher) updateCache(path string, stat fileStat) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                oldMapPtr := w.statCache.Load()
                oldMap := *oldMapPtr
                newMap := make(map[string]fileStat, len(oldMap)+1)

                // Copy existing entries
                for k, v := range oldMap </span><span class="cov8" title="1">{
                        newMap[k] = v
                }</span>

                // Add/update new entry
                <span class="cov8" title="1">newMap[path] = stat

                // Atomic compare-and-swap
                if w.statCache.CompareAndSwap(oldMapPtr, &amp;newMap) </span><span class="cov8" title="1">{
                        return // Success! No pool cleanup needed with value types
                }</span>
                // Retry if another goroutine updated the cache concurrently
        }
}

// removeFromCache atomically removes an entry from the cache (no pool, value types)
func (w *Watcher) removeFromCache(path string) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                oldMapPtr := w.statCache.Load()
                oldMap := *oldMapPtr
                if _, exists := oldMap[path]; !exists </span><span class="cov8" title="1">{
                        return // Entry doesn't exist, nothing to do
                }</span>

                <span class="cov8" title="1">newMap := make(map[string]fileStat, len(oldMap)-1)

                // Copy all entries except the one to remove
                for k, v := range oldMap </span><span class="cov8" title="1">{
                        if k != path </span><span class="cov8" title="1">{
                                newMap[k] = v
                        }</span>
                }

                // Atomic compare-and-swap
                <span class="cov8" title="1">if w.statCache.CompareAndSwap(oldMapPtr, &amp;newMap) </span><span class="cov8" title="1">{
                        return // Success! No pool cleanup needed with value types
                }</span>
                // Retry if another goroutine updated the cache concurrently
        }
}

// checkFile compares current file stat with last known stat and sends events via BoreasLite
func (w *Watcher) checkFile(wf *watchedFile) <span class="cov8" title="1">{
        currentStat, err := w.getStat(wf.path)

        // Handle stat errors
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        // File was deleted
                        if wf.lastStat.exists </span><span class="cov8" title="1">{
                                // Send delete event via BoreasLite ring buffer
                                w.eventRing.WriteFileChange(wf.path, time.Time{}, 0, false, true, false)
                                wf.lastStat.exists = false
                        }</span>
                } else<span class="cov0" title="0"> if w.config.ErrorHandler != nil </span><span class="cov0" title="0">{
                        w.config.ErrorHandler(errors.Wrap(err, ErrCodeFileNotFound, "failed to stat file").
                                WithContext("path", wf.path), wf.path)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // File exists now
        <span class="cov8" title="1">if !wf.lastStat.exists </span><span class="cov8" title="1">{
                // File was created - send via BoreasLite
                w.eventRing.WriteFileChange(wf.path, currentStat.modTime, currentStat.size, true, false, false)
        }</span> else<span class="cov8" title="1"> if currentStat.modTime != wf.lastStat.modTime || currentStat.size != wf.lastStat.size </span><span class="cov8" title="1">{
                // File was modified - send via BoreasLite
                w.eventRing.WriteFileChange(wf.path, currentStat.modTime, currentStat.size, false, false, true)
        }</span>

        <span class="cov8" title="1">wf.lastStat = currentStat</span>
}

// watchLoop is the main polling loop that checks all watched files
func (w *Watcher) watchLoop() <span class="cov8" title="1">{
        defer close(w.stoppedCh)

        ticker := time.NewTicker(w.config.PollInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-w.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-w.stopCh:<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        w.pollFiles()</span>
                }
        }
}

// pollFiles checks all watched files for changes
// ULTRA-OPTIMIZED: Zero-allocation version using reusable buffer
func (w *Watcher) pollFiles() <span class="cov8" title="1">{
        w.filesMu.RLock()
        // Reuse buffer to avoid allocations
        w.filesBuffer = w.filesBuffer[:0] // Reset slice but keep capacity
        for _, wf := range w.files </span><span class="cov8" title="1">{
                w.filesBuffer = append(w.filesBuffer, wf)
        }</span>
        <span class="cov8" title="1">files := w.filesBuffer
        w.filesMu.RUnlock()

        // For single file, use direct checking to avoid goroutine overhead
        if len(files) == 1 </span><span class="cov8" title="1">{
                w.checkFile(files[0])
                return
        }</span>

        // For multiple files, use parallel checking with limited concurrency
        <span class="cov8" title="1">const maxConcurrency = 8 // Prevent goroutine explosion
        if len(files) &lt;= maxConcurrency </span><span class="cov8" title="1">{
                // Use goroutines for small number of files
                var wg sync.WaitGroup
                for _, wf := range files </span><span class="cov8" title="1">{
                        wg.Add(1)
                        go func(wf *watchedFile) </span><span class="cov8" title="1">{
                                defer wg.Done()
                                w.checkFile(wf)
                        }</span>(wf)
                }
                <span class="cov8" title="1">wg.Wait()</span>
        } else<span class="cov8" title="1"> {
                // Use worker pool for many files
                fileCh := make(chan *watchedFile, len(files))
                var wg sync.WaitGroup

                // Start workers
                for i := 0; i &lt; maxConcurrency; i++ </span><span class="cov8" title="1">{
                        wg.Add(1)
                        go func() </span><span class="cov8" title="1">{
                                defer wg.Done()
                                for wf := range fileCh </span><span class="cov8" title="1">{
                                        w.checkFile(wf)
                                }</span>
                        }()
                }

                // Send files to workers
                <span class="cov8" title="1">for _, wf := range files </span><span class="cov8" title="1">{
                        fileCh &lt;- wf
                }</span>
                <span class="cov8" title="1">close(fileCh)
                wg.Wait()</span>
        }
}

// ClearCache forces clearing of the stat cache (no pool cleanup needed)
// Useful for testing or when you want to force fresh stat calls
func (w *Watcher) ClearCache() <span class="cov8" title="1">{
        emptyCache := make(map[string]fileStat)
        w.statCache.Store(&amp;emptyCache)
}</span>

// CacheStats returns statistics about the internal cache
type CacheStats struct {
        Entries   int           // Number of cached entries
        OldestAge time.Duration // Age of oldest cache entry
        NewestAge time.Duration // Age of newest cache entry
}

// GetCacheStats returns current cache statistics using timecache for performance
func (w *Watcher) GetCacheStats() CacheStats <span class="cov8" title="1">{
        cacheMap := *w.statCache.Load()

        if len(cacheMap) == 0 </span><span class="cov8" title="1">{
                return CacheStats{}
        }</span>

        <span class="cov8" title="1">now := timecache.CachedTimeNano()
        var oldest, newest int64
        first := true

        for _, stat := range cacheMap </span><span class="cov8" title="1">{
                if first </span><span class="cov8" title="1">{
                        oldest = stat.cachedAt
                        newest = stat.cachedAt
                        first = false
                }</span> else<span class="cov8" title="1"> {
                        if stat.cachedAt &lt; oldest </span><span class="cov0" title="0">{
                                oldest = stat.cachedAt
                        }</span>
                        <span class="cov8" title="1">if stat.cachedAt &gt; newest </span><span class="cov0" title="0">{
                                newest = stat.cachedAt
                        }</span>
                }
        }

        <span class="cov8" title="1">return CacheStats{
                Entries:   len(cacheMap),
                OldestAge: time.Duration(now - oldest),
                NewestAge: time.Duration(now - newest),
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// audit.go: Comprehensive audit trail system for Argus
//
// This provides security audit logging for all configuration changes,
// ensuring full accountability and traceability in production environments.
//
// Features:
// - Immutable audit logs with tamper detection
// - Structured logging with context
// - Performance optimized (sub-microsecond impact)
// - Configurable audit levels and outputs
//
// Copyright (c) 2025 AGILira
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "os"
        "sync"
        "time"

        "github.com/agilira/go-timecache"
)

// AuditLevel represents the severity of audit events
type AuditLevel int

const (
        AuditInfo AuditLevel = iota
        AuditWarn
        AuditCritical
        AuditSecurity
)

func (al AuditLevel) String() string <span class="cov8" title="1">{
        switch al </span>{
        case AuditInfo:<span class="cov8" title="1">
                return "INFO"</span>
        case AuditWarn:<span class="cov8" title="1">
                return "WARN"</span>
        case AuditCritical:<span class="cov8" title="1">
                return "CRITICAL"</span>
        case AuditSecurity:<span class="cov8" title="1">
                return "SECURITY"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// AuditEvent represents a single auditable event
type AuditEvent struct {
        Timestamp   time.Time              `json:"timestamp"`
        Level       AuditLevel             `json:"level"`
        Event       string                 `json:"event"`
        Component   string                 `json:"component"`
        FilePath    string                 `json:"file_path,omitempty"`
        OldValue    interface{}            `json:"old_value,omitempty"`
        NewValue    interface{}            `json:"new_value,omitempty"`
        UserAgent   string                 `json:"user_agent,omitempty"`
        ProcessID   int                    `json:"process_id"`
        ProcessName string                 `json:"process_name"`
        Context     map[string]interface{} `json:"context,omitempty"`
        Checksum    string                 `json:"checksum"` // For tamper detection
}

// AuditConfig configures the audit system
type AuditConfig struct {
        Enabled       bool          `json:"enabled"`
        OutputFile    string        `json:"output_file"`
        MinLevel      AuditLevel    `json:"min_level"`
        BufferSize    int           `json:"buffer_size"`
        FlushInterval time.Duration `json:"flush_interval"`
        IncludeStack  bool          `json:"include_stack"`
}

// DefaultAuditConfig returns secure default audit configuration
func DefaultAuditConfig() AuditConfig <span class="cov8" title="1">{
        return AuditConfig{
                Enabled:       true,
                OutputFile:    "/var/log/argus/audit.jsonl",
                MinLevel:      AuditInfo,
                BufferSize:    1000,
                FlushInterval: 5 * time.Second,
                IncludeStack:  false,
        }
}</span>

// AuditLogger provides high-performance audit logging
type AuditLogger struct {
        config      AuditConfig
        file        *os.File
        buffer      []AuditEvent
        bufferMu    sync.Mutex
        flushTicker *time.Ticker
        stopCh      chan struct{}
        processID   int
        processName string
}

// NewAuditLogger creates a new audit logger
func NewAuditLogger(config AuditConfig) (*AuditLogger, error) <span class="cov8" title="1">{
        logger := &amp;AuditLogger{
                config:      config,
                buffer:      make([]AuditEvent, 0, config.BufferSize),
                stopCh:      make(chan struct{}),
                processID:   os.Getpid(),
                processName: getProcessName(),
        }

        if config.Enabled &amp;&amp; config.OutputFile != "" </span><span class="cov8" title="1">{
                // Ensure directory exists
                if err := os.MkdirAll(getDir(config.OutputFile), 0750); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to create audit log directory: %w", err)
                }</span>

                // Open audit file with secure permissions (owner read/write only)
                <span class="cov8" title="1">file, err := os.OpenFile(config.OutputFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open audit log file: %w", err)
                }</span>
                <span class="cov8" title="1">logger.file = file</span>
        }

        // Start background flusher
        <span class="cov8" title="1">if config.FlushInterval &gt; 0 </span><span class="cov8" title="1">{
                logger.flushTicker = time.NewTicker(config.FlushInterval)
                go logger.flushLoop()
        }</span>

        <span class="cov8" title="1">return logger, nil</span>
}

// Log records an audit event with ultra-high performance
func (al *AuditLogger) Log(level AuditLevel, event, component, filePath string, oldVal, newVal interface{}, context map[string]interface{}) <span class="cov8" title="1">{
        if !al.config.Enabled || level &lt; al.config.MinLevel </span><span class="cov8" title="1">{
                return
        }</span>

        // Use cached timestamp for performance (121x faster than time.Now())
        <span class="cov8" title="1">timestamp := timecache.CachedTime()

        auditEvent := AuditEvent{
                Timestamp:   timestamp,
                Level:       level,
                Event:       event,
                Component:   component,
                FilePath:    filePath,
                OldValue:    oldVal,
                NewValue:    newVal,
                ProcessID:   al.processID,
                ProcessName: al.processName,
                Context:     context,
        }

        // Generate tamper-detection checksum
        auditEvent.Checksum = al.generateChecksum(auditEvent)

        // Buffer the event
        al.bufferMu.Lock()
        al.buffer = append(al.buffer, auditEvent)
        if len(al.buffer) &gt;= al.config.BufferSize </span><span class="cov8" title="1">{
                al.flushBufferUnsafe()
        }</span>
        <span class="cov8" title="1">al.bufferMu.Unlock()</span>
}

// LogConfigChange logs configuration file changes (most common use case)
func (al *AuditLogger) LogConfigChange(filePath string, oldConfig, newConfig map[string]interface{}) <span class="cov8" title="1">{
        al.Log(AuditCritical, "config_change", "argus", filePath, oldConfig, newConfig, nil)
}</span>

// LogFileWatch logs file watch events
func (al *AuditLogger) LogFileWatch(event, filePath string) <span class="cov8" title="1">{
        al.Log(AuditInfo, event, "argus", filePath, nil, nil, nil)
}</span>

// LogSecurityEvent logs security-related events
func (al *AuditLogger) LogSecurityEvent(event, details string, context map[string]interface{}) <span class="cov8" title="1">{
        al.Log(AuditSecurity, event, "argus", "", nil, nil, context)
}</span>

// Flush immediately writes all buffered events
func (al *AuditLogger) Flush() error <span class="cov8" title="1">{
        al.bufferMu.Lock()
        defer al.bufferMu.Unlock()
        return al.flushBufferUnsafe()
}</span>

// Close gracefully shuts down the audit logger
func (al *AuditLogger) Close() error <span class="cov8" title="1">{
        close(al.stopCh)
        if al.flushTicker != nil </span><span class="cov8" title="1">{
                al.flushTicker.Stop()
        }</span>

        // Final flush
        <span class="cov8" title="1">if err := al.Flush(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if al.file != nil </span><span class="cov8" title="1">{
                return al.file.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// flushLoop runs the background flush process
func (al *AuditLogger) flushLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-al.flushTicker.C:<span class="cov8" title="1">
                        al.Flush()</span>
                case &lt;-al.stopCh:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// flushBufferUnsafe writes buffer to file (caller must hold bufferMu)
func (al *AuditLogger) flushBufferUnsafe() error <span class="cov8" title="1">{
        if len(al.buffer) == 0 || al.file == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, event := range al.buffer </span><span class="cov8" title="1">{
                data, err := json.Marshal(event)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip malformed events
                }
                <span class="cov8" title="1">al.file.Write(data)
                al.file.Write([]byte("\n"))</span>
        }

        <span class="cov8" title="1">al.file.Sync()            // Force to disk for audit integrity
        al.buffer = al.buffer[:0] // Reset buffer
        return nil</span>
}

// generateChecksum creates a tamper-detection checksum using SHA-256
func (al *AuditLogger) generateChecksum(event AuditEvent) string <span class="cov8" title="1">{
        // Cryptographic hash for tamper detection
        data := fmt.Sprintf("%s:%s:%s:%v:%v",
                event.Timestamp.Format(time.RFC3339Nano),
                event.Event, event.Component, event.OldValue, event.NewValue)
        hash := sha256.Sum256([]byte(data))
        return fmt.Sprintf("%x", hash)
}</span>

// Helper functions
func getProcessName() string <span class="cov8" title="1">{
        return "argus" // Could read from /proc/self/comm
}</span>

func getDir(filePath string) string <span class="cov8" title="1">{
        for i := len(filePath) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if filePath[i] == '/' </span><span class="cov8" title="1">{
                        return filePath[:i]
                }</span>
        }
        <span class="cov0" title="0">return "."</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// boreaslite.go: Xantos Powered MPSC ring buffer derived from Boreas
//
// Copyright (c) 2025 AGILira
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "sync/atomic"
        "time"
)

// FileChangeEvent represents a file change optimized for minimal memory footprint
// 128 bytes (2 cache lines) for maximum path compatibility and performance
type FileChangeEvent struct {
        Path    [110]byte // FULL POWER: 110 bytes for any file path (109 chars + null terminator)
        PathLen uint8     // Actual path length
        ModTime int64     // Unix nanoseconds
        Size    int64     // File size
        Flags   uint8     // Create(1), Delete(2), Modify(4) bits
        _       [0]byte   // Perfect 128 bytes: 110+1+8+8+1 = 128
}

// Event flags for file changes
const (
        FileEventCreate uint8 = 1 &lt;&lt; iota
        FileEventDelete
        FileEventModify
)

// BoreasLite - Ultra-fast MPSC ring buffer for file watching
// Optimized for Argus-specific use cases:
//   - Small number of files (typically 1-10)
//   - Infrequent events (file changes are rare)
//   - Low latency priority (immediate callback execution)
//   - Minimal memory footprint
type BoreasLite struct {
        // Ring buffer core (smaller than ZephyrosLite)
        buffer   []FileChangeEvent
        capacity int64
        mask     int64 // capacity - 1 for fast modulo

        // MPSC atomic cursors with cache-line padding
        writerCursor atomic.Int64 // Producer sequence
        readerCursor atomic.Int64 // Consumer sequence
        _            [48]byte     // Padding to prevent false sharing

        // Availability tracking for MPSC coordination
        availableBuffer []atomic.Int64 // Per-slot availability markers

        // Processor function (no interface overhead)
        processor func(*FileChangeEvent)

        // Optimization strategy configuration
        strategy  OptimizationStrategy
        batchSize int64 // Adaptive based on strategy

        // Control
        running atomic.Bool

        // Ultra-simple stats (just counters)
        processed atomic.Int64
        dropped   atomic.Int64
}

// NewBoreasLite creates a new ultra-fast ring buffer for file events
//
// Parameters:
//   - capacity: Ring buffer size (must be power of 2)
//   - strategy: Optimization strategy for performance tuning
//   - processor: Function to process file change events
//
// Returns:
//   - *BoreasLite: Ready-to-use ring buffer
func NewBoreasLite(capacity int64, strategy OptimizationStrategy, processor func(*FileChangeEvent)) *BoreasLite <span class="cov8" title="1">{
        // Validate power of 2
        if capacity &lt;= 0 || (capacity&amp;(capacity-1)) != 0 </span><span class="cov0" title="0">{
                capacity = 64 // Safe default for file watching
        }</span>

        // Determine batch size based on strategy
        <span class="cov8" title="1">var batchSize int64
        switch strategy </span>{
        case OptimizationSingleEvent:<span class="cov8" title="1">
                batchSize = 1</span> // Process immediately, no batching
        case OptimizationSmallBatch:<span class="cov8" title="1">
                batchSize = 4</span> // Small batches for balanced performance
        case OptimizationLargeBatch:<span class="cov8" title="1">
                batchSize = 16</span> // Large batches for throughput
        default:<span class="cov8" title="1"> // OptimizationAuto will be handled at runtime
                batchSize = 4</span> // Safe default
        }

        // Create ring buffer
        <span class="cov8" title="1">b := &amp;BoreasLite{
                buffer:          make([]FileChangeEvent, capacity),
                capacity:        capacity,
                mask:            capacity - 1,
                availableBuffer: make([]atomic.Int64, capacity),
                processor:       processor,
                strategy:        strategy,
                batchSize:       batchSize,
        }

        // Initialize availability markers
        for i := range b.availableBuffer </span><span class="cov8" title="1">{
                b.availableBuffer[i].Store(-1)
        }</span>

        <span class="cov8" title="1">b.running.Store(true)
        return b</span>
}

// AdaptStrategy dynamically adjusts the optimization strategy based on file count
// This is called when OptimizationAuto is used and file count changes
func (b *BoreasLite) AdaptStrategy(fileCount int) <span class="cov8" title="1">{
        if b.strategy != OptimizationAuto </span><span class="cov8" title="1">{
                return // Fixed strategy, no adaptation
        }</span>

        <span class="cov8" title="1">var newBatchSize int64
        switch </span>{
        case fileCount &lt;= 3:<span class="cov8" title="1">
                newBatchSize = 1</span> // SingleEvent optimization
        case fileCount &lt;= 20:<span class="cov8" title="1">
                newBatchSize = 4</span> // SmallBatch optimization
        default:<span class="cov8" title="1">
                newBatchSize = 16</span> // LargeBatch optimization
        }

        // Update batch size atomically (safe to change at runtime)
        <span class="cov8" title="1">b.batchSize = newBatchSize</span>
}

// WriteFileEvent adds a file change event to the ring buffer
// ZERO ALLOCATIONS - uses provided event struct directly
//
// Parameters:
//   - event: Pre-populated file change event
//
// Returns:
//   - bool: true if written, false if ring is full/closed
//
// Performance: Target &lt;8ns per operation
func (b *BoreasLite) WriteFileEvent(event *FileChangeEvent) bool <span class="cov8" title="1">{
        if !b.running.Load() </span><span class="cov0" title="0">{
                b.dropped.Add(1)
                return false
        }</span>

        // MPSC: Claim sequence atomically
        <span class="cov8" title="1">sequence := b.writerCursor.Add(1) - 1

        // Check buffer full (file events should NEVER be dropped, but safety check)
        if sequence &gt;= b.readerCursor.Load()+b.capacity </span><span class="cov0" title="0">{
                b.dropped.Add(1)
                return false
        }</span>

        // Copy event to buffer slot (zero allocation)
        <span class="cov8" title="1">slot := &amp;b.buffer[sequence&amp;b.mask]
        *slot = *event

        // Mark available for reading
        b.availableBuffer[sequence&amp;b.mask].Store(sequence)

        return true</span>
}

// WriteFileChange is a convenience method for creating events from parameters
// Slightly slower than WriteFileEvent but more convenient
func (b *BoreasLite) WriteFileChange(path string, modTime time.Time, size int64, isCreate, isDelete, isModify bool) bool <span class="cov8" title="1">{
        event := FileChangeEvent{
                ModTime: modTime.UnixNano(),
                Size:    size,
        }

        // Copy path with bounds checking
        pathBytes := []byte(path)
        copyLen := len(pathBytes)
        if copyLen &gt; 109 </span><span class="cov0" title="0">{ // Use full buffer capacity (110 bytes - 1 for safety)
                copyLen = 109
        }</span>
        <span class="cov8" title="1">copy(event.Path[:], pathBytes[:copyLen])
        // Safe conversion: copyLen is guaranteed &lt;= 109 (fits in uint8)
        event.PathLen = uint8(copyLen) // #nosec G115 -- bounds checked above, copyLen &lt;= 109

        // Set flags
        if isCreate </span><span class="cov8" title="1">{
                event.Flags |= FileEventCreate
        }</span>
        <span class="cov8" title="1">if isDelete </span><span class="cov8" title="1">{
                event.Flags |= FileEventDelete
        }</span>
        <span class="cov8" title="1">if isModify </span><span class="cov8" title="1">{
                event.Flags |= FileEventModify
        }</span>

        <span class="cov8" title="1">return b.WriteFileEvent(&amp;event)</span>
}

// ProcessBatch processes available events in small batches
// Optimized for low latency - smaller batches than ZephyrosLite
//
// Returns:
//   - int: Number of events processed
func (b *BoreasLite) ProcessBatch() int <span class="cov8" title="1">{
        current := b.readerCursor.Load()
        writerPos := b.writerCursor.Load()

        if current &gt;= writerPos </span><span class="cov8" title="1">{
                return 0 // Nothing to process
        }</span>

        <span class="cov8" title="1">bufferOccupancy := writerPos - current

        // STRATEGY-BASED OPTIMIZATION: Choose processing path based on configuration
        switch b.strategy </span>{
        case OptimizationSingleEvent:<span class="cov8" title="1">
                return b.processSingleEventOptimized(current, writerPos, bufferOccupancy)</span>
        case OptimizationSmallBatch:<span class="cov8" title="1">
                return b.processSmallBatchOptimized(current, writerPos, bufferOccupancy)</span>
        case OptimizationLargeBatch:<span class="cov8" title="1">
                return b.processLargeBatchOptimized(current, writerPos, bufferOccupancy)</span>
        default:<span class="cov8" title="1"> // OptimizationAuto
                return b.processAutoOptimized(current, writerPos, bufferOccupancy)</span>
        }
}

// processSingleEventOptimized - Ultra-low latency for 1-2 files
func (b *BoreasLite) processSingleEventOptimized(current, writerPos, bufferOccupancy int64) int <span class="cov8" title="1">{
        // ULTRA-FAST PATH: Single event with minimal overhead
        if bufferOccupancy == 1 </span><span class="cov8" title="1">{
                if b.availableBuffer[current&amp;b.mask].Load() == current </span><span class="cov8" title="1">{
                        b.processor(&amp;b.buffer[current&amp;b.mask])
                        b.availableBuffer[current&amp;b.mask].Store(-1)
                        b.readerCursor.Store(current + 1)
                        b.processed.Add(1)
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }

        // Process small batches immediately (2-3 events)
        <span class="cov8" title="1">maxProcess := minInt64(3, writerPos-current)
        available := current - 1

        for seq := current; seq &lt; current+maxProcess; seq++ </span><span class="cov8" title="1">{
                if b.availableBuffer[seq&amp;b.mask].Load() == seq </span><span class="cov8" title="1">{
                        available = seq
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">if available &lt; current </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">processed := int(available - current + 1)
        for seq := current; seq &lt;= available; seq++ </span><span class="cov8" title="1">{
                idx := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx])
                b.availableBuffer[idx].Store(-1)
        }</span>

        <span class="cov8" title="1">b.readerCursor.Store(available + 1)
        b.processed.Add(int64(processed))
        return processed</span>
}

// processSmallBatchOptimized - Balanced performance for 3-20 files
func (b *BoreasLite) processSmallBatchOptimized(current, writerPos, bufferOccupancy int64) int <span class="cov8" title="1">{
        maxProcess := minInt64(b.batchSize, writerPos-current)
        available := current - 1

        // Find contiguous available events
        for seq := current; seq &lt; current+maxProcess; seq++ </span><span class="cov8" title="1">{
                if b.availableBuffer[seq&amp;b.mask].Load() == seq </span><span class="cov8" title="1">{
                        available = seq
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">if available &lt; current </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">processed := int(available - current + 1)

        // Use simple loop for small batches (no unrolling overhead)
        for seq := current; seq &lt;= available; seq++ </span><span class="cov8" title="1">{
                idx := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx])
                b.availableBuffer[idx].Store(-1)
        }</span>

        <span class="cov8" title="1">b.readerCursor.Store(available + 1)
        b.processed.Add(int64(processed))
        return processed</span>
}

// processLargeBatchOptimized - High throughput for 20+ files with Zephyros optimizations
func (b *BoreasLite) processLargeBatchOptimized(current, writerPos, bufferOccupancy int64) int <span class="cov8" title="1">{
        // Adaptive batching based on buffer pressure
        adaptiveBatchSize := b.batchSize
        if bufferOccupancy &gt; b.capacity*3/4 </span><span class="cov0" title="0">{
                adaptiveBatchSize = minInt64(b.batchSize*4, b.capacity/2)
        }</span>

        <span class="cov8" title="1">maxProcess := minInt64(adaptiveBatchSize, writerPos-current)
        available := current - 1
        maxScan := current + maxProcess

        // Smart prefetching for optimal cache hits
        for seq := current; seq &lt; maxScan; seq++ </span><span class="cov8" title="1">{
                if seq+4 &lt; maxScan </span><span class="cov8" title="1">{
                        _ = b.availableBuffer[(seq+4)&amp;b.mask].Load() // Prefetch 4 slots ahead
                }</span>

                <span class="cov8" title="1">if b.availableBuffer[seq&amp;b.mask].Load() == seq </span><span class="cov8" title="1">{
                        available = seq
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">if available &lt; current </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">processed := int(available - current + 1)

        // 4x Unrolled processing for maximum throughput
        seq := current
        remainder := processed &amp; 3
        chunks := processed &gt;&gt; 2

        for i := 0; i &lt; chunks; i++ </span><span class="cov8" title="1">{
                if seq+8 &lt;= available </span><span class="cov8" title="1">{
                        _ = b.buffer[(seq+8)&amp;b.mask] // Prefetch data 8 slots ahead
                }</span>

                // Process 4 events at once
                <span class="cov8" title="1">idx1 := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx1])
                seq++

                idx2 := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx2])
                seq++

                idx3 := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx3])
                seq++

                idx4 := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx4])
                seq++

                // Batch reset for cache locality
                b.availableBuffer[idx1].Store(-1)
                b.availableBuffer[idx2].Store(-1)
                b.availableBuffer[idx3].Store(-1)
                b.availableBuffer[idx4].Store(-1)</span>
        }

        // Process remaining items
        <span class="cov8" title="1">for i := 0; i &lt; remainder; i++ </span><span class="cov8" title="1">{
                idx := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx])
                b.availableBuffer[idx].Store(-1)
                seq++
        }</span>

        <span class="cov8" title="1">b.readerCursor.Store(available + 1)
        b.processed.Add(int64(processed))
        return processed</span>
}

// processAutoOptimized - Dynamic strategy based on runtime conditions
func (b *BoreasLite) processAutoOptimized(current, writerPos, bufferOccupancy int64) int <span class="cov8" title="1">{
        // Choose strategy based on buffer occupancy
        switch </span>{
        case bufferOccupancy &lt;= 3:<span class="cov8" title="1">
                return b.processSingleEventOptimized(current, writerPos, bufferOccupancy)</span>
        case bufferOccupancy &lt;= 16:<span class="cov8" title="1">
                return b.processSmallBatchOptimized(current, writerPos, bufferOccupancy)</span>
        default:<span class="cov0" title="0">
                return b.processLargeBatchOptimized(current, writerPos, bufferOccupancy)</span>
        }
}

// RunProcessor runs the consumer loop with strategy-optimized behavior
func (b *BoreasLite) RunProcessor() <span class="cov8" title="1">{
        // Strategy-specific spinning behavior
        switch b.strategy </span>{
        case OptimizationSingleEvent:<span class="cov8" title="1">
                b.runSingleEventProcessor()</span>
        case OptimizationSmallBatch:<span class="cov8" title="1">
                b.runSmallBatchProcessor()</span>
        case OptimizationLargeBatch:<span class="cov8" title="1">
                b.runLargeBatchProcessor()</span>
        default:<span class="cov8" title="1"> // OptimizationAuto
                b.runAutoProcessor()</span>
        }
}

// runSingleEventProcessor - Ultra-aggressive spinning for 1-2 files
func (b *BoreasLite) runSingleEventProcessor() <span class="cov8" title="1">{
        spins := 0
        for b.running.Load() </span><span class="cov8" title="1">{
                processed := b.ProcessBatch()
                if processed &gt; 0 </span><span class="cov8" title="1">{
                        spins = 0
                        continue</span> // Hot loop for immediate processing
                }

                <span class="cov8" title="1">spins++
                if spins &lt; 5000 </span><span class="cov8" title="1">{ // Aggressive spinning for ultra-low latency
                        continue</span>
                } else<span class="cov8" title="1"> {
                        spins = 0 // Reset quickly for file changes
                }</span>
        }

        // Final drain
        <span class="cov8" title="1">for b.ProcessBatch() &gt; 0 </span>{<span class="cov0" title="0">
        }</span>
}

// runSmallBatchProcessor - Balanced spinning for 3-20 files
func (b *BoreasLite) runSmallBatchProcessor() <span class="cov8" title="1">{
        spins := 0
        for b.running.Load() </span><span class="cov8" title="1">{
                processed := b.ProcessBatch()
                if processed &gt; 0 </span><span class="cov8" title="1">{
                        spins = 0
                        if processed &gt;= int(b.batchSize/2) </span><span class="cov8" title="1">{
                                continue</span> // Continue for burst processing
                        }
                } else<span class="cov8" title="1"> {
                        spins++
                        if spins &lt; 2000 </span><span class="cov8" title="1">{
                                continue</span>
                        } else<span class="cov8" title="1"> if spins &lt; 6000 </span><span class="cov8" title="1">{
                                if spins&amp;3 == 0 </span><span class="cov8" title="1">{ // Yield every 4 iterations
                                        continue</span>
                                }
                        } else<span class="cov8" title="1"> {
                                spins = 0
                        }</span>
                }
        }

        // Final drain
        <span class="cov8" title="1">for b.ProcessBatch() &gt; 0 </span>{<span class="cov0" title="0">
        }</span>
}

// runLargeBatchProcessor - Optimized for high throughput 20+ files
func (b *BoreasLite) runLargeBatchProcessor() <span class="cov8" title="1">{
        spins := 0
        for b.running.Load() </span><span class="cov8" title="1">{
                processed := b.ProcessBatch()
                if processed &gt; 0 </span><span class="cov8" title="1">{
                        spins = 0
                        if processed &gt;= int(b.batchSize) </span><span class="cov8" title="1">{
                                continue</span> // Hot loop for maximum throughput
                        }
                } else<span class="cov8" title="1"> {
                        spins++
                        if spins &lt; 1000 </span><span class="cov8" title="1">{
                                continue</span>
                        } else<span class="cov8" title="1"> if spins &lt; 4000 </span><span class="cov8" title="1">{
                                if spins&amp;15 == 0 </span><span class="cov8" title="1">{ // Yield every 16 iterations
                                        continue</span>
                                }
                        } else<span class="cov8" title="1"> {
                                spins = 0
                        }</span>
                }
        }

        // Final drain
        <span class="cov8" title="1">for b.ProcessBatch() &gt; 0 </span>{<span class="cov0" title="0">
        }</span>
}

// runAutoProcessor - Dynamic behavior based on runtime conditions
func (b *BoreasLite) runAutoProcessor() <span class="cov8" title="1">{
        spins := 0
        for b.running.Load() </span><span class="cov8" title="1">{
                processed := b.ProcessBatch()
                if processed &gt; 0 </span><span class="cov8" title="1">{
                        spins = 0
                        continue</span>
                }

                <span class="cov8" title="1">spins++
                if spins &lt; 2000 </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if spins &lt; 8000 </span><span class="cov8" title="1">{
                        if spins&amp;7 == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                } else<span class="cov8" title="1"> {
                        spins = 0
                }</span>
        }

        // Final drain
        <span class="cov8" title="1">for b.ProcessBatch() &gt; 0 </span>{<span class="cov0" title="0">
        }</span>
}

// Stop stops the processor (immediate, no graceful shutdown needed for file watching)
func (b *BoreasLite) Stop() <span class="cov8" title="1">{
        b.running.Store(false)
}</span>

// Stats returns minimal statistics for monitoring
func (b *BoreasLite) Stats() map[string]int64 <span class="cov8" title="1">{
        writerPos := b.writerCursor.Load()
        readerPos := b.readerCursor.Load()

        return map[string]int64{
                "writer_position": writerPos,
                "reader_position": readerPos,
                "buffer_size":     b.capacity,
                "items_buffered":  writerPos - readerPos,
                "items_processed": b.processed.Load(),
                "items_dropped":   b.dropped.Load(),
                "running":         boolToInt64(b.running.Load()),
        }
}</span>

// ConvertChangeEventToFileEvent converts standard ChangeEvent to FileChangeEvent
func ConvertChangeEventToFileEvent(event ChangeEvent) FileChangeEvent <span class="cov8" title="1">{
        fileEvent := FileChangeEvent{
                ModTime: event.ModTime.UnixNano(),
                Size:    event.Size,
        }

        // Copy path
        pathBytes := []byte(event.Path)
        copyLen := len(pathBytes)
        if copyLen &gt; 109 </span><span class="cov0" title="0">{ // Use full buffer capacity (110 bytes - 1 for safety)
                copyLen = 109
        }</span>
        <span class="cov8" title="1">copy(fileEvent.Path[:], pathBytes[:copyLen])
        // Safe conversion: copyLen is guaranteed &lt;= 109 (fits in uint8)
        fileEvent.PathLen = uint8(copyLen) // #nosec G115 -- bounds checked above, copyLen &lt;= 109

        // Set flags
        if event.IsCreate </span><span class="cov8" title="1">{
                fileEvent.Flags |= FileEventCreate
        }</span>
        <span class="cov8" title="1">if event.IsDelete </span><span class="cov0" title="0">{
                fileEvent.Flags |= FileEventDelete
        }</span>
        <span class="cov8" title="1">if !event.IsCreate &amp;&amp; !event.IsDelete </span><span class="cov0" title="0">{
                fileEvent.Flags |= FileEventModify
        }</span>

        <span class="cov8" title="1">return fileEvent</span>
}

// ConvertFileEventToChangeEvent converts FileChangeEvent back to ChangeEvent
func ConvertFileEventToChangeEvent(fileEvent FileChangeEvent) ChangeEvent <span class="cov8" title="1">{
        return ChangeEvent{
                Path:     string(fileEvent.Path[:fileEvent.PathLen]),
                ModTime:  time.Unix(0, fileEvent.ModTime),
                Size:     fileEvent.Size,
                IsCreate: (fileEvent.Flags &amp; FileEventCreate) != 0,
                IsDelete: (fileEvent.Flags &amp; FileEventDelete) != 0,
                IsModify: (fileEvent.Flags &amp; FileEventModify) != 0,
        }
}</span>

// Helper functions
func minInt64(a, b int64) int64 <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func boolToInt64(b bool) int64 <span class="cov8" title="1">{
        if b </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// config.go: Configuration management for Argus Dynamic Configuration Framework
//
// Copyright (c) 2025 AGILira
// Series: AGILira System Libraries
// SPDX-License-Identifier: MPL-2.0

package argus

import "time"

// IdleStrategy defines how the watcher should behave when no file changes
// are detected. This allows for power management and CPU optimization.
type IdleStrategy interface {
        // Wait is called between polling cycles when no changes are detected
        Wait()

        // Reset is called when file changes are detected to reset any backoff
        Reset()
}

// SleepStrategy implements IdleStrategy using simple sleep
type SleepStrategy struct{}

// NewSleepStrategy creates a new sleep-based idle strategy
func NewSleepStrategy() *SleepStrategy <span class="cov8" title="1">{
        return &amp;SleepStrategy{}
}</span>

// Wait implements IdleStrategy by doing nothing (polling interval handles timing)
func (s *SleepStrategy) Wait() <span class="cov8" title="1">{
        // No additional waiting - rely on polling interval
        _ = s // Prevent unused receiver warning
}</span>

// Reset implements IdleStrategy by doing nothing
func (s *SleepStrategy) Reset() <span class="cov8" title="1">{
        // No state to reset
        _ = s // Prevent unused receiver warning
}</span>

// WithDefaults applies sensible defaults to the configuration
func (c *Config) WithDefaults() *Config <span class="cov8" title="1">{
        config := *c

        if config.PollInterval &lt;= 0 </span><span class="cov8" title="1">{
                config.PollInterval = 5 * time.Second
        }</span>

        <span class="cov8" title="1">if config.CacheTTL &lt;= 0 </span><span class="cov8" title="1">{
                config.CacheTTL = config.PollInterval / 2
        }</span>

        // GUARD RAIL: Ensure CacheTTL &lt;= PollInterval for effectiveness
        <span class="cov8" title="1">if config.CacheTTL &gt; config.PollInterval </span><span class="cov8" title="1">{
                config.CacheTTL = config.PollInterval / 2
        }</span>

        <span class="cov8" title="1">if config.MaxWatchedFiles &lt;= 0 </span><span class="cov8" title="1">{
                config.MaxWatchedFiles = 100
        }</span>

        // Set audit defaults if not configured
        <span class="cov8" title="1">if config.Audit == (AuditConfig{}) </span><span class="cov8" title="1">{
                config.Audit = DefaultAuditConfig()
        }</span>

        // Set BoreasLite optimization defaults
        <span class="cov8" title="1">if config.OptimizationStrategy == OptimizationAuto </span><span class="cov8" title="1">{
                // Auto-strategy remains, will be determined at runtime based on file count
                config.OptimizationStrategy = OptimizationAuto
        }</span>

        // Set BoreasLite capacity based on strategy if not explicitly set
        <span class="cov8" title="1">if config.BoreasLiteCapacity &lt;= 0 </span><span class="cov8" title="1">{
                switch config.OptimizationStrategy </span>{
                case OptimizationSingleEvent:<span class="cov8" title="1">
                        config.BoreasLiteCapacity = 64</span> // Minimal for 1-2 files
                case OptimizationSmallBatch:<span class="cov0" title="0">
                        config.BoreasLiteCapacity = 128</span> // Balanced for 3-20 files
                case OptimizationLargeBatch:<span class="cov0" title="0">
                        config.BoreasLiteCapacity = 256</span> // High throughput for 20+ files
                default:<span class="cov8" title="1"> // OptimizationAuto
                        config.BoreasLiteCapacity = 128</span> // Safe default, will adjust at runtime
                }
        }

        // Ensure capacity is power of 2
        <span class="cov8" title="1">if config.BoreasLiteCapacity &gt; 0 &amp;&amp; (config.BoreasLiteCapacity&amp;(config.BoreasLiteCapacity-1)) != 0 </span><span class="cov0" title="0">{
                // Find next power of 2
                capacity := int64(1)
                for capacity &lt; config.BoreasLiteCapacity </span><span class="cov0" title="0">{
                        capacity &lt;&lt;= 1
                }</span>
                <span class="cov0" title="0">config.BoreasLiteCapacity = capacity</span>
        }

        <span class="cov8" title="1">return &amp;config</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// parser_structured.go: Structured configuration parsers for Argus
//
// This file contains parsers for structured configuration formats:
// - JSON (JavaScript Object Notation)
// - YAML (YAML Ain't Markup Language)
// - TOML (Tom's Obvious Minimal Language)
//
// Copyright (c) 2025 AGILira
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "encoding/json"
        "fmt"
        "strings"
)

// parseJSON parses JSON configuration with pooled map to reduce allocations
func parseJSON(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := getConfigMap()
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                putConfigMap(config)
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>
        // Note: We don't put the config back in the pool since we're returning it
        // The caller is responsible for the memory
        <span class="cov8" title="1">return config, nil</span>
}

// parseYAML parses YAML configuration (simple implementation) with pooled map
func parseYAML(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := getConfigMap()
        lines := strings.Split(string(data), "\n")

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Parse value
                config[key] = parseValue(value)</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}

// parseTOML parses TOML configuration (simple implementation) with pooled map
func parseTOML(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := getConfigMap()
        lines := strings.Split(string(data), "\n")

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Remove quotes from strings
                if strings.HasPrefix(value, "\"") &amp;&amp; strings.HasSuffix(value, "\"") </span><span class="cov8" title="1">{
                        value = strings.Trim(value, "\"")
                }</span>

                <span class="cov8" title="1">config[key] = parseValue(value)</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// parser_text.go: Text-based configuration parsers for Argus
//
// This file contains parsers for text-based configuration formats:
// - HCL (HashiCorp Configuration Language)
// - INI files (with sections)
// - Java Properties files
//
// Copyright (c) 2025 AGILira
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "bufio"
        "strings"
)

// parseHCL parses HCL (HashiCorp Configuration Language) files
func parseHCL(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := make(map[string]interface{})
        lines := strings.Split(string(data), "\n")

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "//") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Remove quotes from strings
                if strings.HasPrefix(value, "\"") &amp;&amp; strings.HasSuffix(value, "\"") </span><span class="cov8" title="1">{
                        value = strings.Trim(value, "\"")
                }</span>

                <span class="cov8" title="1">config[key] = parseValue(value)</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}

// parseINI parses INI configuration
func parseINI(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := make(map[string]interface{})
        lines := strings.Split(string(data), "\n")
        currentSection := ""

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, ";") || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for section header
                <span class="cov8" title="1">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov8" title="1">{
                        currentSection = strings.Trim(line, "[]") + "."
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Prefix with section if we have one
                if currentSection != "" </span><span class="cov8" title="1">{
                        key = currentSection + key
                }</span>

                <span class="cov8" title="1">config[key] = parseValue(value)</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}

// parseProperties parses Java-style properties files
func parseProperties(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := make(map[string]interface{})
        scanner := bufio.NewScanner(strings.NewReader(string(data)))

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "!") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                config[key] = parseValue(value)</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// parsers.go: Universal configuration file parsers for Argus
//
// This file provides parsing support for major configuration formats,
// making Argus truly universal and not a "one-trick pony".
//
// Supported Formats:
// - JSON (.json) - Full production support
// - YAML (.yml, .yaml) - Simple built-in + plugin support
// - TOML (.toml) - Simple built-in + plugin support
// - HCL (.hcl, .tf) - Simple built-in + plugin support
// - INI/Config (.ini, .conf, .cfg) - Simple built-in + plugin support
// - Properties (.properties) - Simple built-in + plugin support
//
// Parser Architecture:
// - Built-in parsers: Simple, fast, zero-dependency for 80% use cases
// - Plugin parsers: Full-featured external parsers for complex production needs
// - Automatic fallback: Try plugins first, fallback to built-in
//
// Copyright (c) 2025 AGILira
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "fmt"
        "strconv"
        "strings"
        "sync"
)

// ConfigFormat represents supported configuration file formats
type ConfigFormat int

const (
        FormatJSON ConfigFormat = iota
        FormatYAML
        FormatTOML
        FormatHCL
        FormatINI
        FormatProperties
        FormatUnknown
)

// ConfigParser defines the interface for pluggable configuration parsers
//
// PRODUCTION PARSER INTEGRATION:
// Go binaries are compiled statically, so "plugins" work via compile-time registration:
//
//  1. IMPORT-BASED REGISTRATION (Recommended):
//     Users import parser libraries that auto-register in init():
//
//     import _ "github.com/your-org/argus-yaml-pro"   // Registers advanced YAML parser
//     import _ "github.com/your-org/argus-toml-pro"   // Registers advanced TOML parser
//
//  2. MANUAL REGISTRATION:
//     Users manually register parsers in their main():
//
//     argus.RegisterParser(&amp;MyAdvancedYAMLParser{})
//
//  3. BUILD TAGS (Advanced):
//     Conditional compilation for different parser sets:
//
//     go build -tags "yaml_pro,toml_pro" ./...
//
// Built-in parsers handle 80% of use cases with zero dependencies.
// Production parsers provide full spec compliance and advanced features.
type ConfigParser interface {
        // Parse parses configuration data for supported formats
        Parse(data []byte) (map[string]interface{}, error)

        // Supports returns true if this parser can handle the given format
        Supports(format ConfigFormat) bool

        // Name returns a human-readable name for this parser (for debugging)
        Name() string
}

// Global registry of custom parsers (production environments can register advanced parsers)
var (
        customParsers []ConfigParser
        parserMutex   sync.RWMutex
)

// RegisterParser registers a custom parser for production use
// Custom parsers are tried before built-in parsers
func RegisterParser(parser ConfigParser) <span class="cov8" title="1">{
        parserMutex.Lock()
        defer parserMutex.Unlock()
        customParsers = append(customParsers, parser)
}</span>

// configMapPool is a sync.Pool for reusing map[string]interface{} to reduce allocations
var configMapPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return make(map[string]interface{})
        }</span>,
}

// getConfigMap gets a map from the pool and clears it
func getConfigMap() map[string]interface{} <span class="cov8" title="1">{
        config := configMapPool.Get().(map[string]interface{})
        // Clear the map for reuse
        for k := range config </span><span class="cov0" title="0">{
                delete(config, k)
        }</span>
        <span class="cov8" title="1">return config</span>
}

// putConfigMap returns a map to the pool
func putConfigMap(config map[string]interface{}) <span class="cov8" title="1">{
        configMapPool.Put(config)
}</span>

// String returns the string representation of the config format
func (cf ConfigFormat) String() string <span class="cov8" title="1">{
        switch cf </span>{
        case FormatJSON:<span class="cov8" title="1">
                return "JSON"</span>
        case FormatYAML:<span class="cov8" title="1">
                return "YAML"</span>
        case FormatTOML:<span class="cov8" title="1">
                return "TOML"</span>
        case FormatHCL:<span class="cov8" title="1">
                return "HCL"</span>
        case FormatINI:<span class="cov8" title="1">
                return "INI"</span>
        case FormatProperties:<span class="cov8" title="1">
                return "Properties"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// DetectFormat detects the configuration format from file extension
// HYPER-OPTIMIZED: Zero allocations, perfect hashing, unrolled loops
// Note: High cyclomatic complexity (38) is justified for optimal performance
// across 7 configuration formats with zero memory allocation
func DetectFormat(filePath string) ConfigFormat <span class="cov8" title="1">{
        length := len(filePath)
        if length &lt; 3 </span><span class="cov8" title="1">{ // Minimum: ".tf"
                return FormatUnknown
        }</span>

        // Fast backward scan with unrolled loop for common extensions
        // Most files are short, so unrolling the common cases is faster

        // Check last 11 chars for .properties (longest extension)
        <span class="cov8" title="1">if length &gt;= 11 &amp;&amp;
                filePath[length-11] == '.' &amp;&amp;
                (filePath[length-10]|32) == 'p' &amp;&amp; // |32 converts to lowercase
                (filePath[length-9]|32) == 'r' &amp;&amp;
                (filePath[length-8]|32) == 'o' &amp;&amp;
                (filePath[length-7]|32) == 'p' &amp;&amp;
                (filePath[length-6]|32) == 'e' &amp;&amp;
                (filePath[length-5]|32) == 'r' &amp;&amp;
                (filePath[length-4]|32) == 't' &amp;&amp;
                (filePath[length-3]|32) == 'i' &amp;&amp;
                (filePath[length-2]|32) == 'e' &amp;&amp;
                (filePath[length-1]|32) == 's' </span><span class="cov8" title="1">{
                return FormatProperties
        }</span>

        // Check last 8 chars for .config
        <span class="cov8" title="1">if length &gt;= 8 &amp;&amp;
                filePath[length-8] == '.' &amp;&amp;
                (filePath[length-7]|32) == 'c' &amp;&amp;
                (filePath[length-6]|32) == 'o' &amp;&amp;
                (filePath[length-5]|32) == 'n' &amp;&amp;
                (filePath[length-4]|32) == 'f' &amp;&amp;
                (filePath[length-3]|32) == 'i' &amp;&amp;
                (filePath[length-2]|32) == 'g' </span><span class="cov0" title="0">{
                return FormatINI
        }</span>

        // Check last 5 chars for common extensions: .json, .yaml, .toml, .conf
        <span class="cov8" title="1">if length &gt;= 5 &amp;&amp; filePath[length-5] == '.' </span><span class="cov8" title="1">{
                b1, b2, b3, b4 := filePath[length-4]|32, filePath[length-3]|32, filePath[length-2]|32, filePath[length-1]|32
                // Perfect hash for 4-char extensions
                switch uint32(b1)&lt;&lt;24 | uint32(b2)&lt;&lt;16 | uint32(b3)&lt;&lt;8 | uint32(b4) </span>{
                case 0x6a736f6e:<span class="cov8" title="1"> // "json"
                        return FormatJSON</span>
                case 0x79616d6c:<span class="cov8" title="1"> // "yaml"
                        return FormatYAML</span>
                case 0x746f6d6c:<span class="cov8" title="1"> // "toml"
                        return FormatTOML</span>
                case 0x636f6e66:<span class="cov8" title="1"> // "conf"
                        return FormatINI</span>
                }
        }

        // Check last 4 chars for: .yml, .hcl, .ini, .cfg
        <span class="cov8" title="1">if length &gt;= 4 &amp;&amp; filePath[length-4] == '.' </span><span class="cov8" title="1">{
                b1, b2, b3 := filePath[length-3]|32, filePath[length-2]|32, filePath[length-1]|32
                // Perfect hash for 3-char extensions
                switch uint32(b1)&lt;&lt;16 | uint32(b2)&lt;&lt;8 | uint32(b3) </span>{
                case 0x796d6c:<span class="cov8" title="1"> // "yml"
                        return FormatYAML</span>
                case 0x68636c:<span class="cov8" title="1"> // "hcl"
                        return FormatHCL</span>
                case 0x696e69:<span class="cov8" title="1"> // "ini"
                        return FormatINI</span>
                case 0x636667:<span class="cov8" title="1"> // "cfg"
                        return FormatINI</span>
                }
        }

        // Check last 3 chars for: .tf
        <span class="cov8" title="1">if length &gt;= 3 &amp;&amp; filePath[length-3] == '.' </span><span class="cov8" title="1">{
                b1, b2 := filePath[length-2]|32, filePath[length-1]|32
                if b1 == 't' &amp;&amp; b2 == 'f' </span><span class="cov8" title="1">{
                        return FormatHCL
                }</span>
        }

        <span class="cov8" title="1">return FormatUnknown</span>
}

// ParseConfig parses configuration data based on the detected format
// HYPER-OPTIMIZED: Fast path for no custom parsers, reduced lock contention
func ParseConfig(data []byte, format ConfigFormat) (map[string]interface{}, error) <span class="cov8" title="1">{
        // Fast path: Check if we have any custom parsers without locking
        // This is safe because customParsers is only appended to, never modified
        if len(customParsers) == 0 </span><span class="cov8" title="1">{
                // No custom parsers, go straight to built-in
                return parseBuiltin(data, format)
        }</span>

        // Slow path: Check custom parsers with minimal lock time
        <span class="cov8" title="1">parserMutex.RLock()
        for _, parser := range customParsers </span><span class="cov8" title="1">{
                if parser.Supports(format) </span><span class="cov8" title="1">{
                        config, err := parser.Parse(data)
                        parserMutex.RUnlock()
                        return config, err
                }</span>
        }
        <span class="cov0" title="0">parserMutex.RUnlock()

        // No custom parser found, use built-in
        return parseBuiltin(data, format)</span>
}

// parseBuiltin handles built-in parsing without any locks
func parseBuiltin(data []byte, format ConfigFormat) (map[string]interface{}, error) <span class="cov8" title="1">{
        switch format </span>{
        case FormatJSON:<span class="cov8" title="1">
                return parseJSON(data)</span>
        case FormatYAML:<span class="cov8" title="1">
                return parseYAML(data)</span>
        case FormatTOML:<span class="cov8" title="1">
                return parseTOML(data)</span>
        case FormatHCL:<span class="cov8" title="1">
                return parseHCL(data)</span>
        case FormatINI:<span class="cov8" title="1">
                return parseINI(data)</span>
        case FormatProperties:<span class="cov8" title="1">
                return parseProperties(data)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }
}

// parseValue attempts to parse a string value into the appropriate type
func parseValue(value string) interface{} <span class="cov8" title="1">{
        // Try boolean
        if strings.ToLower(value) == "true" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.ToLower(value) == "false" </span><span class="cov8" title="1">{
                return false
        }</span>

        // Try integer
        <span class="cov8" title="1">if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                return intVal
        }</span>

        // Try float
        <span class="cov8" title="1">if floatVal, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov8" title="1">{
                return floatVal
        }</span>

        // Return as string
        <span class="cov8" title="1">return value</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// utilities.go: Testing Argus Utilities
//
// Copyright (c) 2025 AGILira
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "fmt"
        "log"
        "os"
)

// copyMap creates a deep copy of a map for audit trail
func copyMap(original map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if original == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">result := make(map[string]interface{})
        for k, v := range original </span><span class="cov8" title="1">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

// UniversalConfigWatcher creates a watcher for ANY configuration format
// Supports JSON, YAML, TOML, HCL, INI, XML, Properties
//
// Example:
//
//        watcher, err := argus.UniversalConfigWatcher("config.yml", func(config map[string]interface{}) {
//            if level, ok := config["level"].(string); ok {
//                // Handle level change
//            }
//            if port, ok := config["port"].(int); ok {
//                // Handle port change
//            }
//        })
func UniversalConfigWatcher(configPath string, callback func(config map[string]interface{})) (*Watcher, error) <span class="cov8" title="1">{
        return UniversalConfigWatcherWithConfig(configPath, callback, Config{})
}</span>

// UniversalConfigWatcherWithConfig creates a watcher for ANY configuration format with custom config
func UniversalConfigWatcherWithConfig(configPath string, callback func(config map[string]interface{}), config Config) (*Watcher, error) <span class="cov8" title="1">{
        // Detect format from file extension
        format := DetectFormat(configPath)
        if format == FormatUnknown </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unsupported config format for file: %s", configPath)
        }</span>

        // Set default error handler if none provided
        <span class="cov8" title="1">if config.ErrorHandler == nil </span><span class="cov8" title="1">{
                config.ErrorHandler = func(err error, path string) </span><span class="cov8" title="1">{
                        log.Printf("Argus: error in file %s: %v", path, err)
                }</span>
        }

        <span class="cov8" title="1">watcher := New(config)

        // Track current config for audit trail
        var currentConfig map[string]interface{}

        watchCallback := func(event ChangeEvent) </span><span class="cov8" title="1">{
                if event.IsDelete </span><span class="cov0" title="0">{
                        // AUDIT: Log file deletion
                        if auditor := watcher.auditLogger; auditor != nil </span><span class="cov0" title="0">{
                                auditor.LogFileWatch("config_deleted", event.Path)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov8" title="1">data, err := os.ReadFile(event.Path)
                if err != nil </span><span class="cov8" title="1">{
                        if watcher.config.ErrorHandler != nil </span><span class="cov8" title="1">{
                                watcher.config.ErrorHandler(fmt.Errorf("failed to read config file: %w", err), event.Path)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">newConfig, err := ParseConfig(data, format)
                if err != nil </span><span class="cov8" title="1">{
                        if watcher.config.ErrorHandler != nil </span><span class="cov8" title="1">{
                                watcher.config.ErrorHandler(fmt.Errorf("failed to parse %s config: %w", format, err), event.Path)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                // AUDIT: Log configuration change with before/after values
                <span class="cov8" title="1">if auditor := watcher.auditLogger; auditor != nil </span><span class="cov8" title="1">{
                        auditor.LogConfigChange(event.Path, currentConfig, newConfig)
                }</span>

                // Update current config for next comparison
                <span class="cov8" title="1">currentConfig = copyMap(newConfig)

                callback(newConfig)</span>
        }

        <span class="cov8" title="1">if err := watcher.Watch(configPath, watchCallback); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to watch config file: %w", err)
        }</span>

        // Load initial configuration and start watcher
        <span class="cov8" title="1">if _, err := os.Stat(configPath); err == nil </span><span class="cov8" title="1">{
                data, err := os.ReadFile(configPath) // #nosec G304 -- configPath is user-provided intentionally
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read initial config file: %w", err)
                }</span>

                <span class="cov8" title="1">initialConfig, err := ParseConfig(data, format)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse initial %s config: %w", format, err)
                }</span>

                // Set current config for audit trail
                <span class="cov8" title="1">currentConfig = copyMap(initialConfig)

                // Auto-start the watcher (convenience feature)
                if err := watcher.Start(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to start watcher: %w", err)
                }</span>

                // Call callback with initial config
                <span class="cov8" title="1">callback(initialConfig)</span>
        } else<span class="cov8" title="1"> {
                // File doesn't exist yet, start watcher anyway
                if err := watcher.Start(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to start watcher: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return watcher, nil</span>
}

// GenericConfigWatcher creates a watcher for JSON configuration (backward compatibility)
// DEPRECATED: Use UniversalConfigWatcher for better format support
func GenericConfigWatcher(configPath string, callback func(config map[string]interface{})) (*Watcher, error) <span class="cov8" title="1">{
        return UniversalConfigWatcher(configPath, callback)
}</span>

// SimpleFileWatcher creates a basic file watcher with minimal configuration
// Useful for simple use cases where you just want to know when a file changes
func SimpleFileWatcher(filePath string, callback func(path string)) (*Watcher, error) <span class="cov8" title="1">{
        watcher := New(Config{})

        watchCallback := func(event ChangeEvent) </span><span class="cov8" title="1">{
                if !event.IsDelete </span><span class="cov8" title="1">{
                        callback(event.Path)
                }</span>
        }

        <span class="cov8" title="1">if err := watcher.Watch(filePath, watchCallback); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to watch file: %w", err)
        }</span>

        <span class="cov8" title="1">return watcher, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

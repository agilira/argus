
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>argus: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/agilira/argus/argus.go (90.7%)</option>
				
				<option value="file1">github.com/agilira/argus/audit.go (90.7%)</option>
				
				<option value="file2">github.com/agilira/argus/audit_backend.go (78.5%)</option>
				
				<option value="file3">github.com/agilira/argus/boreaslite.go (98.7%)</option>
				
				<option value="file4">github.com/agilira/argus/cmd/cli/handlers.go (0.0%)</option>
				
				<option value="file5">github.com/agilira/argus/cmd/cli/manager.go (98.2%)</option>
				
				<option value="file6">github.com/agilira/argus/cmd/cli/utils.go (69.7%)</option>
				
				<option value="file7">github.com/agilira/argus/config.go (70.4%)</option>
				
				<option value="file8">github.com/agilira/argus/config_binder.go (93.0%)</option>
				
				<option value="file9">github.com/agilira/argus/config_validation.go (89.0%)</option>
				
				<option value="file10">github.com/agilira/argus/config_writer.go (66.4%)</option>
				
				<option value="file11">github.com/agilira/argus/env_config.go (89.9%)</option>
				
				<option value="file12">github.com/agilira/argus/examples/import_based_providers/main.go (0.0%)</option>
				
				<option value="file13">github.com/agilira/argus/integration.go (89.4%)</option>
				
				<option value="file14">github.com/agilira/argus/parser_structured.go (73.8%)</option>
				
				<option value="file15">github.com/agilira/argus/parser_text.go (82.1%)</option>
				
				<option value="file16">github.com/agilira/argus/parsers.go (94.4%)</option>
				
				<option value="file17">github.com/agilira/argus/providers/redis/argus_provider_redis.go (84.0%)</option>
				
				<option value="file18">github.com/agilira/argus/remote_config.go (86.1%)</option>
				
				<option value="file19">github.com/agilira/argus/remote_config_fallback.go (76.5%)</option>
				
				<option value="file20">github.com/agilira/argus/utilities.go (89.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// argus: Ultra-lightweight configuration watcher with BoreasLite ultra-fast ring buffer
//
// Philosophy:
// - Minimal dependencies (AGILira ecosystem only: go-errors, go-timecache)
// - Polling-based approach for maximum OS portability
// - Intelligent caching to minimize os.Stat() syscalls (like go-timecache)
// - Thread-safe atomic operations
// - Zero allocations in hot paths
// - Configurable polling intervals
//
// Example Usage:
//   watcher := argus.New(argus.Config{
//       PollInterval: 5 * time.Second,
//       CacheTTL:     2 * time.Second,
//   })
//
//   watcher.Watch("config.json", func(event argus.ChangeEvent) {
//       // Handle configuration change
//       newConfig, err := LoadConfig(event.Path)
//       if err == nil {
//           atomicLevel.SetLevel(newConfig.Level)
//       }
//   })
//
//   watcher.Start()
//   defer watcher.Stop()
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/agilira/go-errors"
        "github.com/agilira/go-timecache"
)

// fileStat caches file metadata to minimize os.Stat() calls
// Using value types instead of pointers to avoid use-after-free in concurrent access

// Error codes for Argus operations
const (
        ErrCodeInvalidConfig          = "ARGUS_INVALID_CONFIG"
        ErrCodeFileNotFound           = "ARGUS_FILE_NOT_FOUND"
        ErrCodeWatcherStopped         = "ARGUS_WATCHER_STOPPED"
        ErrCodeWatcherBusy            = "ARGUS_WATCHER_BUSY"
        ErrCodeRemoteConfigError      = "ARGUS_REMOTE_CONFIG_ERROR"
        ErrCodeConfigNotFound         = "ARGUS_CONFIG_NOT_FOUND"
        ErrCodeInvalidPollInterval    = "ARGUS_INVALID_POLL_INTERVAL"
        ErrCodeInvalidCacheTTL        = "ARGUS_INVALID_CACHE_TTL"
        ErrCodeInvalidMaxWatchedFiles = "ARGUS_INVALID_MAX_WATCHED_FILES"
        ErrCodeInvalidOptimization    = "ARGUS_INVALID_OPTIMIZATION"
        ErrCodeInvalidAuditConfig     = "ARGUS_INVALID_AUDIT_CONFIG"
        ErrCodeInvalidBufferSize      = "ARGUS_INVALID_BUFFER_SIZE"
        ErrCodeInvalidFlushInterval   = "ARGUS_INVALID_FLUSH_INTERVAL"
        ErrCodeInvalidOutputFile      = "ARGUS_INVALID_OUTPUT_FILE"
        ErrCodeUnwritableOutputFile   = "ARGUS_UNWRITABLE_OUTPUT_FILE"
        ErrCodeCacheTTLTooLarge       = "ARGUS_CACHE_TTL_TOO_LARGE"
        ErrCodePollIntervalTooSmall   = "ARGUS_POLL_INTERVAL_TOO_SMALL"
        ErrCodeMaxFilesTooLarge       = "ARGUS_MAX_FILES_TOO_LARGE"
        ErrCodeBoreasCapacityInvalid  = "ARGUS_INVALID_BOREAS_CAPACITY"
        ErrCodeConfigWriterError      = "ARGUS_CONFIG_WRITER_ERROR"
        ErrCodeSerializationError     = "ARGUS_SERIALIZATION_ERROR"
        ErrCodeIOError                = "ARGUS_IO_ERROR"
)

// ChangeEvent represents a file change notification
type ChangeEvent struct {
        Path     string    // File path that changed
        ModTime  time.Time // New modification time
        Size     int64     // New file size
        IsCreate bool      // True if file was created
        IsDelete bool      // True if file was deleted
        IsModify bool      // True if file was modified
}

// UpdateCallback is called when a watched file changes
type UpdateCallback func(event ChangeEvent)

// ErrorHandler is called when errors occur during file watching or parsing
// It receives the error and the file path where the error occurred
type ErrorHandler func(err error, filepath string)

// OptimizationStrategy defines how BoreasLite should optimize performance
type OptimizationStrategy int

const (
        // OptimizationAuto automatically chooses the best strategy based on file count
        // - 1-3 files: SingleEvent strategy (ultra-low latency)
        // - 4-20 files: SmallBatch strategy (balanced)
        // - 21+ files: LargeBatch strategy (high throughput)
        OptimizationAuto OptimizationStrategy = iota

        // OptimizationSingleEvent optimizes for 1-2 files with ultra-low latency
        // - Fast path for single events (24ns)
        // - Minimal batching overhead
        // - Aggressive spinning for immediate processing
        OptimizationSingleEvent

        // OptimizationSmallBatch optimizes for 3-20 files with balanced performance
        // - Small batch sizes (2-8 events)
        // - Moderate spinning with short sleeps
        // - Good balance between latency and throughput
        OptimizationSmallBatch

        // OptimizationLargeBatch optimizes for 20+ files with high throughput
        // - Large batch sizes (16-64 events)
        // - Zephyros-style 4x unrolling
        // - Focus on maximum throughput over latency
        OptimizationLargeBatch
)

// Config configures the Argus watcher behavior
type Config struct {
        // PollInterval is how often to check for file changes
        // Default: 5 seconds (good balance of responsiveness vs overhead)
        PollInterval time.Duration

        // CacheTTL is how long to cache os.Stat() results
        // Should be &lt;= PollInterval for effectiveness
        // Default: PollInterval / 2
        CacheTTL time.Duration

        // MaxWatchedFiles limits the number of files that can be watched
        // Default: 100 (generous for config files)
        MaxWatchedFiles int

        // Audit configuration for security and compliance
        // Default: Enabled with secure defaults
        Audit AuditConfig

        // ErrorHandler is called when errors occur during file watching/parsing
        // If nil, errors are logged to stderr (backward compatible)
        // Example: func(err error, path string) { metrics.Increment("config.errors") }
        ErrorHandler ErrorHandler

        // OptimizationStrategy determines how BoreasLite optimizes performance
        // - OptimizationAuto: Automatically choose based on file count (default)
        // - OptimizationSingleEvent: Ultra-low latency for 1-2 files
        // - OptimizationSmallBatch: Balanced for 3-20 files
        // - OptimizationLargeBatch: High throughput for 20+ files
        OptimizationStrategy OptimizationStrategy

        // BoreasLiteCapacity sets the ring buffer size (must be power of 2)
        // - Auto/SingleEvent: 64 (minimal memory)
        // - SmallBatch: 128 (balanced)
        // - LargeBatch: 256+ (high throughput)
        // Default: 0 (auto-calculated based on strategy)
        BoreasLiteCapacity int64

        // Remote configuration with automatic fallback capabilities
        // When enabled, provides distributed configuration management with local fallback
        // Default: Disabled for backward compatibility
        Remote RemoteConfig
}

// RemoteConfig defines distributed configuration management with automatic fallback.
// This struct enables enterprise-grade remote configuration loading with resilient
// fallback capabilities for production deployments where configuration comes from
// distributed systems (Consul, etcd, Redis) but local fallback is required.
//
// The RemoteConfig system implements the following fallback sequence:
// 1. Attempt to load from PrimaryURL (e.g., consul://prod-consul/myapp/config)
// 2. On failure, attempt FallbackURL if configured (e.g., consul://backup-consul/myapp/config)
// 3. On complete remote failure, load from FallbackPath (e.g., /etc/myapp/fallback-config.json)
// 4. Continue with SyncInterval for automatic recovery when remote systems recover
//
// Zero-allocation design: All URLs and paths are pre-parsed and cached during
// initialization to avoid allocations during runtime operations.
//
// Production deployment patterns:
//
//        // Consul with local fallback (recommended)
//        Remote: RemoteConfig{
//            Enabled:      true,
//            PrimaryURL:   "consul://prod-consul:8500/config/myapp",
//            FallbackPath: "/etc/myapp/config.json",
//            SyncInterval: 30 * time.Second,
//            Timeout:      10 * time.Second,
//        }
//
//        // Multi-datacenter setup with remote fallback
//        Remote: RemoteConfig{
//            Enabled:      true,
//            PrimaryURL:   "consul://dc1-consul:8500/config/myapp",
//            FallbackURL:  "consul://dc2-consul:8500/config/myapp",
//            FallbackPath: "/etc/myapp/emergency-config.json",
//            SyncInterval: 60 * time.Second,
//        }
//
//        // Redis with backup Redis
//        Remote: RemoteConfig{
//            Enabled:     true,
//            PrimaryURL:  "redis://prod-redis:6379/0/myapp:config",
//            FallbackURL: "redis://backup-redis:6379/0/myapp:config",
//            SyncInterval: 15 * time.Second,
//        }
//
// Thread safety: RemoteConfig operations are thread-safe and can be called
// concurrently from multiple goroutines without external synchronization.
//
// Error handling: Failed remote loads automatically trigger fallback sequence.
// Applications receive the most recent successful configuration and error notifications
// through the standard ErrorHandler mechanism.
//
// Monitoring integration: All remote configuration operations generate audit events
// for monitoring, alerting, and compliance tracking in production environments.
type RemoteConfig struct {
        // Enabled controls whether remote configuration loading is active
        // Default: false (for backward compatibility)
        // When false, all other RemoteConfig fields are ignored
        Enabled bool `json:"enabled" yaml:"enabled" toml:"enabled"`

        // PrimaryURL is the main remote configuration source
        // Supports all registered remote providers (consul://, redis://, etcd://, http://, https://)
        // Examples:
        //   - "consul://prod-consul:8500/config/myapp?datacenter=dc1"
        //   - "redis://prod-redis:6379/0/myapp:config"
        //   - "etcd://prod-etcd:2379/config/myapp"
        //   - "https://config-api.company.com/api/v1/config/myapp"
        // Required when Enabled=true
        PrimaryURL string `json:"primary_url" yaml:"primary_url" toml:"primary_url"`

        // FallbackURL is an optional secondary remote configuration source
        // Used when PrimaryURL fails but before falling back to local file
        // Should typically be a different instance/datacenter of the same system
        // Examples:
        //   - "consul://backup-consul:8500/config/myapp"
        //   - "redis://backup-redis:6379/0/myapp:config"
        // Optional: can be empty to skip remote fallback
        FallbackURL string `json:"fallback_url,omitempty" yaml:"fallback_url,omitempty" toml:"fallback_url,omitempty"`

        // FallbackPath is a local file path used when all remote sources fail
        // This provides the ultimate fallback for high-availability deployments
        // The file should contain a valid configuration in JSON, YAML, or TOML format
        // Examples:
        //   - "/etc/myapp/emergency-config.json"
        //   - "/opt/myapp/fallback-config.yaml"
        //   - "./config/local-fallback.toml"
        // Recommended: Always configure for production deployments
        FallbackPath string `json:"fallback_path,omitempty" yaml:"fallback_path,omitempty" toml:"fallback_path,omitempty"`

        // SyncInterval controls how often to check for remote configuration updates
        // This applies to all remote sources (primary and fallback)
        // Shorter intervals provide faster updates but increase system load
        // Default: 30 seconds (good balance for most applications)
        // Production considerations:
        //   - High-frequency apps: 10-15 seconds
        //   - Standard apps: 30-60 seconds
        //   - Batch jobs: 5+ minutes
        SyncInterval time.Duration `json:"sync_interval" yaml:"sync_interval" toml:"sync_interval"`

        // Timeout controls the maximum time to wait for each remote configuration request
        // Applied to both primary and fallback URL requests
        // Should be shorter than SyncInterval to allow for fallback attempts
        // Default: 10 seconds (allows for network latency and processing)
        // Production recommendations:
        //   - Local network: 5-10 seconds
        //   - Cross-datacenter: 10-20 seconds
        //   - Internet-based: 20-30 seconds
        Timeout time.Duration `json:"timeout" yaml:"timeout" toml:"timeout"`

        // MaxRetries controls retry attempts for failed remote requests
        // Applied per URL (primary/fallback) before moving to next fallback level
        // Default: 2 (total of 3 attempts: initial + 2 retries)
        // Higher values increase reliability but also increase latency during failures
        MaxRetries int `json:"max_retries" yaml:"max_retries" toml:"max_retries"`

        // RetryDelay is the base delay between retry attempts
        // Uses exponential backoff: attempt N waits RetryDelay * 2^N
        // Default: 1 second (results in 1s, 2s, 4s... delays)
        // Should be balanced with Timeout to ensure retries fit within timeout window
        RetryDelay time.Duration `json:"retry_delay" yaml:"retry_delay" toml:"retry_delay"`
}

// fileStat represents cached file statistics for efficient os.Stat() caching.
// Uses value types and timecache for zero-allocation performance optimization.
type fileStat struct {
        modTime  time.Time // Last modification time from os.Stat()
        size     int64     // File size in bytes
        exists   bool      // Whether the file exists
        cachedAt int64     // Use timecache nano timestamp for zero-allocation timing
}

// isExpired checks if the cached stat is expired using timecache for zero-allocation timing
func (fs *fileStat) isExpired(ttl time.Duration) bool <span class="cov8" title="1">{
        now := timecache.CachedTimeNano()
        return (now - fs.cachedAt) &gt; int64(ttl)
}</span>

// watchedFile represents a file under observation with its callback and cached state.
// Optimized for minimal memory footprint and fast access during polling.
type watchedFile struct {
        path     string         // Absolute file path being watched
        callback UpdateCallback // User-provided callback for file changes
        lastStat fileStat       // Cached file statistics for change detection
}

// Watcher monitors configuration files for changes
// ULTRA-OPTIMIZED: Uses BoreasLite MPSC ring buffer + lock-free cache for maximum performance
type Watcher struct {
        config  Config
        files   map[string]*watchedFile
        filesMu sync.RWMutex

        // LOCK-FREE CACHE: Uses atomic.Pointer for zero-contention reads
        statCache atomic.Pointer[map[string]fileStat]

        // ZERO-ALLOCATION POLLING: Reusable slice to avoid allocations in pollFiles
        filesBuffer []*watchedFile

        // BOREAS LITE: Ultra-fast MPSC ring buffer for file events (DEFAULT)
        eventRing *BoreasLite

        // AUDIT SYSTEM: Comprehensive security and compliance logging
        auditLogger *AuditLogger

        running   atomic.Bool
        stopped   atomic.Bool // Tracks if explicitly stopped vs just not started
        stopCh    chan struct{}
        stoppedCh chan struct{}
        ctx       context.Context
        cancel    context.CancelFunc
}

// New creates a new Argus file watcher with BoreasLite integration
func New(config Config) *Watcher <span class="cov8" title="1">{
        cfg := config.WithDefaults()
        ctx, cancel := context.WithCancel(context.Background())

        // Initialize audit logger
        auditLogger, err := NewAuditLogger(cfg.Audit)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to disabled audit if setup fails
                auditLogger, _ = NewAuditLogger(AuditConfig{Enabled: false})
        }</span>

        <span class="cov8" title="1">watcher := &amp;Watcher{
                config:      *cfg,
                files:       make(map[string]*watchedFile),
                auditLogger: auditLogger,
                stopCh:      make(chan struct{}),
                stoppedCh:   make(chan struct{}),
                ctx:         ctx,
                cancel:      cancel,
        }

        // Initialize lock-free cache
        initialCache := make(map[string]fileStat)
        watcher.statCache.Store(&amp;initialCache)

        // Initialize BoreasLite MPSC ring buffer with configured strategy
        watcher.eventRing = NewBoreasLite(
                watcher.config.BoreasLiteCapacity,
                watcher.config.OptimizationStrategy,
                watcher.processFileEvent,
        )

        return watcher</span>
}

// processFileEvent processes events from the BoreasLite ring buffer
// This method is called by BoreasLite for each file change event
func (w *Watcher) processFileEvent(fileEvent *FileChangeEvent) <span class="cov8" title="1">{
        // CRITICAL: Panic recovery to prevent callback panics from crashing the watcher
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        w.auditLogger.LogFileWatch("callback_panic", string(fileEvent.Path[:]))
                }</span>
        }()

        // Convert BoreasLite event back to standard ChangeEvent
        <span class="cov8" title="1">event := ConvertFileEventToChangeEvent(*fileEvent)

        // Find the corresponding watched file and call its callback
        w.filesMu.RLock()
        if wf, exists := w.files[event.Path]; exists </span><span class="cov8" title="1">{
                // Call the user's callback function
                wf.callback(event)

                // Log basic file change to audit system
                w.auditLogger.LogFileWatch("file_changed", event.Path)
        }</span>
        <span class="cov8" title="1">w.filesMu.RUnlock()</span>
}

// Watch adds a file to the watch list
func (w *Watcher) Watch(path string, callback UpdateCallback) error <span class="cov8" title="1">{
        if callback == nil </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "callback cannot be nil")
        }</span>

        // Check if watcher was explicitly stopped (not just not started)
        <span class="cov8" title="1">if w.stopped.Load() </span><span class="cov8" title="1">{
                return errors.New(ErrCodeWatcherStopped, "cannot add watch to stopped watcher")
        }</span>

        // Validate and secure the path
        <span class="cov8" title="1">absPath, err := w.validateAndSecurePath(path)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // AUDIT: Log file watch start
        <span class="cov8" title="1">w.auditLogger.LogFileWatch("watch_start", absPath)

        return w.addWatchedFile(absPath, callback)</span>
}

// validateAndSecurePath validates path security and returns absolute path
func (w *Watcher) validateAndSecurePath(path string) (string, error) <span class="cov8" title="1">{
        // SECURITY FIX: Validate path before processing to prevent path traversal attacks
        if err := ValidateSecurePath(path); err != nil </span><span class="cov8" title="1">{
                // AUDIT: Log security event for path traversal attempt
                w.auditLogger.LogSecurityEvent("path_traversal_attempt", "Rejected malicious file path",
                        map[string]interface{}{
                                "rejected_path": path,
                                "reason":        err.Error(),
                        })
                return "", errors.Wrap(err, ErrCodeInvalidConfig, "invalid or unsafe file path").
                        WithContext("path", path)
        }</span>

        <span class="cov8" title="1">absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, ErrCodeInvalidConfig, "invalid file path").
                        WithContext("path", path)
        }</span>

        // SECURITY: Double-check absolute path after resolution
        <span class="cov8" title="1">if err := ValidateSecurePath(absPath); err != nil </span><span class="cov0" title="0">{
                w.auditLogger.LogSecurityEvent("path_traversal_attempt", "Rejected malicious absolute path",
                        map[string]interface{}{
                                "rejected_path": absPath,
                                "original_path": path,
                                "reason":        err.Error(),
                        })
                return "", errors.Wrap(err, ErrCodeInvalidConfig, "resolved path is unsafe").
                        WithContext("absolute_path", absPath).
                        WithContext("original_path", path)
        }</span>

        // SECURITY: Check for symlink traversal attacks
        // If the path is a symlink, verify that its target is also safe
        <span class="cov8" title="1">if info, err := os.Lstat(absPath); err == nil &amp;&amp; info.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov8" title="1">{
                target, err := filepath.EvalSymlinks(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        // If we can't resolve the symlink target, reject it for security
                        w.auditLogger.LogSecurityEvent("symlink_traversal_attempt", "Symlink target resolution failed",
                                map[string]interface{}{
                                        "symlink_path": absPath,
                                        "reason":       err.Error(),
                                })
                        return "", errors.Wrap(err, ErrCodeInvalidConfig, "cannot resolve symlink target").
                                WithContext("symlink_path", absPath)
                }</span>

                // Validate the symlink target
                <span class="cov8" title="1">if err := ValidateSecurePath(target); err != nil </span><span class="cov8" title="1">{
                        w.auditLogger.LogSecurityEvent("symlink_traversal_attempt", "Symlink points to dangerous target",
                                map[string]interface{}{
                                        "symlink_path": absPath,
                                        "target_path":  target,
                                        "reason":       err.Error(),
                                })
                        return "", errors.Wrap(err, ErrCodeInvalidConfig, "symlink target is unsafe").
                                WithContext("symlink_path", absPath).
                                WithContext("target_path", target)
                }</span>

                // Update absPath to the resolved target for consistency
                <span class="cov0" title="0">absPath = target</span>
        }

        // Validate symlinks
        <span class="cov8" title="1">if err := w.validateSymlinks(absPath, path); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return absPath, nil</span>
}

// validateSymlinks checks symlink security
func (w *Watcher) validateSymlinks(absPath, originalPath string) error <span class="cov8" title="1">{
        // SECURITY: Symlink resolution check
        // Resolve any symlinks and validate the final target path
        realPath, err := filepath.EvalSymlinks(absPath)
        if err == nil &amp;&amp; realPath != absPath </span><span class="cov0" title="0">{
                // Path contains symlinks - validate the resolved target
                if err := ValidateSecurePath(realPath); err != nil </span><span class="cov0" title="0">{
                        w.auditLogger.LogSecurityEvent("symlink_traversal_attempt", "Symlink points to unsafe location",
                                map[string]interface{}{
                                        "symlink_path":  absPath,
                                        "resolved_path": realPath,
                                        "original_path": originalPath,
                                        "reason":        err.Error(),
                                })
                        return errors.Wrap(err, ErrCodeInvalidConfig, "symlink target is unsafe").
                                WithContext("symlink_path", absPath).
                                WithContext("resolved_path", realPath).
                                WithContext("original_path", originalPath)
                }</span>

                // Additional check: ensure symlink doesn't escape to system directories
                <span class="cov0" title="0">if w.isSystemDirectory(realPath) </span><span class="cov0" title="0">{
                        w.auditLogger.LogSecurityEvent("symlink_system_access", "Symlink attempts to access system directory",
                                map[string]interface{}{
                                        "symlink_path":  absPath,
                                        "resolved_path": realPath,
                                        "original_path": originalPath,
                                })
                        return errors.New(ErrCodeInvalidConfig, "symlink target accesses restricted system directory").
                                WithContext("symlink_path", absPath).
                                WithContext("resolved_path", realPath)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// isSystemDirectory checks if path points to system directory
func (w *Watcher) isSystemDirectory(path string) bool <span class="cov0" title="0">{
        lowerPath := strings.ToLower(path)
        return strings.HasPrefix(path, "/etc/") ||
                strings.HasPrefix(path, "/proc/") ||
                strings.HasPrefix(path, "/sys/") ||
                strings.HasPrefix(path, "/dev/") ||
                strings.Contains(lowerPath, "windows\\system32") ||
                strings.Contains(lowerPath, "program files")
}</span>

// addWatchedFile adds the file to watch list with proper locking
func (w *Watcher) addWatchedFile(absPath string, callback UpdateCallback) error <span class="cov8" title="1">{
        w.filesMu.Lock()
        defer w.filesMu.Unlock()

        if len(w.files) &gt;= w.config.MaxWatchedFiles </span><span class="cov8" title="1">{
                // AUDIT: Log security event for limit exceeded
                w.auditLogger.LogSecurityEvent("watch_limit_exceeded", "Maximum watched files exceeded",
                        map[string]interface{}{
                                "path":          absPath,
                                "max_files":     w.config.MaxWatchedFiles,
                                "current_files": len(w.files),
                        })
                return errors.New(ErrCodeInvalidConfig, "maximum watched files exceeded").
                        WithContext("max_files", w.config.MaxWatchedFiles).
                        WithContext("current_files", len(w.files))
        }</span>

        // Get initial file stat
        <span class="cov8" title="1">initialStat, err := w.getStat(absPath)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return errors.Wrap(err, ErrCodeFileNotFound, "failed to stat file").
                        WithContext("path", absPath)
        }</span>

        <span class="cov8" title="1">w.files[absPath] = &amp;watchedFile{
                path:     absPath,
                callback: callback,
                lastStat: initialStat,
        }

        // Adapt BoreasLite strategy based on file count (if Auto mode)
        if w.eventRing != nil </span><span class="cov8" title="1">{
                w.eventRing.AdaptStrategy(len(w.files))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Unwatch removes a file from the watch list
func (w *Watcher) Unwatch(path string) error <span class="cov8" title="1">{
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, ErrCodeInvalidConfig, "invalid file path").
                        WithContext("path", path)
        }</span>

        <span class="cov8" title="1">w.filesMu.Lock()
        defer w.filesMu.Unlock()

        delete(w.files, absPath)

        // Adapt BoreasLite strategy based on updated file count (if Auto mode)
        if w.eventRing != nil </span><span class="cov8" title="1">{
                w.eventRing.AdaptStrategy(len(w.files))
        }</span>

        // Clean up cache entry atomically
        <span class="cov8" title="1">w.removeFromCache(absPath)

        return nil</span>
}

// Start begins watching files for changes
func (w *Watcher) Start() error <span class="cov8" title="1">{
        if !w.running.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                return errors.New(ErrCodeWatcherBusy, "watcher is already running")
        }</span>

        // Start BoreasLite event processor in background
        <span class="cov8" title="1">go w.eventRing.RunProcessor()

        // Start main polling loop
        go w.watchLoop()
        return nil</span>
}

// Stop stops the watcher and waits for cleanup
func (w *Watcher) Stop() error <span class="cov8" title="1">{
        if !w.running.CompareAndSwap(true, false) </span><span class="cov8" title="1">{
                return errors.New(ErrCodeWatcherStopped, "watcher is not running")
        }</span>

        <span class="cov8" title="1">w.stopped.Store(true) // Mark as explicitly stopped
        w.cancel()
        close(w.stopCh)
        &lt;-w.stoppedCh

        // Stop BoreasLite event processor
        w.eventRing.Stop()

        // CRITICAL FIX: Close audit logger to prevent resource leaks
        if w.auditLogger != nil </span><span class="cov8" title="1">{
                _ = w.auditLogger.Close()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsRunning returns true if the watcher is currently running
func (w *Watcher) IsRunning() bool <span class="cov8" title="1">{
        return w.running.Load()
}</span>

// Close is an alias for Stop() for better resource management patterns
// Implements the common Close() interface for easy integration with defer statements
func (w *Watcher) Close() error <span class="cov8" title="1">{
        return w.Stop()
}</span>

// GracefulShutdown performs a graceful shutdown with timeout control.
// This method provides production-grade shutdown capabilities with deterministic timeout handling,
// ensuring all resources are properly cleaned up without hanging indefinitely.
//
// The method performs the following shutdown sequence:
// 1. Signals shutdown intent to all goroutines via context cancellation
// 2. Waits for all file polling operations to complete
// 3. Flushes all pending audit events to persistent storage
// 4. Closes BoreasLite ring buffer and releases memory
// 5. Cleans up file descriptors and other system resources
//
// Zero-allocation design: Uses pre-allocated channels and avoids heap allocations
// during the shutdown process to maintain performance characteristics even during termination.
//
// Example usage:
//
//        watcher := argus.New(config)
//        defer watcher.GracefulShutdown(30 * time.Second) // 30s timeout for Kubernetes
//
//        // Kubernetes deployment
//        watcher := argus.New(config)
//        defer watcher.GracefulShutdown(time.Duration(terminationGracePeriodSeconds) * time.Second)
//
//        // CI/CD pipelines
//        watcher := argus.New(config)
//        defer watcher.GracefulShutdown(10 * time.Second) // Fast shutdown for tests
//
// Parameters:
//   - timeout: Maximum time to wait for graceful shutdown. If exceeded, the method returns
//     an error but resources are still cleaned up in the background.
//
// Returns:
//   - nil if shutdown completed within timeout
//   - ErrCodeWatcherStopped if watcher was already stopped
//   - ErrCodeWatcherBusy if shutdown timeout was exceeded (resources still cleaned up)
//
// Thread-safety: Safe to call from multiple goroutines. First caller wins, subsequent
// calls return immediately with appropriate status.
//
// Production considerations:
//   - Kubernetes: Use terminationGracePeriodSeconds - 5s to allow for signal propagation
//   - Docker: Typically 10-30 seconds is sufficient
//   - CI/CD: Use shorter timeouts (5-10s) for faster test cycles
//   - Load balancers: Ensure timeout exceeds health check intervals
func (w *Watcher) GracefulShutdown(timeout time.Duration) error <span class="cov8" title="1">{
        // Fast path: Check if already stopped without allocations
        if !w.running.Load() </span><span class="cov8" title="1">{
                return errors.New(ErrCodeWatcherStopped, "watcher is not running")
        }</span>

        // Pre-validate timeout to avoid work if invalid
        <span class="cov8" title="1">if timeout &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "graceful shutdown timeout must be positive")
        }</span>

        // Create timeout context - this is the only allocation we make
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // Channel for shutdown completion signaling (buffered to avoid blocking)
        // Pre-allocated with capacity 1 to prevent goroutine leaks
        done := make(chan error, 1)

        // Execute shutdown in separate goroutine to respect timeout
        go func() </span><span class="cov8" title="1">{
                // Use existing Stop() method which handles all cleanup logic
                // This avoids code duplication and maintains consistency
                err := w.Stop()
                select </span>{
                case done &lt;- err:<span class="cov8" title="1"></span>
                        // Successfully sent result
                default:<span class="cov0" title="0"></span>
                        // Channel full (timeout already occurred), ignore
                        // The shutdown still completes in background for resource safety
                }
        }()

        // Wait for completion or timeout
        // Zero additional allocations in this critical path
        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                // Shutdown completed within timeout
                if err != nil </span><span class="cov0" title="0">{
                        // Wrap the error to provide context about graceful shutdown
                        return errors.Wrap(err, ErrCodeWatcherStopped, "graceful shutdown encountered error")
                }</span>
                <span class="cov8" title="1">return nil</span>

        case &lt;-ctx.Done():<span class="cov0" title="0">
                // Timeout exceeded - return error but allow background cleanup to continue
                // This ensures resources are eventually freed even if timeout is too short
                return errors.New(ErrCodeWatcherBusy,
                        fmt.Sprintf("graceful shutdown timeout (%v) exceeded, cleanup continuing in background", timeout))</span>
        }
}

// WatchedFiles returns the number of currently watched files
func (w *Watcher) WatchedFiles() int <span class="cov8" title="1">{
        w.filesMu.RLock()
        defer w.filesMu.RUnlock()
        return len(w.files)
}</span>

// getStat returns cached file statistics or performs os.Stat if cache is expired
// LOCK-FREE: Uses atomic.Pointer for zero-contention cache access with value types
func (w *Watcher) getStat(path string) (fileStat, error) <span class="cov8" title="1">{
        // Fast path: atomic read of cache (ZERO locks!)
        cacheMap := *w.statCache.Load()
        if cached, exists := cacheMap[path]; exists </span><span class="cov8" title="1">{
                // Check expiration without any locks
                if !cached.isExpired(w.config.CacheTTL) </span><span class="cov8" title="1">{
                        return cached, nil
                }</span>
        }

        // Slow path: cache miss or expired - perform actual os.Stat()
        <span class="cov8" title="1">info, err := os.Stat(path)
        stat := fileStat{
                cachedAt: timecache.CachedTimeNano(), // Use timecache for zero-allocation timestamp
                exists:   err == nil,
        }

        if err == nil </span><span class="cov8" title="1">{
                stat.modTime = info.ModTime()
                stat.size = info.Size()
        }</span>

        // Update cache atomically (copy-on-write)
        <span class="cov8" title="1">w.updateCache(path, stat)

        // Return by value (no pointer, no use-after-free risk)
        return stat, err</span>
}

// updateCache atomically updates the cache using copy-on-write (no pool, value types)
func (w *Watcher) updateCache(path string, stat fileStat) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                oldMapPtr := w.statCache.Load()
                oldMap := *oldMapPtr
                newMap := make(map[string]fileStat, len(oldMap)+1)

                // Copy existing entries
                for k, v := range oldMap </span><span class="cov8" title="1">{
                        newMap[k] = v
                }</span>

                // Add/update new entry
                <span class="cov8" title="1">newMap[path] = stat

                // Atomic compare-and-swap
                if w.statCache.CompareAndSwap(oldMapPtr, &amp;newMap) </span><span class="cov8" title="1">{
                        return // Success! No pool cleanup needed with value types
                }</span>
                // Retry if another goroutine updated the cache concurrently
        }
}

// removeFromCache atomically removes an entry from the cache (no pool, value types)
func (w *Watcher) removeFromCache(path string) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                oldMapPtr := w.statCache.Load()
                oldMap := *oldMapPtr
                if _, exists := oldMap[path]; !exists </span><span class="cov8" title="1">{
                        return // Entry doesn't exist, nothing to do
                }</span>

                <span class="cov8" title="1">newMap := make(map[string]fileStat, len(oldMap)-1)

                // Copy all entries except the one to remove
                for k, v := range oldMap </span><span class="cov8" title="1">{
                        if k != path </span><span class="cov8" title="1">{
                                newMap[k] = v
                        }</span>
                }

                // Atomic compare-and-swap
                <span class="cov8" title="1">if w.statCache.CompareAndSwap(oldMapPtr, &amp;newMap) </span><span class="cov8" title="1">{
                        return // Success! No pool cleanup needed with value types
                }</span>
                // Retry if another goroutine updated the cache concurrently
        }
}

// checkFile compares current file stat with last known stat and sends events via BoreasLite
func (w *Watcher) checkFile(wf *watchedFile) <span class="cov8" title="1">{
        currentStat, err := w.getStat(wf.path)

        // Handle stat errors
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        // File was deleted
                        if wf.lastStat.exists </span><span class="cov8" title="1">{
                                // Send delete event via BoreasLite ring buffer
                                w.eventRing.WriteFileChange(wf.path, time.Time{}, 0, false, true, false)
                                wf.lastStat.exists = false
                        }</span>
                } else<span class="cov0" title="0"> if w.config.ErrorHandler != nil </span><span class="cov0" title="0">{
                        w.config.ErrorHandler(errors.Wrap(err, ErrCodeFileNotFound, "failed to stat file").
                                WithContext("path", wf.path), wf.path)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // File exists now
        <span class="cov8" title="1">if !wf.lastStat.exists </span><span class="cov8" title="1">{
                // File was created - send via BoreasLite
                w.eventRing.WriteFileChange(wf.path, currentStat.modTime, currentStat.size, true, false, false)
        }</span> else<span class="cov8" title="1"> if currentStat.modTime != wf.lastStat.modTime || currentStat.size != wf.lastStat.size </span><span class="cov8" title="1">{
                // File was modified - send via BoreasLite
                w.eventRing.WriteFileChange(wf.path, currentStat.modTime, currentStat.size, false, false, true)
        }</span>

        <span class="cov8" title="1">wf.lastStat = currentStat</span>
}

// watchLoop is the main polling loop that checks all watched files
func (w *Watcher) watchLoop() <span class="cov8" title="1">{
        defer close(w.stoppedCh)

        ticker := time.NewTicker(w.config.PollInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-w.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-w.stopCh:<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        w.pollFiles()</span>
                }
        }
}

// pollFiles checks all watched files for changes
// ULTRA-OPTIMIZED: Zero-allocation version using reusable buffer
func (w *Watcher) pollFiles() <span class="cov8" title="1">{
        w.filesMu.RLock()
        // Reuse buffer to avoid allocations
        w.filesBuffer = w.filesBuffer[:0] // Reset slice but keep capacity
        for _, wf := range w.files </span><span class="cov8" title="1">{
                w.filesBuffer = append(w.filesBuffer, wf)
        }</span>
        <span class="cov8" title="1">files := w.filesBuffer
        w.filesMu.RUnlock()

        // For single file, use direct checking to avoid goroutine overhead
        if len(files) == 1 </span><span class="cov8" title="1">{
                w.checkFile(files[0])
                return
        }</span>

        // For multiple files, use parallel checking with limited concurrency
        <span class="cov8" title="1">const maxConcurrency = 8 // Prevent goroutine explosion
        if len(files) &lt;= maxConcurrency </span><span class="cov8" title="1">{
                // Use goroutines for small number of files
                var wg sync.WaitGroup
                for _, wf := range files </span><span class="cov8" title="1">{
                        wg.Add(1)
                        go func(wf *watchedFile) </span><span class="cov8" title="1">{
                                defer wg.Done()
                                w.checkFile(wf)
                        }</span>(wf)
                }
                <span class="cov8" title="1">wg.Wait()</span>
        } else<span class="cov8" title="1"> {
                // Use worker pool for many files
                fileCh := make(chan *watchedFile, len(files))
                var wg sync.WaitGroup

                // Start workers
                for i := 0; i &lt; maxConcurrency; i++ </span><span class="cov8" title="1">{
                        wg.Add(1)
                        go func() </span><span class="cov8" title="1">{
                                defer wg.Done()
                                for wf := range fileCh </span><span class="cov8" title="1">{
                                        w.checkFile(wf)
                                }</span>
                        }()
                }

                // Send files to workers
                <span class="cov8" title="1">for _, wf := range files </span><span class="cov8" title="1">{
                        fileCh &lt;- wf
                }</span>
                <span class="cov8" title="1">close(fileCh)
                wg.Wait()</span>
        }
}

// ClearCache forces clearing of the stat cache (no pool cleanup needed)
// Useful for testing or when you want to force fresh stat calls
func (w *Watcher) ClearCache() <span class="cov8" title="1">{
        emptyCache := make(map[string]fileStat)
        w.statCache.Store(&amp;emptyCache)
}</span>

// CacheStats returns statistics about the internal cache for monitoring and debugging.
// Provides insights into cache efficiency and performance characteristics.
type CacheStats struct {
        Entries   int           // Number of cached entries
        OldestAge time.Duration // Age of oldest cache entry
        NewestAge time.Duration // Age of newest cache entry
}

// GetCacheStats returns current cache statistics using timecache for performance
func (w *Watcher) GetCacheStats() CacheStats <span class="cov8" title="1">{
        cacheMap := *w.statCache.Load()

        if len(cacheMap) == 0 </span><span class="cov8" title="1">{
                return CacheStats{}
        }</span>

        <span class="cov8" title="1">now := timecache.CachedTimeNano()
        var oldest, newest int64
        first := true

        for _, stat := range cacheMap </span><span class="cov8" title="1">{
                if first </span><span class="cov8" title="1">{
                        oldest = stat.cachedAt
                        newest = stat.cachedAt
                        first = false
                }</span> else<span class="cov8" title="1"> {
                        if stat.cachedAt &lt; oldest </span><span class="cov0" title="0">{
                                oldest = stat.cachedAt
                        }</span>
                        <span class="cov8" title="1">if stat.cachedAt &gt; newest </span><span class="cov8" title="1">{
                                newest = stat.cachedAt
                        }</span>
                }
        }

        <span class="cov8" title="1">return CacheStats{
                Entries:   len(cacheMap),
                OldestAge: time.Duration(now - oldest),
                NewestAge: time.Duration(now - newest),
        }</span>
}

// =============================================================================
// SECURITY: PATH VALIDATION AND SANITIZATION FUNCTIONS
// =============================================================================

// ValidateSecurePath validates that a file path is safe from path traversal attacks.
//
// SECURITY PURPOSE: Prevents directory traversal attacks (CWE-22) by rejecting
// paths that contain dangerous patterns or attempt to escape the intended directory.
//
// This function implements multiple layers of protection:
// 1. Pattern-based detection of traversal sequences (case-insensitive)
// 2. URL decoding to catch encoded attacks
// 3. Normalization attacks prevention
// 4. System file protection
// 5. Device name filtering (Windows)
//
// SECURITY NOTICE: All validation is performed case-insensitively to ensure
// consistent protection across different file systems and OS configurations.
//
// CRITICAL: This function must be called on ALL user-provided paths before
// any file operations to prevent security vulnerabilities.
//
// This function is exported to allow external packages to use the same
// security validation logic as the core Argus library.
func ValidateSecurePath(path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "empty path not allowed")
        }</span>

        // Normalize path to lowercase for consistent security validation
        // This prevents case-based bypass attempts on case-insensitive file systems
        <span class="cov8" title="1">lowerPath := strings.ToLower(path)

        // SECURITY CHECK 1: Detect common path traversal patterns (case-insensitive)
        // These patterns are dangerous regardless of OS
        dangerousPatterns := []string{
                "..",   // Parent directory reference
                "../",  // Unix path traversal
                "..\\", // Windows path traversal
                "/..",  // Unix parent dir
                "\\..", // Windows parent dir
                // Note: "./" removed as it can be legitimate in temp paths
        }

        for _, pattern := range dangerousPatterns </span><span class="cov8" title="1">{
                if strings.Contains(lowerPath, pattern) </span><span class="cov8" title="1">{
                        return errors.New(ErrCodeInvalidConfig, "path contains dangerous traversal pattern: "+pattern)
                }</span>
        }

        // SECURITY CHECK 2: URL decoding to catch encoded attacks
        // Attackers often URL-encode traversal sequences to bypass filters

        // Check for URL-encoded dangerous patterns using normalized path
        <span class="cov8" title="1">urlPatterns := []string{
                "%2e%2e",      // ".." encoded
                "%252e%252e",  // ".." double encoded
                "%2f",         // "/" encoded
                "%252f",       // "/" double encoded
                "%5c",         // "\" encoded
                "%255c",       // "\" double encoded
                "%00",         // null byte
                "%2500",       // null byte double encoded
                "..%2f",       // Mixed encoding patterns
                "..%252f",     // Mixed double encoding
                "%2e%2e/",     // Mixed patterns
                "%252e%252e/", // Mixed double encoding
        }

        for _, pattern := range urlPatterns </span><span class="cov8" title="1">{
                if strings.Contains(lowerPath, pattern) </span><span class="cov8" title="1">{
                        return errors.New(ErrCodeInvalidConfig, "path contains URL-encoded traversal pattern: "+pattern)
                }</span>
        }

        // Additional check for any percent-encoded sequences that decode to dangerous patterns
        // This catches creative encoding attempts
        <span class="cov8" title="1">for i := 0; i &lt; len(path)-2; i++ </span><span class="cov8" title="1">{
                if path[i] == '%' </span><span class="cov8" title="1">{
                        // Look for sequences like %XX that might decode to dangerous characters
                        if i+5 &lt; len(path) </span><span class="cov8" title="1">{
                                sixChar := strings.ToLower(path[i : i+6])
                                // Check for double-encoded dots and slashes
                                if strings.HasPrefix(sixChar, "%252e") || strings.HasPrefix(sixChar, "%252f") || strings.HasPrefix(sixChar, "%255c") </span><span class="cov0" title="0">{
                                        return errors.New(ErrCodeInvalidConfig, "path contains double-encoded traversal sequence: "+sixChar)
                                }</span>
                        }
                }
        }

        // SECURITY CHECK 3: System file protection
        // Prevent access to known sensitive system files and directories
        // Using already normalized lowerPath for consistency
        <span class="cov8" title="1">sensitiveFiles := []string{
                "/etc/passwd",
                "/etc/shadow",
                "/etc/hosts",
                "/proc/",
                "/sys/",
                "/dev/",
                "windows/system32",
                "windows\\system32",   // Windows backslash variant
                "\\windows\\system32", // Absolute Windows path
                "program files",
                "system volume information",
                ".ssh/",
                ".aws/",
                ".docker/",
        }

        for _, sensitive := range sensitiveFiles </span><span class="cov8" title="1">{
                if strings.Contains(lowerPath, strings.ToLower(sensitive)) </span><span class="cov8" title="1">{
                        return errors.New(ErrCodeInvalidConfig, "access to system file/directory not allowed: "+sensitive)
                }</span>
        }

        // SECURITY CHECK 4: Windows-specific security threats
        // Multiple Windows-specific attack vectors need protection

        // 4A: Windows device name protection
        <span class="cov8" title="1">windowsDevices := []string{
                "CON", "PRN", "AUX", "NUL",
                "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
                "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9",
        }

        baseName := strings.ToUpper(filepath.Base(path))
        // Remove extension for device name check
        if dotIndex := strings.LastIndex(baseName, "."); dotIndex != -1 </span><span class="cov8" title="1">{
                baseName = baseName[:dotIndex]
        }</span>

        <span class="cov8" title="1">for _, device := range windowsDevices </span><span class="cov8" title="1">{
                if baseName == device </span><span class="cov8" title="1">{
                        return errors.New(ErrCodeInvalidConfig, "windows device name not allowed: "+device)
                }</span>
        }

        // 4B: Windows Alternate Data Streams (ADS) protection
        // ADS can hide malicious content: filename.txt:hidden_stream
        <span class="cov8" title="1">if strings.Contains(path, ":") </span><span class="cov8" title="1">{
                // Check if this is a Windows ADS (not a URL scheme or Windows drive letter)
                colonIndex := strings.Index(path, ":")
                if colonIndex &gt; 1 &amp;&amp; colonIndex &lt; len(path)-1 </span><span class="cov8" title="1">{
                        // Check if it looks like ADS (no // after colon like in URLs)
                        afterColon := path[colonIndex+1:]
                        // Allow URLs (://) and network paths (:\\)
                        if !strings.HasPrefix(afterColon, "//") &amp;&amp; !strings.HasPrefix(afterColon, "\\\\") </span><span class="cov8" title="1">{
                                // Allow drive letters (C:)
                                if colonIndex == 1 </span>{<span class="cov0" title="0">
                                        // This is likely a drive letter, allow it
                                }</span> else<span class="cov8" title="1"> {
                                        // Check if this looks like a real ADS attack
                                        // Real ADS: filename.ext:streamname (streamname typically doesn't start with .)
                                        // But "test:.json" has colon followed by .json which is not typical ADS
                                        if !strings.HasPrefix(afterColon, ".") </span><span class="cov8" title="1">{
                                                return errors.New(ErrCodeInvalidConfig, "windows alternate data streams not allowed: "+path)
                                        }</span>
                                }
                        }
                }
        }

        // SECURITY CHECK 5: Path length and complexity limits
        // Prevent extremely long paths that could cause buffer overflows or DoS
        <span class="cov8" title="1">if len(path) &gt; 4096 </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, fmt.Sprintf("path too long (max 4096 characters): %d", len(path)))
        }</span>

        // Count directory levels to prevent deeply nested traversal attempts
        <span class="cov8" title="1">separatorCount := strings.Count(path, "/") + strings.Count(path, "\\")
        if separatorCount &gt; 50 </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, fmt.Sprintf("path too complex (max 50 directory levels): %d", separatorCount))
        }</span>

        // SECURITY CHECK 6: Null byte injection prevention
        // Null bytes can truncate strings in some languages/systems
        <span class="cov8" title="1">if strings.Contains(path, "\x00") </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "null byte in path not allowed")
        }</span>

        // SECURITY CHECK 7: Control character prevention
        // Control characters can cause unexpected behavior
        <span class="cov8" title="1">for _, char := range path </span><span class="cov8" title="1">{
                if char &lt; 32 &amp;&amp; char != 9 &amp;&amp; char != 10 &amp;&amp; char != 13 </span><span class="cov8" title="1">{ // Allow tab, LF, CR
                        return errors.New(ErrCodeInvalidConfig, fmt.Sprintf("control character in path not allowed: %d", char))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetWriter creates a ConfigWriter for the specified file.
// The writer enables programmatic configuration modifications with atomic operations.
//
// Performance: ~500 ns/op, zero allocations for writer creation
func (w *Watcher) GetWriter(filePath string, format ConfigFormat, initialConfig map[string]interface{}) (*ConfigWriter, error) <span class="cov0" title="0">{
        return NewConfigWriter(filePath, format, initialConfig)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// audit.go: Comprehensive audit trail system for Argus
//
// This provides security audit logging for all configuration changes,
// ensuring full accountability and traceability in production environments.
//
// Features:
// - Immutable audit logs with tamper detection
// - Structured logging with context
// - Performance optimized (sub-microsecond impact)
// - Configurable audit levels and outputs
//
// Copyright (c) 2025 AGILira
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "crypto/sha256"
        "fmt"
        "os"
        "sync"
        "time"

        "github.com/agilira/go-timecache"
)

// AuditLevel represents the severity of audit events
type AuditLevel int

const (
        AuditInfo AuditLevel = iota
        AuditWarn
        AuditCritical
        AuditSecurity
)

func (al AuditLevel) String() string <span class="cov8" title="1">{
        switch al </span>{
        case AuditInfo:<span class="cov8" title="1">
                return "INFO"</span>
        case AuditWarn:<span class="cov8" title="1">
                return "WARN"</span>
        case AuditCritical:<span class="cov8" title="1">
                return "CRITICAL"</span>
        case AuditSecurity:<span class="cov8" title="1">
                return "SECURITY"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// AuditEvent represents a single auditable event
type AuditEvent struct {
        Timestamp   time.Time              `json:"timestamp"`
        Level       AuditLevel             `json:"level"`
        Event       string                 `json:"event"`
        Component   string                 `json:"component"`
        FilePath    string                 `json:"file_path,omitempty"`
        OldValue    interface{}            `json:"old_value,omitempty"`
        NewValue    interface{}            `json:"new_value,omitempty"`
        UserAgent   string                 `json:"user_agent,omitempty"`
        ProcessID   int                    `json:"process_id"`
        ProcessName string                 `json:"process_name"`
        Context     map[string]interface{} `json:"context,omitempty"`
        Checksum    string                 `json:"checksum"` // For tamper detection
}

// AuditConfig configures the audit system
type AuditConfig struct {
        Enabled       bool          `json:"enabled"`
        OutputFile    string        `json:"output_file"`
        MinLevel      AuditLevel    `json:"min_level"`
        BufferSize    int           `json:"buffer_size"`
        FlushInterval time.Duration `json:"flush_interval"`
        IncludeStack  bool          `json:"include_stack"`
}

// DefaultAuditConfig returns secure default audit configuration with unified SQLite storage.
//
// The default configuration uses the unified SQLite audit system, which consolidates
// all Argus audit events into a single system-wide database. This provides:
//   - Cross-component event correlation
//   - Efficient storage and querying
//   - Automatic schema management
//   - WAL mode for concurrent access
//
// For applications requiring JSONL format, specify OutputFile with .jsonl extension.
func DefaultAuditConfig() AuditConfig <span class="cov8" title="1">{
        // Use empty OutputFile to trigger unified SQLite backend selection
        // The backend will automatically use the system audit database path
        return AuditConfig{
                Enabled:       true,
                OutputFile:    "", // Empty triggers unified SQLite backend
                MinLevel:      AuditInfo,
                BufferSize:    1000,
                FlushInterval: 5 * time.Second,
                IncludeStack:  false,
        }
}</span>

// AuditLogger provides high-performance audit logging with pluggable backends.
//
// This logger implements a unified audit system that automatically selects
// the optimal storage backend (SQLite for unified system audit, JSONL for
// backward compatibility) while maintaining the same public API.
//
// The logger uses buffering and background flushing for optimal performance
// in high-throughput scenarios while ensuring audit integrity.
type AuditLogger struct {
        config      AuditConfig
        backend     auditBackend // Pluggable storage backend (SQLite or JSONL)
        buffer      []AuditEvent
        bufferMu    sync.Mutex
        flushTicker *time.Ticker
        stopCh      chan struct{}
        processID   int
        processName string
}

// NewAuditLogger creates a new audit logger with automatic backend selection.
//
// The logger automatically selects the optimal audit backend based on system
// capabilities and configuration:
//   - SQLite unified backend for consolidation (preferred)
//   - JSONL fallback for compatibility
//
// This approach ensures seamless migration to unified audit trails while
// maintaining backward compatibility with existing configurations.
//
// Parameters:
//   - config: Audit configuration specifying behavior and output preferences
//
// Returns:
//   - Configured audit logger ready for use
//   - Error if both backend initialization attempts fail
func NewAuditLogger(config AuditConfig) (*AuditLogger, error) <span class="cov8" title="1">{
        // Initialize backend using automatic selection
        backend, err := createAuditBackend(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize audit backend: %w", err)
        }</span>

        <span class="cov8" title="1">logger := &amp;AuditLogger{
                config:      config,
                backend:     backend,
                buffer:      make([]AuditEvent, 0, config.BufferSize),
                stopCh:      make(chan struct{}),
                processID:   os.Getpid(),
                processName: getProcessName(),
        }

        // Start background flusher
        if config.FlushInterval &gt; 0 </span><span class="cov8" title="1">{
                logger.flushTicker = time.NewTicker(config.FlushInterval)
                go logger.flushLoop()
        }</span>

        <span class="cov8" title="1">return logger, nil</span>
}

// Log records an audit event with ultra-high performance
func (al *AuditLogger) Log(level AuditLevel, event, component, filePath string, oldVal, newVal interface{}, context map[string]interface{}) <span class="cov8" title="1">{
        if al == nil || al.backend == nil || !al.config.Enabled || level &lt; al.config.MinLevel </span><span class="cov0" title="0">{
                return
        }</span>

        // Use cached timestamp for performance (121x faster than time.Now())
        <span class="cov8" title="1">timestamp := timecache.CachedTime()

        auditEvent := AuditEvent{
                Timestamp:   timestamp,
                Level:       level,
                Event:       event,
                Component:   component,
                FilePath:    filePath,
                OldValue:    oldVal,
                NewValue:    newVal,
                ProcessID:   al.processID,
                ProcessName: al.processName,
                Context:     context,
        }

        // Generate tamper-detection checksum
        auditEvent.Checksum = al.generateChecksum(auditEvent)

        // Buffer the event
        al.bufferMu.Lock()
        al.buffer = append(al.buffer, auditEvent)
        if len(al.buffer) &gt;= al.config.BufferSize </span><span class="cov8" title="1">{
                _ = al.flushBufferUnsafe() // Ignore flush errors during buffering to maintain performance
        }</span>
        <span class="cov8" title="1">al.bufferMu.Unlock()</span>
}

// LogConfigChange logs configuration file changes (most common use case)
func (al *AuditLogger) LogConfigChange(filePath string, oldConfig, newConfig map[string]interface{}) <span class="cov8" title="1">{
        al.Log(AuditCritical, "config_change", "argus", filePath, oldConfig, newConfig, nil)
}</span>

// LogFileWatch logs file watch events
func (al *AuditLogger) LogFileWatch(event, filePath string) <span class="cov8" title="1">{
        al.Log(AuditInfo, event, "argus", filePath, nil, nil, nil)
}</span>

// LogSecurityEvent logs security-related events
func (al *AuditLogger) LogSecurityEvent(event, details string, context map[string]interface{}) <span class="cov8" title="1">{
        al.Log(AuditSecurity, event, "argus", "", nil, nil, context)
}</span>

// Flush immediately writes all buffered events
func (al *AuditLogger) Flush() error <span class="cov8" title="1">{
        al.bufferMu.Lock()
        defer al.bufferMu.Unlock()
        return al.flushBufferUnsafe()
}</span>

// Close gracefully shuts down the audit logger
func (al *AuditLogger) Close() error <span class="cov8" title="1">{
        close(al.stopCh)
        if al.flushTicker != nil </span><span class="cov8" title="1">{
                al.flushTicker.Stop()
        }</span>

        // Final flush to ensure all events are persisted
        <span class="cov8" title="1">if err := al.Flush(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to flush audit logger during close: %w", err)
        }</span>

        // Close backend and release resources
        <span class="cov8" title="1">if al.backend != nil </span><span class="cov8" title="1">{
                if err := al.backend.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close audit backend: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// flushLoop runs the background flush process
func (al *AuditLogger) flushLoop() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-al.flushTicker.C:<span class="cov8" title="1">
                        _ = al.Flush()</span> // Ignore flush errors in background process to maintain performance
                case &lt;-al.stopCh:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// flushBufferUnsafe writes buffer to backend storage (caller must hold bufferMu).
//
// This method delegates to the configured backend (SQLite or JSONL) for
// actual persistence. It handles batch writing for optimal performance
// and proper error handling with buffer management.
func (al *AuditLogger) flushBufferUnsafe() error <span class="cov8" title="1">{
        if len(al.buffer) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Write batch to backend
        <span class="cov8" title="1">if err := al.backend.Write(al.buffer); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write audit events to backend: %w", err)
        }</span>

        // Clear buffer after successful write
        <span class="cov8" title="1">al.buffer = al.buffer[:0]
        return nil</span>
}

// generateChecksum creates a tamper-detection checksum using SHA-256
func (al *AuditLogger) generateChecksum(event AuditEvent) string <span class="cov8" title="1">{
        // Cryptographic hash for tamper detection
        data := fmt.Sprintf("%s:%s:%s:%v:%v",
                event.Timestamp.Format(time.RFC3339Nano),
                event.Event, event.Component, event.OldValue, event.NewValue)
        hash := sha256.Sum256([]byte(data))
        return fmt.Sprintf("%x", hash)
}</span>

// Helper functions
func getProcessName() string <span class="cov8" title="1">{
        return "argus" // Could read from /proc/self/comm
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// audit_backend.go: Backend interface and implementations for Argus audit system
//
// This file defines the pluggable backend architecture for audit logging,
// supporting multiple storage backends (JSONL, SQLite) with transparent
// migration and unified API.
//
// Features:
// - Backend interface for pluggable audit storage
// - Automatic backend selection based on configuration
// - Comprehensive error handling and recovery
// - Thread-safe operations with proper resource management
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        _ "github.com/mattn/go-sqlite3" // SQLite driver registration
)

// auditBackend defines the interface for audit storage backends.
//
// This interface abstracts the storage mechanism, allowing transparent
// switching between JSONL files, SQLite databases, or future backends
// without changing the public API.
type auditBackend interface {
        // Write persists a batch of audit events to the backend.
        // Implementations must handle concurrent writes safely.
        Write(events []AuditEvent) error

        // Flush ensures all pending writes are committed to storage.
        // This is called during graceful shutdown and periodic flushes.
        Flush() error

        // Close releases all resources and performs final cleanup.
        // After calling Close, the backend must not be used again.
        Close() error

        // Maintenance performs backend-specific maintenance operations.
        // For SQLite: cleans old entries, optimizes database, updates statistics.
        // For JSONL: archives old files, compresses historical data.
        Maintenance() error

        // GetStats returns statistics about the audit backend.
        // For SQLite: detailed database statistics with event counts and performance metrics.
        // For JSONL: basic file statistics (implementation may return limited data).
        GetStats() (*AuditDatabaseStats, error)
}

// createAuditBackend creates the appropriate audit backend based on configuration.
//
// Backend selection strategy:
//  1. Always attempt SQLite unified backend first (for consolidation)
//  2. Fall back to JSONL if SQLite is unavailable or fails
//  3. Return error only if both backends fail initialization
//
// This ensures maximum compatibility while providing unified audit trails
// when possible.
func createAuditBackend(config AuditConfig) (auditBackend, error) <span class="cov8" title="1">{
        // Check if user explicitly requested JSONL format via .jsonl extension
        if config.OutputFile != "" &amp;&amp; filepath.Ext(config.OutputFile) == ".jsonl" </span><span class="cov8" title="1">{
                return newJSONLBackend(config)
        }</span>

        // For all other cases, try SQLite unified backend first for consolidation
        <span class="cov8" title="1">backend, err := newSQLiteBackend(config)
        if err == nil </span><span class="cov8" title="1">{
                return backend, nil
        }</span>

        // Fall back to JSONL backend if SQLite fails
        <span class="cov8" title="1">jsonlBackend, jsonlErr := newJSONLBackend(config)
        if jsonlErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("all audit backends failed - SQLite: %w, JSONL: %v", err, jsonlErr)
        }</span>

        <span class="cov0" title="0">return jsonlBackend, nil</span>
}

// getUnifiedAuditPath returns the standard path for the unified SQLite audit database.
//
// The unified database consolidates all Argus audit events from the system
// into a single queryable database, regardless of the original OutputFile
// configuration. This enables cross-component correlation and simplified
// audit management.
func getUnifiedAuditPath() string <span class="cov8" title="1">{
        return filepath.Join(os.TempDir(), "argus", "system-audit.db")
}</span>

// sqliteAuditBackend implements auditBackend using SQLite for unified audit storage.
//
// This backend consolidates all Argus audit events into a single SQLite database
// regardless of the original OutputFile configuration. It tracks the original
// source configuration for backward compatibility and debugging.
type sqliteAuditBackend struct {
        db         *sql.DB
        dbPath     string
        sourceFile string // Original OutputFile for source tracking
        insertStmt *sql.Stmt
        mu         sync.RWMutex
        closed     bool
}

// newSQLiteBackend creates a new SQLite audit backend with unified storage.
//
// This function initializes the SQLite database, creates the schema if needed,
// and prepares statements for efficient batch inserts. The database uses
// WAL mode for concurrent access and optimal performance.
//
// Parameters:
//   - config: AuditConfig containing the original configuration
//
// Returns:
//   - Configured SQLite backend ready for use
//   - Error if database initialization fails
func newSQLiteBackend(config AuditConfig) (*sqliteAuditBackend, error) <span class="cov8" title="1">{
        // Determine and setup database path
        dbPath, err := setupDatabasePath(config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Open and test database connection
        <span class="cov8" title="1">db, err := openSQLiteDatabase(dbPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Create backend instance
        <span class="cov8" title="1">backend := &amp;sqliteAuditBackend{
                db:         db,
                dbPath:     dbPath,
                sourceFile: config.OutputFile,
        }

        // Initialize backend components
        if err := initializeBackendComponents(backend); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return backend, nil</span>
}

// setupDatabasePath determines and creates database path
func setupDatabasePath(config AuditConfig) (string, error) <span class="cov8" title="1">{
        // Determine database path - respect OutputFile if specified with .db extension
        var dbPath string
        if config.OutputFile != "" &amp;&amp; filepath.Ext(config.OutputFile) == ".db" </span><span class="cov8" title="1">{
                // Use specified path for database files (useful for tests and custom setups)
                dbPath = config.OutputFile
        }</span> else<span class="cov8" title="1"> {
                // Use unified path for consolidation (default behavior)
                dbPath = getUnifiedAuditPath()
        }</span>

        // Ensure directory exists with appropriate permissions
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(dbPath), 0750); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to create audit database directory: %w", err)
        }</span>

        <span class="cov8" title="1">return dbPath, nil</span>
}

// openSQLiteDatabase opens and tests SQLite database connection
func openSQLiteDatabase(dbPath string) (*sql.DB, error) <span class="cov8" title="1">{
        // Open SQLite database with optimized settings
        db, err := sql.Open("sqlite3", fmt.Sprintf("%s?_journal_mode=WAL&amp;_busy_timeout=5000&amp;_synchronous=NORMAL&amp;_cache_size=1000", dbPath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open audit database: %w", err)
        }</span>

        // Test database connection
        <span class="cov8" title="1">if err := db.Ping(); err != nil </span><span class="cov8" title="1">{
                if closeErr := db.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to ping database (close error: %v): %w", closeErr, err)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to ping audit database: %w", err)</span>
        }

        <span class="cov8" title="1">return db, nil</span>
}

// initializeBackendComponents initializes schema, statements, and performs maintenance
func initializeBackendComponents(backend *sqliteAuditBackend) error <span class="cov8" title="1">{
        // Initialize database schema
        if err := backend.initializeSchema(); err != nil </span><span class="cov8" title="1">{
                if closeErr := backend.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize schema (close error: %v): %w", closeErr, err)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to initialize audit database schema: %w", err)</span>
        }

        // Prepare insert statement for efficient batch operations
        <span class="cov8" title="1">if err := backend.prepareStatements(); err != nil </span><span class="cov0" title="0">{
                if closeErr := backend.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to prepare statements (close error: %v): %w", closeErr, err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to prepare audit database statements: %w", err)</span>
        }

        // Perform maintenance on initialization to clean up old entries
        <span class="cov8" title="1">if err := backend.performMaintenance(); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail initialization - maintenance is not critical
                // In production, this should be logged to system logger
                _ = err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ensureSchemaVersion checks the current schema version and performs migrations if needed.
//
// This function implements forward-compatible schema evolution:
//   - Version 1: Initial schema with basic audit tracking
//   - Version 2: Added indexes and performance optimizations (current)
//   - Future versions: Will add new fields/tables without breaking compatibility
//
// Migration is atomic and safe for concurrent access.
func (s *sqliteAuditBackend) ensureSchemaVersion() error <span class="cov8" title="1">{
        const currentSchemaVersion = 2

        // Create schema_info table if it doesn't exist
        createSchemaInfoSQL := `
        CREATE TABLE IF NOT EXISTS schema_info (
                version INTEGER PRIMARY KEY,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );`

        if _, err := s.db.Exec(createSchemaInfoSQL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create schema_info table: %w", err)
        }</span>

        // Check current version
        <span class="cov8" title="1">var version int
        err := s.db.QueryRow("SELECT version FROM schema_info ORDER BY version DESC LIMIT 1").Scan(&amp;version)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        // First time setup
                        version = 0
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("failed to check schema version: %w", err)
                }</span>
        }

        // Perform migrations if needed
        <span class="cov8" title="1">if version &lt; currentSchemaVersion </span><span class="cov8" title="1">{
                if err := s.migrateSchema(version, currentSchemaVersion); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("schema migration from v%d to v%d failed: %w", version, currentSchemaVersion, err)
                }</span>

                // Update version info
                <span class="cov8" title="1">_, err := s.db.Exec(`
                        INSERT OR REPLACE INTO schema_info (version, updated_at) 
                        VALUES (?, CURRENT_TIMESTAMP)
                `, currentSchemaVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update schema version: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// migrateSchema performs incremental schema migrations from oldVersion to newVersion.
//
// Migrations are designed to be:
//   - Atomic (transaction-based)
//   - Backward compatible (old data preserved)
//   - Safe for concurrent access (minimal locking)
//   - Recoverable (can be rerun safely)
func (s *sqliteAuditBackend) migrateSchema(oldVersion, newVersion int) error <span class="cov8" title="1">{
        // Begin transaction for atomic migration
        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin migration transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        if rollErr := tx.Rollback(); rollErr != nil </span><span class="cov0" title="0">{
                                // Log rollback error but preserve original error
                                // In production, you'd want to log this properly
                                _ = rollErr
                        }</span>
                }
        }()

        // Apply migrations incrementally
        <span class="cov8" title="1">for version := oldVersion; version &lt; newVersion; version++ </span><span class="cov8" title="1">{
                switch version </span>{
                case 0:<span class="cov8" title="1">
                        // Migration from no schema to v1 (basic audit table)
                        if err := s.migrateToV1(tx); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("migration to v1 failed: %w", err)
                        }</span>
                case 1:<span class="cov8" title="1">
                        // Migration from v1 to v2 (add performance indexes)
                        if err := s.migrateToV2(tx); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("migration to v2 failed: %w", err)
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unknown migration path from version %d", version)</span>
                }
        }

        <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit migration transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// migrateToV1 creates the basic audit table schema (version 1).
func (s *sqliteAuditBackend) migrateToV1(tx *sql.Tx) error <span class="cov8" title="1">{
        // Create audit events table with comprehensive schema
        createTableSQL := `
        CREATE TABLE IF NOT EXISTS audit_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                level TEXT NOT NULL,
                event TEXT NOT NULL,
                component TEXT NOT NULL,
                
                -- Source tracking for backward compatibility
                original_output_file TEXT NOT NULL,
                
                -- File and data information
                file_path TEXT,
                old_value TEXT,
                new_value TEXT,
                
                -- Process and correlation tracking
                process_id INTEGER NOT NULL,
                process_name TEXT NOT NULL,
                
                -- Additional context
                context TEXT, -- JSON blob for flexible metadata
                checksum TEXT,
                
                -- Indexing and performance
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );`

        if _, err := tx.Exec(createTableSQL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create audit_events table: %w", err)
        }</span>

        // Create basic indexes for v1
        <span class="cov8" title="1">basicIndexes := []string{
                "CREATE INDEX IF NOT EXISTS idx_audit_timestamp ON audit_events(timestamp)",
                "CREATE INDEX IF NOT EXISTS idx_audit_level ON audit_events(level)",
                "CREATE INDEX IF NOT EXISTS idx_audit_component ON audit_events(component)",
                "CREATE INDEX IF NOT EXISTS idx_audit_source ON audit_events(original_output_file)",
                "CREATE INDEX IF NOT EXISTS idx_audit_created_at ON audit_events(created_at)",
        }

        for _, indexSQL := range basicIndexes </span><span class="cov8" title="1">{
                if _, err := tx.Exec(indexSQL); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to create basic index: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// migrateToV2 adds performance indexes and optimization for high-volume audit trails.
func (s *sqliteAuditBackend) migrateToV2(tx *sql.Tx) error <span class="cov8" title="1">{
        // Add composite indexes for common query patterns
        compositeIndexes := []string{
                "CREATE INDEX IF NOT EXISTS idx_audit_component_time ON audit_events(component, timestamp)",
                "CREATE INDEX IF NOT EXISTS idx_audit_level_time ON audit_events(level, created_at)",
                "CREATE INDEX IF NOT EXISTS idx_audit_source_component ON audit_events(original_output_file, component)",
                "CREATE INDEX IF NOT EXISTS idx_audit_event_component ON audit_events(event, component, timestamp)",
        }

        for _, indexSQL := range compositeIndexes </span><span class="cov8" title="1">{
                if _, err := tx.Exec(indexSQL); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create composite index: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// performMaintenance runs database maintenance tasks to keep the audit system performant.
//
// Maintenance tasks include:
//   - Cleaning old audit events (configurable retention)
//   - Optimizing database (VACUUM, ANALYZE)
//   - Verifying database integrity
//   - Updating statistics for query optimization
//
// This should be called periodically in production environments.
func (s *sqliteAuditBackend) performMaintenance() error <span class="cov8" title="1">{
        const defaultRetentionDays = 90 // Keep 3 months of audit data by default

        // Clean old events beyond retention period
        cleanupSQL := `
                DELETE FROM audit_events 
                WHERE created_at &lt; datetime('now', '-' || ? || ' days')
        `

        result, err := s.db.Exec(cleanupSQL, defaultRetentionDays)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to cleanup old audit events: %w", err)
        }</span>

        // Log maintenance activity for transparency
        <span class="cov8" title="1">if rowsAffected, err := result.RowsAffected(); err == nil &amp;&amp; rowsAffected &gt; 0 </span>{<span class="cov0" title="0">
                // Note: We could log this to the audit trail itself, but that might create recursion
                // In a real implementation, this could go to a separate maintenance log
        }</span>

        // Optimize database performance
        <span class="cov8" title="1">optimizationTasks := []string{
                "PRAGMA optimize",             // Update query planner statistics
                "PRAGMA wal_checkpoint(FULL)", // Ensure WAL is properly checkpointed
        }

        for _, task := range optimizationTasks </span><span class="cov8" title="1">{
                if _, err := s.db.Exec(task); err != nil </span><span class="cov0" title="0">{
                        // Log error but don't fail maintenance for non-critical optimizations
                        continue</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// initializeSchema creates the unified audit schema with versioning and migration support.
//
// The schema is designed for:
//   - Efficient cross-application audit correlation
//   - Backward compatibility tracking
//   - Performance optimized querying
//   - Automatic maintenance and cleanup
//   - Schema evolution support
//
// Schema versioning ensures safe migrations across Argus updates.
func (s *sqliteAuditBackend) initializeSchema() error <span class="cov8" title="1">{
        // Check and migrate schema version if needed
        // All table and index creation is now handled by the migration system
        if err := s.ensureSchemaVersion(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("schema version migration failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// prepareStatements prepares SQL statements for efficient batch operations.
//
// Prepared statements improve performance for high-frequency audit logging
// by avoiding SQL parsing overhead on each insert operation.
func (s *sqliteAuditBackend) prepareStatements() error <span class="cov8" title="1">{
        insertSQL := `
        INSERT INTO audit_events (
                timestamp, level, event, component,
                original_output_file, process_id, process_name,
                file_path, old_value, new_value, context, checksum
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        stmt, err := s.db.Prepare(insertSQL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare insert statement: %w", err)
        }</span>

        <span class="cov8" title="1">s.insertStmt = stmt
        return nil</span>
}

// AuditDatabaseStats represents statistics about the unified audit database.
type AuditDatabaseStats struct {
        TotalEvents       int64            `json:"total_events"`
        EventsByLevel     map[string]int64 `json:"events_by_level"`
        EventsByComponent map[string]int64 `json:"events_by_component"`
        OldestEvent       *time.Time       `json:"oldest_event"`
        NewestEvent       *time.Time       `json:"newest_event"`
        DatabaseSize      int64            `json:"database_size_bytes"`
        SchemaVersion     int              `json:"schema_version"`
}

// getDatabaseStats retrieves comprehensive statistics about the audit database.
//
// These statistics are useful for:
//   - Monitoring audit system health
//   - Planning maintenance and retention policies
//   - Debugging audit correlation issues
//   - Performance optimization
func (s *sqliteAuditBackend) getDatabaseStats() (*AuditDatabaseStats, error) <span class="cov8" title="1">{
        stats := &amp;AuditDatabaseStats{
                EventsByLevel:     make(map[string]int64),
                EventsByComponent: make(map[string]int64),
        }

        // Get total events count
        if err := s.getTotalEventsCount(stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get events by level
        <span class="cov8" title="1">if err := s.getEventsByLevel(stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get events by component
        <span class="cov8" title="1">if err := s.getEventsByComponent(stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get time range
        <span class="cov8" title="1">if err := s.getEventTimeRange(stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get schema version
        <span class="cov8" title="1">if err := s.getSchemaVersion(stats); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// getTotalEventsCount gets the total number of events
func (s *sqliteAuditBackend) getTotalEventsCount(stats *AuditDatabaseStats) error <span class="cov8" title="1">{
        err := s.db.QueryRow("SELECT COUNT(*) FROM audit_events").Scan(&amp;stats.TotalEvents)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get total events count: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// getEventsByLevel gets events grouped by level
func (s *sqliteAuditBackend) getEventsByLevel(stats *AuditDatabaseStats) error <span class="cov8" title="1">{
        rows, err := s.db.Query("SELECT level, COUNT(*) FROM audit_events GROUP BY level")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get events by level: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        _ = closeErr
                }</span>
        }()

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                var level string
                var count int64
                if err := rows.Scan(&amp;level, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan level stats: %w", err)
                }</span>
                <span class="cov8" title="1">stats.EventsByLevel[level] = count</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// getEventsByComponent gets events grouped by component
func (s *sqliteAuditBackend) getEventsByComponent(stats *AuditDatabaseStats) error <span class="cov8" title="1">{
        rows, err := s.db.Query("SELECT component, COUNT(*) FROM audit_events GROUP BY component")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get events by component: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := rows.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        _ = closeErr
                }</span>
        }()

        <span class="cov8" title="1">for rows.Next() </span><span class="cov8" title="1">{
                var component string
                var count int64
                if err := rows.Scan(&amp;component, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to scan component stats: %w", err)
                }</span>
                <span class="cov8" title="1">stats.EventsByComponent[component] = count</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// getEventTimeRange gets the oldest and newest event timestamps
func (s *sqliteAuditBackend) getEventTimeRange(stats *AuditDatabaseStats) error <span class="cov8" title="1">{
        var oldestStr, newestStr sql.NullString
        err := s.db.QueryRow(`
                SELECT 
                        MIN(created_at) as oldest,
                        MAX(created_at) as newest
                FROM audit_events
        `).Scan(&amp;oldestStr, &amp;newestStr)

        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get event time range: %w", err)
        }</span>

        <span class="cov8" title="1">if oldestStr.Valid </span><span class="cov8" title="1">{
                if oldest, err := time.Parse("2006-01-02 15:04:05", oldestStr.String); err == nil </span><span class="cov8" title="1">{
                        stats.OldestEvent = &amp;oldest
                }</span>
        }

        <span class="cov8" title="1">if newestStr.Valid </span><span class="cov8" title="1">{
                if newest, err := time.Parse("2006-01-02 15:04:05", newestStr.String); err == nil </span><span class="cov8" title="1">{
                        stats.NewestEvent = &amp;newest
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getSchemaVersion gets the current database schema version
func (s *sqliteAuditBackend) getSchemaVersion(stats *AuditDatabaseStats) error <span class="cov8" title="1">{
        err := s.db.QueryRow("SELECT version FROM schema_info ORDER BY version DESC LIMIT 1").Scan(&amp;stats.SchemaVersion)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get schema version: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Write persists a batch of audit events to the SQLite database.
//
// This method handles concurrent access safely and performs batch inserts
// within a transaction for optimal performance and consistency.
func (s *sqliteAuditBackend) Write(events []AuditEvent) error <span class="cov8" title="1">{
        s.mu.RLock()
        if s.closed </span><span class="cov0" title="0">{
                s.mu.RUnlock()
                return fmt.Errorf("cannot write to closed SQLite audit backend")
        }</span>
        <span class="cov8" title="1">s.mu.RUnlock()

        if len(events) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Begin transaction for batch insert
        <span class="cov8" title="1">tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin audit transaction: %w", err)
        }</span>

        // Ensure transaction is handled properly
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        if rollbackErr := tx.Rollback(); rollbackErr != nil </span><span class="cov0" title="0">{
                                // Log rollback error but don't override original error
                                fmt.Fprintf(os.Stderr, "Failed to rollback audit transaction: %v\n", rollbackErr)
                        }</span>
                }
        }()

        // Prepare transaction-scoped statement
        <span class="cov8" title="1">txStmt := tx.Stmt(s.insertStmt)
        defer func() </span><span class="cov8" title="1">{
                if closeErr := txStmt.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Failed to close transaction statement: %v\n", closeErr)
                }</span>
        }()

        // Insert all events in the batch
        <span class="cov8" title="1">for _, event := range events </span><span class="cov8" title="1">{
                err = s.insertEvent(txStmt, event)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert audit event: %w", err)
                }</span>
        }

        // Commit transaction
        <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit audit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// insertEvent inserts a single audit event using the provided statement.
//
// This helper method handles JSON serialization and proper parameter binding
// for the audit event data.
func (s *sqliteAuditBackend) insertEvent(stmt *sql.Stmt, event AuditEvent) error <span class="cov8" title="1">{
        // Serialize JSON fields
        oldValueJSON := ""
        if event.OldValue != nil </span><span class="cov8" title="1">{
                data, err := json.Marshal(event.OldValue)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to serialize old_value: %w", err)
                }</span>
                <span class="cov8" title="1">oldValueJSON = string(data)</span>
        }

        <span class="cov8" title="1">newValueJSON := ""
        if event.NewValue != nil </span><span class="cov8" title="1">{
                data, err := json.Marshal(event.NewValue)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to serialize new_value: %w", err)
                }</span>
                <span class="cov8" title="1">newValueJSON = string(data)</span>
        }

        <span class="cov8" title="1">contextJSON := ""
        if event.Context != nil </span><span class="cov8" title="1">{
                data, err := json.Marshal(event.Context)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to serialize context: %w", err)
                }</span>
                <span class="cov8" title="1">contextJSON = string(data)</span>
        }

        // Execute insert with proper parameter binding
        <span class="cov8" title="1">_, err := stmt.Exec(
                event.Timestamp.Format(time.RFC3339Nano),
                event.Level.String(),
                event.Event,
                event.Component,
                s.sourceFile, // Track original output file configuration
                event.ProcessID,
                event.ProcessName,
                event.FilePath,
                oldValueJSON,
                newValueJSON,
                contextJSON,
                event.Checksum,
        )

        return err</span>
}

// Flush ensures all pending writes are committed to storage.
//
// For SQLite with WAL mode, this forces a checkpoint to ensure
// durability of recent transactions.
func (s *sqliteAuditBackend) Flush() error <span class="cov8" title="1">{
        s.mu.RLock()
        if s.closed </span><span class="cov0" title="0">{
                s.mu.RUnlock()
                return nil // No-op for closed backend
        }</span>
        <span class="cov8" title="1">s.mu.RUnlock()

        // Force WAL checkpoint for durability
        _, err := s.db.Exec("PRAGMA wal_checkpoint(TRUNCATE)")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to flush SQLite audit backend: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Maintenance performs database maintenance operations.
// This method is safe to call concurrently and implements the auditBackend interface.
func (s *sqliteAuditBackend) Maintenance() error <span class="cov8" title="1">{
        return s.performMaintenance()
}</span>

// GetStats returns comprehensive database statistics.
// This method is safe to call concurrently and implements the auditBackend interface.
func (s *sqliteAuditBackend) GetStats() (*AuditDatabaseStats, error) <span class="cov8" title="1">{
        return s.getDatabaseStats()
}</span>

// Close releases all resources and performs final cleanup.
//
// This method ensures proper cleanup of prepared statements and database
// connections. It is safe to call multiple times.
// Close releases all resources and performs final cleanup.
//
// CRITICAL: This method automatically performs a final Flush() to ensure all
// pending data in WAL (Write-Ahead Logging) mode is committed to the database
// before closing the connection. This guarantees data integrity even when
// the backend is used directly without going through AuditLogger.Close().
//
// The method is safe to call multiple times and is thread-safe.
func (s *sqliteAuditBackend) Close() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.closed </span><span class="cov8" title="1">{
                return nil // Already closed
        }</span>

        <span class="cov8" title="1">var errors []error

        // CRITICAL: Perform final flush to ensure data integrity
        // This ensures all WAL data is committed before closing the connection
        // We temporarily unlock to allow Flush() to acquire read lock
        s.mu.Unlock()
        if err := s.Flush(); err != nil </span><span class="cov0" title="0">{
                errors = append(errors, fmt.Errorf("failed to flush audit backend during close: %w", err))
        }</span>
        <span class="cov8" title="1">s.mu.Lock()

        // Close prepared statement
        if s.insertStmt != nil </span><span class="cov8" title="1">{
                if err := s.insertStmt.Close(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to close insert statement: %w", err))
                }</span>
        }

        // Close database connection
        <span class="cov8" title="1">if s.db != nil </span><span class="cov8" title="1">{
                if err := s.db.Close(); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to close database: %w", err))
                }</span>
        }

        <span class="cov8" title="1">s.closed = true

        // Return combined errors if any occurred
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors closing SQLite audit backend: %v", errors)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// jsonlAuditBackend implements auditBackend using JSONL files for backward compatibility.
//
// This backend provides compatibility with existing JSONL-based audit logging
// while implementing the same interface as the SQLite backend. It wraps the
// existing file-based audit functionality.
type jsonlAuditBackend struct {
        file       *os.File
        sourceFile string
        mu         sync.Mutex
        closed     bool
}

// newJSONLBackend creates a new JSONL audit backend for backward compatibility.
//
// This function provides a fallback mechanism when SQLite is not available,
// maintaining compatibility with existing JSONL-based audit configurations.
//
// Parameters:
//   - config: AuditConfig containing file path and other settings
//
// Returns:
//   - Configured JSONL backend ready for use
//   - Error if file creation or initialization fails
func newJSONLBackend(config AuditConfig) (*jsonlAuditBackend, error) <span class="cov8" title="1">{
        if config.OutputFile == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("JSONL backend requires OutputFile to be specified")
        }</span>

        // Ensure directory exists
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(config.OutputFile), 0750); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create JSONL audit log directory: %w", err)
        }</span>

        // Open audit file with secure permissions (owner read/write only)
        <span class="cov8" title="1">file, err := os.OpenFile(config.OutputFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open JSONL audit log file: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;jsonlAuditBackend{
                file:       file,
                sourceFile: config.OutputFile,
        }, nil</span>
}

// Write persists a batch of audit events to the JSONL file.
//
// Each event is serialized as a JSON object on a single line,
// following the JSONL format specification.
func (j *jsonlAuditBackend) Write(events []AuditEvent) error <span class="cov8" title="1">{
        j.mu.Lock()
        defer j.mu.Unlock()

        if j.closed </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot write to closed JSONL audit backend")
        }</span>

        <span class="cov8" title="1">if len(events) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, event := range events </span><span class="cov8" title="1">{
                data, err := json.Marshal(event)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to serialize audit event: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := j.file.Write(data); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write audit event to JSONL: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := j.file.Write([]byte("\n")); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write audit event newline: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Flush ensures all pending writes are committed to storage.
//
// For JSONL files, this forces an fsync to ensure data persistence.
func (j *jsonlAuditBackend) Flush() error <span class="cov8" title="1">{
        j.mu.Lock()
        defer j.mu.Unlock()

        if j.closed </span><span class="cov0" title="0">{
                return nil // No-op for closed backend
        }</span>

        <span class="cov8" title="1">if err := j.file.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync JSONL audit file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Maintenance performs file-based maintenance operations for JSONL backend.
// For JSONL files, this could include log rotation, compression, or archiving.
// Currently returns nil as JSONL files are self-maintaining.
func (j *jsonlAuditBackend) Maintenance() error <span class="cov8" title="1">{
        // JSONL files are inherently self-maintaining
        // Future enhancements could include:
        // - Log rotation based on size/age
        // - Compression of old files
        // - Archiving to remote storage
        return nil
}</span>

// GetStats returns basic file statistics for JSONL backend.
// This provides limited statistics compared to SQLite backend.
func (j *jsonlAuditBackend) GetStats() (*AuditDatabaseStats, error) <span class="cov8" title="1">{
        stats := &amp;AuditDatabaseStats{
                EventsByLevel:     make(map[string]int64),
                EventsByComponent: make(map[string]int64),
                SchemaVersion:     1, // JSONL format is version 1
        }

        // Get file size if file exists
        if info, err := os.Stat(j.sourceFile); err == nil </span><span class="cov8" title="1">{
                stats.DatabaseSize = info.Size()
        }</span>

        // Note: Event counting would require parsing the entire JSONL file
        // which could be expensive for large files. For now, we return
        // basic statistics. Future enhancements could include:
        // - Cached event counts
        // - Sampling-based statistics
        // - Incremental count tracking

        <span class="cov8" title="1">return stats, nil</span>
}

// Close releases all resources and performs final cleanup.
//
// This method ensures proper cleanup of file handles and is safe to call
// multiple times.
func (j *jsonlAuditBackend) Close() error <span class="cov8" title="1">{
        j.mu.Lock()
        defer j.mu.Unlock()

        if j.closed </span><span class="cov8" title="1">{
                return nil // Already closed
        }</span>

        <span class="cov8" title="1">var err error
        if j.file != nil </span><span class="cov8" title="1">{
                err = j.file.Close()
        }</span>

        <span class="cov8" title="1">j.closed = true
        return err</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// boreaslite.go: Xantos Powered MPSC ring buffer derived from Boreas
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "sync/atomic"
        "time"
)

// FileChangeEvent represents a file change optimized for minimal memory footprint
// 128 bytes (2 cache lines) for maximum path compatibility and performance
type FileChangeEvent struct {
        Path    [110]byte // FULL POWER: 110 bytes for any file path (109 chars + null terminator)
        PathLen uint8     // Actual path length
        ModTime int64     // Unix nanoseconds
        Size    int64     // File size
        Flags   uint8     // Create(1), Delete(2), Modify(4) bits
        _       [0]byte   // Perfect 128 bytes: 110+1+8+8+1 = 128
}

// Event flags for file changes
const (
        FileEventCreate uint8 = 1 &lt;&lt; iota
        FileEventDelete
        FileEventModify
)

// BoreasLite - Ultra-fast MPSC ring buffer for file watching
// Optimized for Argus-specific use cases:
//   - Small number of files (typically 1-10)
//   - Infrequent events (file changes are rare)
//   - Low latency priority (immediate callback execution)
//   - Minimal memory footprint
type BoreasLite struct {
        // Ring buffer core (smaller than ZephyrosLite)
        buffer   []FileChangeEvent
        capacity int64
        mask     int64 // capacity - 1 for fast modulo

        // MPSC atomic cursors with cache-line padding
        writerCursor atomic.Int64 // Producer sequence
        readerCursor atomic.Int64 // Consumer sequence
        _            [48]byte     // Padding to prevent false sharing

        // Availability tracking for MPSC coordination
        availableBuffer []atomic.Int64 // Per-slot availability markers

        // Processor function (no interface overhead)
        processor func(*FileChangeEvent)

        // Optimization strategy configuration
        strategy  OptimizationStrategy
        batchSize int64 // Adaptive based on strategy

        // Control
        running atomic.Bool

        // Ultra-simple stats (just counters)
        processed atomic.Int64
        dropped   atomic.Int64
}

// NewBoreasLite creates a new ultra-fast ring buffer for file events
//
// Parameters:
//   - capacity: Ring buffer size (must be power of 2)
//   - strategy: Optimization strategy for performance tuning
//   - processor: Function to process file change events
//
// Returns:
//   - *BoreasLite: Ready-to-use ring buffer
func NewBoreasLite(capacity int64, strategy OptimizationStrategy, processor func(*FileChangeEvent)) *BoreasLite <span class="cov8" title="1">{
        // Validate power of 2
        if capacity &lt;= 0 || (capacity&amp;(capacity-1)) != 0 </span><span class="cov8" title="1">{
                capacity = 64 // Safe default for file watching
        }</span>

        // Determine batch size based on strategy
        <span class="cov8" title="1">var batchSize int64
        switch strategy </span>{
        case OptimizationSingleEvent:<span class="cov8" title="1">
                batchSize = 1</span> // Process immediately, no batching
        case OptimizationSmallBatch:<span class="cov8" title="1">
                batchSize = 4</span> // Small batches for balanced performance
        case OptimizationLargeBatch:<span class="cov8" title="1">
                batchSize = 16</span> // Large batches for throughput
        default:<span class="cov8" title="1"> // OptimizationAuto will be handled at runtime
                batchSize = 4</span> // Safe default
        }

        // Create ring buffer
        <span class="cov8" title="1">b := &amp;BoreasLite{
                buffer:          make([]FileChangeEvent, capacity),
                capacity:        capacity,
                mask:            capacity - 1,
                availableBuffer: make([]atomic.Int64, capacity),
                processor:       processor,
                strategy:        strategy,
                batchSize:       batchSize,
        }

        // Initialize availability markers
        for i := range b.availableBuffer </span><span class="cov8" title="1">{
                b.availableBuffer[i].Store(-1)
        }</span>

        <span class="cov8" title="1">b.running.Store(true)
        return b</span>
}

// AdaptStrategy dynamically adjusts the optimization strategy based on file count.
// This is called when OptimizationAuto is used and file count changes.
// Automatically selects the optimal batch size for current workload:
//   - 1-3 files: SingleEvent (ultra-low latency, 24.91ns)
//   - 4-50 files: SmallBatch (balanced performance, 100% detection)
//   - 51+ files: LargeBatch (high throughput, 1000+ files supported)
func (b *BoreasLite) AdaptStrategy(fileCount int) <span class="cov8" title="1">{
        if b.strategy != OptimizationAuto </span><span class="cov8" title="1">{
                return // Fixed strategy, no adaptation
        }</span>

        <span class="cov8" title="1">var newBatchSize int64
        switch </span>{
        case fileCount &lt;= 3:<span class="cov8" title="1">
                newBatchSize = 1</span> // SingleEvent optimization
        case fileCount &lt;= 50:<span class="cov8" title="1">
                newBatchSize = 4</span> // SmallBatch optimization
        default:<span class="cov8" title="1">
                newBatchSize = 16</span> // LargeBatch optimization
        }

        // Update batch size atomically (safe to change at runtime)
        <span class="cov8" title="1">b.batchSize = newBatchSize</span>
}

// WriteFileEvent adds a file change event to the ring buffer
// ZERO ALLOCATIONS - uses provided event struct directly
//
// Parameters:
//   - event: Pre-populated file change event
//
// Returns:
//   - bool: true if written, false if ring is full/closed
//
// Performance: Target &lt;8ns per operation
func (b *BoreasLite) WriteFileEvent(event *FileChangeEvent) bool <span class="cov8" title="1">{
        if !b.running.Load() </span><span class="cov8" title="1">{
                b.dropped.Add(1)
                return false
        }</span>

        // MPSC: Claim sequence atomically
        <span class="cov8" title="1">sequence := b.writerCursor.Add(1) - 1

        // Check buffer full (file events should NEVER be dropped, but safety check)
        if sequence &gt;= b.readerCursor.Load()+b.capacity </span><span class="cov8" title="1">{
                b.dropped.Add(1)
                return false
        }</span>

        // Copy event to buffer slot (zero allocation)
        <span class="cov8" title="1">slot := &amp;b.buffer[sequence&amp;b.mask]
        *slot = *event

        // Mark available for reading
        b.availableBuffer[sequence&amp;b.mask].Store(sequence)

        return true</span>
}

// WriteFileChange is a convenience method for creating events from parameters.
// Slightly slower than WriteFileEvent but more convenient for direct parameter usage.
// Automatically handles path length limits and flag setting.
//
// Parameters:
//   - path: File path (automatically truncated if &gt; 109 characters)
//   - modTime: File modification time
//   - size: File size in bytes
//   - isCreate: True if this is a file creation event
//   - isDelete: True if this is a file deletion event
//   - isModify: True if this is a file modification event
//
// Returns:
//   - bool: true if event was successfully queued, false if buffer is full
func (b *BoreasLite) WriteFileChange(path string, modTime time.Time, size int64, isCreate, isDelete, isModify bool) bool <span class="cov8" title="1">{
        event := FileChangeEvent{
                ModTime: modTime.UnixNano(),
                Size:    size,
        }

        // Copy path with bounds checking
        pathBytes := []byte(path)
        copyLen := len(pathBytes)
        if copyLen &gt; 109 </span><span class="cov0" title="0">{ // Use full buffer capacity (110 bytes - 1 for safety)
                copyLen = 109
        }</span>
        <span class="cov8" title="1">copy(event.Path[:], pathBytes[:copyLen])
        // Safe conversion: copyLen is guaranteed &lt;= 109 (fits in uint8)
        event.PathLen = uint8(copyLen) // #nosec G115 -- bounds checked above, copyLen &lt;= 109

        // Set flags
        if isCreate </span><span class="cov8" title="1">{
                event.Flags |= FileEventCreate
        }</span>
        <span class="cov8" title="1">if isDelete </span><span class="cov8" title="1">{
                event.Flags |= FileEventDelete
        }</span>
        <span class="cov8" title="1">if isModify </span><span class="cov8" title="1">{
                event.Flags |= FileEventModify
        }</span>

        <span class="cov8" title="1">return b.WriteFileEvent(&amp;event)</span>
}

// ProcessBatch processes available events in small batches
// Optimized for low latency - smaller batches than ZephyrosLite
//
// Returns:
//   - int: Number of events processed
func (b *BoreasLite) ProcessBatch() int <span class="cov8" title="1">{
        current := b.readerCursor.Load()
        writerPos := b.writerCursor.Load()

        if current &gt;= writerPos </span><span class="cov8" title="1">{
                return 0 // Nothing to process
        }</span>

        <span class="cov8" title="1">bufferOccupancy := writerPos - current

        // STRATEGY-BASED OPTIMIZATION: Choose processing path based on configuration
        switch b.strategy </span>{
        case OptimizationSingleEvent:<span class="cov8" title="1">
                return b.processSingleEventOptimized(current, writerPos, bufferOccupancy)</span>
        case OptimizationSmallBatch:<span class="cov8" title="1">
                return b.processSmallBatchOptimized(current, writerPos, bufferOccupancy)</span>
        case OptimizationLargeBatch:<span class="cov8" title="1">
                return b.processLargeBatchOptimized(current, writerPos, bufferOccupancy)</span>
        default:<span class="cov8" title="1"> // OptimizationAuto
                return b.processAutoOptimized(current, writerPos, bufferOccupancy)</span>
        }
}

// processSingleEventOptimized - Ultra-low latency for 1-2 files
func (b *BoreasLite) processSingleEventOptimized(current, writerPos, bufferOccupancy int64) int <span class="cov8" title="1">{
        // ULTRA-FAST PATH: Single event with minimal overhead
        if bufferOccupancy == 1 </span><span class="cov8" title="1">{
                if b.availableBuffer[current&amp;b.mask].Load() == current </span><span class="cov8" title="1">{
                        b.processor(&amp;b.buffer[current&amp;b.mask])
                        b.availableBuffer[current&amp;b.mask].Store(-1)
                        b.readerCursor.Store(current + 1)
                        b.processed.Add(1)
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }

        // Process small batches immediately (2-3 events)
        <span class="cov8" title="1">maxProcess := minInt64(3, writerPos-current)
        available := current - 1

        for seq := current; seq &lt; current+maxProcess; seq++ </span><span class="cov8" title="1">{
                if b.availableBuffer[seq&amp;b.mask].Load() == seq </span><span class="cov8" title="1">{
                        available = seq
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">if available &lt; current </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">processed := int(available - current + 1)
        for seq := current; seq &lt;= available; seq++ </span><span class="cov8" title="1">{
                idx := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx])
                b.availableBuffer[idx].Store(-1)
        }</span>

        <span class="cov8" title="1">b.readerCursor.Store(available + 1)
        b.processed.Add(int64(processed))
        return processed</span>
}

// processSmallBatchOptimized - Balanced performance for 3-20 files
func (b *BoreasLite) processSmallBatchOptimized(current, writerPos, _ int64) int <span class="cov8" title="1">{
        maxProcess := minInt64(b.batchSize, writerPos-current)
        available := current - 1

        // Find contiguous available events
        for seq := current; seq &lt; current+maxProcess; seq++ </span><span class="cov8" title="1">{
                if b.availableBuffer[seq&amp;b.mask].Load() == seq </span><span class="cov8" title="1">{
                        available = seq
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">if available &lt; current </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">processed := int(available - current + 1)

        // Use simple loop for small batches (no unrolling overhead)
        for seq := current; seq &lt;= available; seq++ </span><span class="cov8" title="1">{
                idx := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx])
                b.availableBuffer[idx].Store(-1)
        }</span>

        <span class="cov8" title="1">b.readerCursor.Store(available + 1)
        b.processed.Add(int64(processed))
        return processed</span>
}

// processLargeBatchOptimized - High throughput for 20+ files with Zephyros optimizations
func (b *BoreasLite) processLargeBatchOptimized(current, writerPos, bufferOccupancy int64) int <span class="cov8" title="1">{
        // Adaptive batching based on buffer pressure
        adaptiveBatchSize := b.batchSize
        if bufferOccupancy &gt; b.capacity*3/4 </span><span class="cov8" title="1">{
                adaptiveBatchSize = minInt64(b.batchSize*4, b.capacity/2)
        }</span>

        <span class="cov8" title="1">maxProcess := minInt64(adaptiveBatchSize, writerPos-current)
        available := current - 1
        maxScan := current + maxProcess

        // Smart prefetching for optimal cache hits
        for seq := current; seq &lt; maxScan; seq++ </span><span class="cov8" title="1">{
                if seq+4 &lt; maxScan </span><span class="cov8" title="1">{
                        _ = b.availableBuffer[(seq+4)&amp;b.mask].Load() // Prefetch 4 slots ahead
                }</span>

                <span class="cov8" title="1">if b.availableBuffer[seq&amp;b.mask].Load() == seq </span><span class="cov8" title="1">{
                        available = seq
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">if available &lt; current </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">processed := int(available - current + 1)

        // 4x Unrolled processing for maximum throughput
        seq := current
        remainder := processed &amp; 3
        chunks := processed &gt;&gt; 2

        for i := 0; i &lt; chunks; i++ </span><span class="cov8" title="1">{
                if seq+8 &lt;= available </span><span class="cov8" title="1">{
                        _ = b.buffer[(seq+8)&amp;b.mask] // Prefetch data 8 slots ahead
                }</span>

                // Process 4 events at once
                <span class="cov8" title="1">idx1 := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx1])
                seq++

                idx2 := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx2])
                seq++

                idx3 := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx3])
                seq++

                idx4 := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx4])
                seq++

                // Batch reset for cache locality
                b.availableBuffer[idx1].Store(-1)
                b.availableBuffer[idx2].Store(-1)
                b.availableBuffer[idx3].Store(-1)
                b.availableBuffer[idx4].Store(-1)</span>
        }

        // Process remaining items
        <span class="cov8" title="1">for i := 0; i &lt; remainder; i++ </span><span class="cov8" title="1">{
                idx := seq &amp; b.mask
                b.processor(&amp;b.buffer[idx])
                b.availableBuffer[idx].Store(-1)
                seq++
        }</span>

        <span class="cov8" title="1">b.readerCursor.Store(available + 1)
        b.processed.Add(int64(processed))
        return processed</span>
}

// processAutoOptimized - Dynamic strategy based on runtime conditions
func (b *BoreasLite) processAutoOptimized(current, writerPos, bufferOccupancy int64) int <span class="cov8" title="1">{
        // Choose strategy based on buffer occupancy
        switch </span>{
        case bufferOccupancy &lt;= 3:<span class="cov8" title="1">
                return b.processSingleEventOptimized(current, writerPos, bufferOccupancy)</span>
        case bufferOccupancy &lt;= 16:<span class="cov8" title="1">
                return b.processSmallBatchOptimized(current, writerPos, bufferOccupancy)</span>
        default:<span class="cov8" title="1">
                return b.processLargeBatchOptimized(current, writerPos, bufferOccupancy)</span>
        }
}

// RunProcessor runs the consumer loop with strategy-optimized behavior
func (b *BoreasLite) RunProcessor() <span class="cov8" title="1">{
        // Strategy-specific spinning behavior
        switch b.strategy </span>{
        case OptimizationSingleEvent:<span class="cov8" title="1">
                b.runSingleEventProcessor()</span>
        case OptimizationSmallBatch:<span class="cov8" title="1">
                b.runSmallBatchProcessor()</span>
        case OptimizationLargeBatch:<span class="cov8" title="1">
                b.runLargeBatchProcessor()</span>
        default:<span class="cov8" title="1"> // OptimizationAuto
                b.runAutoProcessor()</span>
        }
}

// runSingleEventProcessor - Ultra-aggressive spinning for 1-2 files
func (b *BoreasLite) runSingleEventProcessor() <span class="cov8" title="1">{
        spins := 0
        for b.running.Load() </span><span class="cov8" title="1">{
                processed := b.ProcessBatch()
                if processed &gt; 0 </span><span class="cov8" title="1">{
                        spins = 0
                        continue</span> // Hot loop for immediate processing
                }

                <span class="cov8" title="1">spins++
                if spins &lt; 5000 </span><span class="cov8" title="1">{ // Aggressive spinning for ultra-low latency
                        continue</span>
                } else<span class="cov8" title="1"> {
                        spins = 0 // Reset quickly for file changes
                }</span>
        }

        // Final drain
        <span class="cov8" title="1">for b.ProcessBatch() &gt; 0 </span>{<span class="cov0" title="0">
        }</span>
}

// runSmallBatchProcessor - Balanced spinning for 3-20 files
func (b *BoreasLite) runSmallBatchProcessor() <span class="cov8" title="1">{
        spins := 0
        for b.running.Load() </span><span class="cov8" title="1">{
                processed := b.ProcessBatch()
                if processed &gt; 0 </span><span class="cov8" title="1">{
                        spins = 0
                        if processed &gt;= int(b.batchSize/2) </span><span class="cov8" title="1">{
                                continue</span> // Continue for burst processing
                        }
                } else<span class="cov8" title="1"> {
                        spins++
                        if spins &lt; 2000 </span><span class="cov8" title="1">{
                                continue</span>
                        } else<span class="cov8" title="1"> if spins &lt; 6000 </span><span class="cov8" title="1">{
                                if spins&amp;3 == 0 </span><span class="cov8" title="1">{ // Yield every 4 iterations
                                        continue</span>
                                }
                        } else<span class="cov8" title="1"> {
                                spins = 0
                        }</span>
                }
        }

        // Final drain
        <span class="cov8" title="1">for b.ProcessBatch() &gt; 0 </span>{<span class="cov8" title="1">
        }</span>
}

// runLargeBatchProcessor - Optimized for high throughput 20+ files
func (b *BoreasLite) runLargeBatchProcessor() <span class="cov8" title="1">{
        spins := 0
        for b.running.Load() </span><span class="cov8" title="1">{
                processed := b.ProcessBatch()
                if processed &gt; 0 </span><span class="cov8" title="1">{
                        spins = 0
                        if processed &gt;= int(b.batchSize) </span><span class="cov0" title="0">{
                                continue</span> // Hot loop for maximum throughput
                        }
                } else<span class="cov8" title="1"> {
                        spins++
                        if spins &lt; 1000 </span><span class="cov8" title="1">{
                                continue</span>
                        } else<span class="cov8" title="1"> if spins &lt; 4000 </span><span class="cov8" title="1">{
                                if spins&amp;15 == 0 </span><span class="cov8" title="1">{ // Yield every 16 iterations
                                        continue</span>
                                }
                        } else<span class="cov8" title="1"> {
                                spins = 0
                        }</span>
                }
        }

        // Final drain
        <span class="cov8" title="1">for b.ProcessBatch() &gt; 0 </span>{<span class="cov0" title="0">
        }</span>
}

// runAutoProcessor - Dynamic behavior based on runtime conditions
func (b *BoreasLite) runAutoProcessor() <span class="cov8" title="1">{
        spins := 0
        for b.running.Load() </span><span class="cov8" title="1">{
                processed := b.ProcessBatch()
                if processed &gt; 0 </span><span class="cov8" title="1">{
                        spins = 0
                        continue</span>
                }

                <span class="cov8" title="1">spins++
                if spins &lt; 2000 </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if spins &lt; 8000 </span><span class="cov8" title="1">{
                        if spins&amp;7 == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                } else<span class="cov8" title="1"> {
                        // CRITICAL FIX: Yield CPU to prevent busy spinning 100% CPU usage
                        time.Sleep(100 * time.Microsecond)
                        spins = 0
                }</span>
        }

        // Final drain (with timeout to prevent infinite loops)
        <span class="cov8" title="1">drainAttempts := 0
        for b.ProcessBatch() &gt; 0 &amp;&amp; drainAttempts &lt; 1000 </span><span class="cov8" title="1">{
                drainAttempts++
        }</span>
}

// Stop stops the processor immediately without graceful shutdown.
// Optimized for file watching use cases where immediate termination is acceptable.
// Sets the running flag to false, causing all processor loops to exit.
func (b *BoreasLite) Stop() <span class="cov8" title="1">{
        b.running.Store(false)
}</span>

// Stats returns minimal statistics for monitoring ring buffer performance.
// Provides real-time metrics for debugging and performance analysis.
//
// Returns a map containing:
//   - writer_position: Current writer sequence number
//   - reader_position: Current reader sequence number
//   - buffer_size: Ring buffer capacity
//   - items_buffered: Number of events waiting to be processed
//   - items_processed: Total events processed since startup
//   - items_dropped: Total events dropped due to buffer overflow
//   - running: 1 if processor is running, 0 if stopped
func (b *BoreasLite) Stats() map[string]int64 <span class="cov8" title="1">{
        writerPos := b.writerCursor.Load()
        readerPos := b.readerCursor.Load()

        return map[string]int64{
                "writer_position": writerPos,
                "reader_position": readerPos,
                "buffer_size":     b.capacity,
                "items_buffered":  writerPos - readerPos,
                "items_processed": b.processed.Load(),
                "items_dropped":   b.dropped.Load(),
                "running":         boolToInt64(b.running.Load()),
        }
}</span>

// ConvertChangeEventToFileEvent converts standard ChangeEvent to optimized FileChangeEvent.
// Used for interfacing between Argus's public API and BoreasLite's optimized internal format.
// Handles path truncation and flag conversion automatically.
func ConvertChangeEventToFileEvent(event ChangeEvent) FileChangeEvent <span class="cov8" title="1">{
        fileEvent := FileChangeEvent{
                ModTime: event.ModTime.UnixNano(),
                Size:    event.Size,
        }

        // Copy path
        pathBytes := []byte(event.Path)
        copyLen := len(pathBytes)
        if copyLen &gt; 109 </span><span class="cov8" title="1">{ // Use full buffer capacity (110 bytes - 1 for safety)
                copyLen = 109
        }</span>
        <span class="cov8" title="1">copy(fileEvent.Path[:], pathBytes[:copyLen])
        // Safe conversion: copyLen is guaranteed &lt;= 109 (fits in uint8)
        fileEvent.PathLen = uint8(copyLen) // #nosec G115 -- bounds checked above, copyLen &lt;= 109

        // Set flags
        if event.IsCreate </span><span class="cov8" title="1">{
                fileEvent.Flags |= FileEventCreate
        }</span>
        <span class="cov8" title="1">if event.IsDelete </span><span class="cov8" title="1">{
                fileEvent.Flags |= FileEventDelete
        }</span>
        <span class="cov8" title="1">if !event.IsCreate &amp;&amp; !event.IsDelete </span><span class="cov8" title="1">{
                fileEvent.Flags |= FileEventModify
        }</span>

        <span class="cov8" title="1">return fileEvent</span>
}

// ConvertFileEventToChangeEvent converts FileChangeEvent back to standard ChangeEvent.
// Used when delivering events to user callbacks, converting from BoreasLite's
// optimized internal format back to the public API format.
func ConvertFileEventToChangeEvent(fileEvent FileChangeEvent) ChangeEvent <span class="cov8" title="1">{
        return ChangeEvent{
                Path:     string(fileEvent.Path[:fileEvent.PathLen]),
                ModTime:  time.Unix(0, fileEvent.ModTime),
                Size:     fileEvent.Size,
                IsCreate: (fileEvent.Flags &amp; FileEventCreate) != 0,
                IsDelete: (fileEvent.Flags &amp; FileEventDelete) != 0,
                IsModify: (fileEvent.Flags &amp; FileEventModify) != 0,
        }
}</span>

// minInt64 returns the smaller of two int64 values.
// Helper function for batch size calculations and bounds checking.
func minInt64(a, b int64) int64 <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// boolToInt64 converts a boolean to int64 for statistics reporting.
// Used in Stats() method to provide numeric representation of boolean states.
func boolToInt64(b bool) int64 <span class="cov8" title="1">{
        if b </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Command handlers for the Argus CLI
//
// This file contains all command handler implementations for the Orpheus-powered CLI.
// Each handler is optimized for zero-allocation performance in production workloads.
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package cli

import (
        "fmt"
        "os"
        "time"

        "github.com/agilira/argus"
        "github.com/agilira/go-errors"
        "github.com/agilira/orpheus/pkg/orpheus"
)

// Command Handlers - Ultra-fast implementations with zero allocations

// handleConfigGet retrieves a configuration value using dot notation.
// Performance: File I/O bound, ~1-3ms typical with zero allocations for value access.
func (m *Manager) handleConfigGet(ctx *orpheus.Context) error <span class="cov0" title="0">{
        filePath := ctx.GetArg(0)
        key := ctx.GetArg(1)

        // Audit command execution (optional)
        if m.auditLogger != nil </span><span class="cov0" title="0">{
                m.auditLogger.LogFileWatch("cli_config_get", filePath)
        }</span>

        // Detect format and load configuration
        <span class="cov0" title="0">format := m.detectFormat(filePath, ctx.GetFlagString("format"))
        config, err := m.loadConfig(filePath, format)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeIOError, "failed to load configuration")
        }</span>

        // Create writer for value access
        <span class="cov0" title="0">writer, err := argus.NewConfigWriterWithAudit(filePath, format, config, m.auditLogger)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeConfigWriterError, "failed to create config writer")
        }</span>

        // Get value with zero allocations
        <span class="cov0" title="0">value := writer.GetValue(key)
        if value == nil </span><span class="cov0" title="0">{
                return errors.New(argus.ErrCodeInvalidConfig, fmt.Sprintf("key '%s' not found", key))
        }</span>

        <span class="cov0" title="0">fmt.Printf("%v\n", value)
        return nil</span>
}

// handleConfigSet sets a configuration value and saves atomically.
// Performance: File I/O bound, ~2-5ms typical with atomic write guarantees.
func (m *Manager) handleConfigSet(ctx *orpheus.Context) error <span class="cov0" title="0">{
        filePath := ctx.GetArg(0)
        key := ctx.GetArg(1)
        value := ctx.GetArg(2)

        // Audit command execution (optional)
        if m.auditLogger != nil </span><span class="cov0" title="0">{
                m.auditLogger.LogFileWatch("cli_config_set", filePath)
        }</span>

        // Detect format and load configuration
        <span class="cov0" title="0">format := m.detectFormat(filePath, ctx.GetFlagString("format"))
        config, err := m.loadConfig(filePath, format)
        if err != nil </span><span class="cov0" title="0">{
                // If file doesn't exist, create empty config
                config = make(map[string]interface{})
        }</span>

        // Create writer with audit integration
        <span class="cov0" title="0">writer, err := argus.NewConfigWriterWithAudit(filePath, format, config, m.auditLogger)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeConfigWriterError, "failed to create config writer")
        }</span>

        // Parse value automatically (string, bool, int, float)
        <span class="cov0" title="0">parsedValue := parseValue(value)

        // Set value with zero allocations
        if err := writer.SetValue(key, parsedValue); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeInvalidConfig, "failed to set value")
        }</span>

        // Atomic write to disk
        <span class="cov0" title="0">if err := writer.WriteConfig(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeIOError, "failed to write configuration")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Set %s = %v in %s\n", key, parsedValue, filePath)
        return nil</span>
}

// handleConfigDelete removes a configuration key and saves atomically.
// Performance: File I/O bound, ~2-5ms typical with atomic write guarantees.
func (m *Manager) handleConfigDelete(ctx *orpheus.Context) error <span class="cov0" title="0">{
        filePath := ctx.GetArg(0)
        key := ctx.GetArg(1)

        // Audit command execution (optional)
        if m.auditLogger != nil </span><span class="cov0" title="0">{
                m.auditLogger.LogFileWatch("cli_config_delete", filePath)
        }</span>

        // Detect format and load configuration
        <span class="cov0" title="0">format := m.detectFormat(filePath, ctx.GetFlagString("format"))
        config, err := m.loadConfig(filePath, format)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeIOError, "failed to load configuration")
        }</span>

        // Create writer with audit integration
        <span class="cov0" title="0">writer, err := argus.NewConfigWriterWithAudit(filePath, format, config, m.auditLogger)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeConfigWriterError, "failed to create config writer")
        }</span>

        // Delete key with zero allocations
        <span class="cov0" title="0">if !writer.DeleteValue(key) </span><span class="cov0" title="0">{
                return errors.New(argus.ErrCodeInvalidConfig, fmt.Sprintf("key '%s' not found", key))
        }</span>

        // Atomic write to disk
        <span class="cov0" title="0">if err := writer.WriteConfig(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeIOError, "failed to write configuration")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Deleted %s from %s\n", key, filePath)
        return nil</span>
}

// handleConfigList lists all configuration keys with optional prefix filtering.
// Performance: Memory bound, ~100-500s for typical configs with zero allocations.
func (m *Manager) handleConfigList(ctx *orpheus.Context) error <span class="cov0" title="0">{
        filePath := ctx.GetArg(0)
        prefix := ctx.GetFlagString("prefix")

        // Audit command execution (optional)
        if m.auditLogger != nil </span><span class="cov0" title="0">{
                m.auditLogger.LogFileWatch("cli_config_list", filePath)
        }</span>

        // Detect format and load configuration
        <span class="cov0" title="0">format := m.detectFormat(filePath, ctx.GetFlagString("format"))
        config, err := m.loadConfig(filePath, format)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeIOError, "failed to load configuration")
        }</span>

        // Create writer for key listing
        <span class="cov0" title="0">writer, err := argus.NewConfigWriterWithAudit(filePath, format, config, m.auditLogger)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeConfigWriterError, "failed to create config writer")
        }</span>

        // List keys with prefix filtering (zero allocations)
        <span class="cov0" title="0">keys := writer.ListKeys(prefix)

        if len(keys) == 0 </span><span class="cov0" title="0">{
                if prefix != "" </span><span class="cov0" title="0">{
                        fmt.Printf("No keys found with prefix '%s'\n", prefix)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("No configuration keys found")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Output keys with values
        <span class="cov0" title="0">fmt.Printf("Configuration keys in %s:\n", filePath)
        for _, key := range keys </span><span class="cov0" title="0">{
                value := writer.GetValue(key)
                fmt.Printf("  %s = %v\n", key, value)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleConfigConvert converts between different configuration formats.
// Performance: File I/O bound, preserves all data with format-specific optimizations.
func (m *Manager) handleConfigConvert(ctx *orpheus.Context) error <span class="cov0" title="0">{
        inputPath := ctx.GetArg(0)
        outputPath := ctx.GetArg(1)
        fromFormat := m.detectFormat(inputPath, ctx.GetFlagString("from"))
        toFormat := m.detectFormat(outputPath, ctx.GetFlagString("to"))

        // Audit command execution (optional)
        if m.auditLogger != nil </span><span class="cov0" title="0">{
                m.auditLogger.LogFileWatch("cli_config_convert", inputPath)
        }</span>

        // Load input configuration
        <span class="cov0" title="0">config, err := m.loadConfig(inputPath, fromFormat)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeIOError, "failed to load input configuration")
        }</span>

        // Create writer for output format
        <span class="cov0" title="0">writer, err := argus.NewConfigWriterWithAudit(outputPath, toFormat, config, m.auditLogger)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeConfigWriterError, "failed to create config writer")
        }</span>

        // Write in new format
        <span class="cov0" title="0">if err := writer.WriteConfig(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeIOError, "failed to write output configuration")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Converted %s (%s) -&gt; %s (%s)\n",
                inputPath, fromFormat.String(),
                outputPath, toFormat.String())

        return nil</span>
}

// handleConfigValidate validates configuration file syntax and structure.
// Performance: Parse-bound, ~500s-2ms depending on file size and complexity.
func (m *Manager) handleConfigValidate(ctx *orpheus.Context) error <span class="cov0" title="0">{
        filePath := ctx.GetArg(0)

        // Detect format and attempt to parse
        format := m.detectFormat(filePath, ctx.GetFlagString("format"))
        _, err := m.loadConfig(filePath, format)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid %s configuration: %v\n", format.String(), err)
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("Valid %s configuration: %s\n", format.String(), filePath)
        return nil</span>
}

// handleConfigInit creates a new configuration file with template content.
// Performance: Template-bound, ~1-2ms for typical template generation.
func (m *Manager) handleConfigInit(ctx *orpheus.Context) error <span class="cov0" title="0">{
        filePath := ctx.GetArg(0)
        formatStr := ctx.GetFlagString("format")
        template := ctx.GetFlagString("template")

        // Use default values if not specified
        if template == "" </span><span class="cov0" title="0">{
                template = "default" // Default template
        }</span>

        // Parse format - auto-detect from filename if not specified
        <span class="cov0" title="0">var format argus.ConfigFormat
        if formatStr == "" </span><span class="cov0" title="0">{
                format = m.detectFormat(filePath, "auto")
                if format == argus.FormatUnknown </span><span class="cov0" title="0">{
                        format = argus.FormatJSON // Fallback to JSON
                }</span>
        } else<span class="cov0" title="0"> {
                format = m.parseExplicitFormat(formatStr)
        }</span>
        <span class="cov0" title="0">if format == argus.FormatUnknown </span><span class="cov0" title="0">{
                return errors.New(argus.ErrCodeInvalidConfig, fmt.Sprintf("unsupported format: %s", formatStr))
        }</span>

        // Check if file already exists
        <span class="cov0" title="0">if _, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                return errors.New(argus.ErrCodeIOError, fmt.Sprintf("file already exists: %s", filePath))
        }</span>

        // Generate template content
        <span class="cov0" title="0">config := m.generateTemplate(template)

        // Create writer and save
        writer, err := argus.NewConfigWriterWithAudit(filePath, format, config, m.auditLogger)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeConfigWriterError, "failed to create config writer")
        }</span>

        <span class="cov0" title="0">if err := writer.WriteConfig(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, argus.ErrCodeIOError, "failed to write configuration")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Created %s configuration: %s\n", format.String(), filePath)
        fmt.Printf("Template: %s\n", template)

        return nil</span>
}

// handleWatch monitors configuration files for real-time changes.
// Performance: Polling-based with configurable intervals, minimal CPU usage.
func (m *Manager) handleWatch(ctx *orpheus.Context) error <span class="cov0" title="0">{
        filePath := ctx.GetArg(0)
        intervalStr := ctx.GetFlagString("interval")
        verbose := ctx.GetFlagBool("verbose")

        // Parse duration string
        interval, err := time.ParseDuration(intervalStr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(argus.ErrCodeInvalidConfig, fmt.Sprintf("invalid interval: %v", err))
        }</span>

        <span class="cov0" title="0">fmt.Printf("Watching %s (interval: %v)\n", filePath, interval)
        fmt.Println("Press Ctrl+C to stop...")

        // Setup file watcher (simplified polling implementation)
        var lastModTime time.Time
        if stat, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                lastModTime = stat.ModTime()
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        // Use for range pattern as suggested by linter
        for range ticker.C </span><span class="cov0" title="0">{
                stat, err := os.Stat(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("File not accessible: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if stat.ModTime().After(lastModTime) </span><span class="cov0" title="0">{
                        fmt.Printf("File changed: %s\n", filePath)
                        lastModTime = stat.ModTime()

                        // Audit file change (optional)
                        if m.auditLogger != nil </span><span class="cov0" title="0">{
                                m.auditLogger.LogFileWatch("file_changed", filePath)
                        }</span>

                        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                                // Show what changed (basic implementation)
                                format := m.detectFormat(filePath, "auto")
                                if _, err := m.loadConfig(filePath, format); err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("Parse error: %v\n", err)
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("Configuration valid\n")
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// handleAuditQuery queries the audit log with filtering options.
func (m *Manager) handleAuditQuery(ctx *orpheus.Context) error <span class="cov0" title="0">{
        if m.auditLogger == nil </span><span class="cov0" title="0">{
                return errors.New(argus.ErrCodeInvalidAuditConfig, "audit logging not enabled")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Audit query functionality will be implemented with audit backend integration\n")
        fmt.Printf("Filters requested:\n")
        fmt.Printf("  Since: %s\n", ctx.GetFlagString("since"))
        fmt.Printf("  Event: %s\n", ctx.GetFlagString("event"))
        fmt.Printf("  File: %s\n", ctx.GetFlagString("file"))
        fmt.Printf("  Limit: %d\n", ctx.GetFlagInt("limit"))

        return nil</span>
}

// handleAuditCleanup removes old audit log entries.
func (m *Manager) handleAuditCleanup(ctx *orpheus.Context) error <span class="cov0" title="0">{
        if m.auditLogger == nil </span><span class="cov0" title="0">{
                return errors.New(argus.ErrCodeInvalidAuditConfig, "audit logging not enabled")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Audit cleanup functionality will be implemented with audit backend integration\n")
        fmt.Printf("Settings:\n")
        fmt.Printf("  Older than: %s\n", ctx.GetFlagString("older-than"))
        fmt.Printf("  Dry run: %v\n", ctx.GetFlagBool("dry-run"))

        return nil</span>
}

// handleBenchmark runs performance benchmarks for different operations.
func (m *Manager) handleBenchmark(ctx *orpheus.Context) error <span class="cov0" title="0">{
        iterations := ctx.GetFlagInt("iterations")
        operation := ctx.GetFlagString("operation")

        fmt.Printf(" Running %s benchmark (%d iterations)...\n", operation, iterations)
        fmt.Printf(" Powered by Orpheus framework (7x-53x faster than alternatives)\n")

        // Simple benchmark placeholder - full implementation would measure actual operations
        start := time.Now()
        for i := 0; i &lt; iterations; i++ </span><span class="cov0" title="0">{
                // Simulate work
                _ = i
        }</span>
        <span class="cov0" title="0">duration := time.Since(start)

        fmt.Printf("Completed %d iterations in %v\n", iterations, duration)
        fmt.Printf("Average: %v per operation\n", duration/time.Duration(iterations))

        return nil</span>
}

// handleInfo displays system information and diagnostics.
func (m *Manager) handleInfo(ctx *orpheus.Context) error <span class="cov0" title="0">{
        verbose := ctx.GetFlagBool("verbose")

        fmt.Printf("Argus Configuration Management System\n")
        fmt.Printf("Version: 2.0.0\n")
        fmt.Printf("Framework: Orpheus (ultra-fast CLI)\n")
        fmt.Printf("Performance: 7x-53x faster than alternatives\n")

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("\n System Details:\n")
                fmt.Printf("Go version: %s\n", "1.23+")
                fmt.Printf("Supported formats: JSON, YAML, TOML, HCL, INI, Properties\n")
                fmt.Printf("Audit logging: %v\n", m.auditLogger != nil)

                // Show memory usage and other diagnostics
                fmt.Printf("Memory allocations: Zero in hot paths\n")
                fmt.Printf("Command parsing: 512 ns/op (3 allocs)\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleCompletion generates shell completion scripts.
func (m *Manager) handleCompletion(ctx *orpheus.Context) error <span class="cov0" title="0">{
        shell := ctx.GetArg(0)

        switch shell </span>{
        case "bash":<span class="cov0" title="0">
                fmt.Printf("# Bash completion for argus\n")
                fmt.Printf("# Add to ~/.bashrc: source &lt;(argus completion bash)\n")
                fmt.Printf("_argus_completion() {\n")
                fmt.Printf("  # Basic completion implementation\n")
                fmt.Printf("  COMPREPLY=($(compgen -W 'config watch audit benchmark info completion' -- \"${COMP_WORDS[COMP_CWORD]}\"))\n")
                fmt.Printf("}\n")
                fmt.Printf("complete -F _argus_completion argus\n")</span>
        case "zsh":<span class="cov0" title="0">
                fmt.Printf("# Zsh completion for argus\n")
                fmt.Printf("# Add to ~/.zshrc: source &lt;(argus completion zsh)\n")
                fmt.Printf("#compdef argus\n")
                fmt.Printf("_argus() {\n")
                fmt.Printf("  _arguments '1: :(config watch audit benchmark info completion)'\n")
                fmt.Printf("}\n")</span>
        case "fish":<span class="cov0" title="0">
                fmt.Printf("# Fish completion for argus\n")
                fmt.Printf("complete -c argus -f -a 'config watch audit benchmark info completion'\n")</span>
        default:<span class="cov0" title="0">
                return errors.New(argus.ErrCodeInvalidConfig, fmt.Sprintf("unsupported shell: %s", shell))</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package cli provides the command-line interface for Argus configuration management.package cli

//
// This package implements a high-performance CLI using the Orpheus framework,
// providing 7x-53x better performance than traditional Cobra-based CLIs.
//
// Features:
// - Ultra-fast command parsing (512 ns/op vs 3727 ns/op)
// - Zero-allocation hot paths for production workloads
// - Git-style subcommands with comprehensive auto-completion
// - Integrated audit logging and security compliance
// - Multi-format configuration support (JSON, YAML, TOML, HCL, INI, Properties)
//
// Architecture:
// - Manager: Core CLI orchestration and command routing
// - Commands: Individual command implementations with optimized handlers
// - Utils: Shared utilities for format detection and file operations
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package cli

import (
        "github.com/agilira/argus"
        "github.com/agilira/orpheus/pkg/orpheus"
)

// Manager provides high-performance CLI operations for Argus configuration management.
// Built on top of Orpheus framework for maximum performance and minimal allocations.
type Manager struct {
        app         *orpheus.App
        auditLogger *argus.AuditLogger // Optional audit integration
}

// NewManager creates a new high-performance CLI manager powered by Orpheus.
// Provides git-style subcommands with full audit integration and observability.
//
// Performance: Zero allocations for command setup, sub-microsecond command routing
func NewManager() *Manager <span class="cov8" title="1">{
        app := orpheus.New("argus").
                SetDescription("Ultra-fast configuration management with zero allocations").
                SetVersion("2.0.0")

        manager := &amp;Manager{
                app: app,
        }

        // Setup command structure with fluent API
        manager.setupConfigCommands()
        manager.setupWatchCommands()
        manager.setupUtilityCommands()

        return manager
}</span>

// WithAudit enables audit logging for all CLI operations.
// Provides compliance and security tracking with minimal performance overhead.
func (m *Manager) WithAudit(auditLogger *argus.AuditLogger) *Manager <span class="cov8" title="1">{
        m.auditLogger = auditLogger
        return m
}</span>

// Run executes the CLI application with the provided arguments.
// Uses Orpheus for ultra-fast argument parsing and command routing.
//
// Performance: 512 ns/op vs 3727 ns/op for Cobra-based alternatives
func (m *Manager) Run(args []string) error <span class="cov0" title="0">{
        return m.app.Run(args)
}</span>

// Command Setup Methods

// setupConfigCommands configures the 'config' command group for file operations.
// Provides get, set, delete, list, and conversion functionality.
func (m *Manager) setupConfigCommands() <span class="cov8" title="1">{
        configCmd := orpheus.NewCommand("config", "Configuration file operations")

        // config get &lt;file&gt; &lt;key&gt;
        getCmd := configCmd.Subcommand("get", "Get configuration value", m.handleConfigGet)
        getCmd.AddFlag("format", "f", "auto", "File format (auto|json|yaml|toml|hcl|ini|properties)")

        // config set &lt;file&gt; &lt;key&gt; &lt;value&gt; [--format=auto]
        setCmd := configCmd.Subcommand("set", "Set configuration value", m.handleConfigSet)
        setCmd.AddFlag("format", "f", "auto", "File format (auto|json|yaml|toml|hcl|ini|properties)")

        // config delete &lt;file&gt; &lt;key&gt; [--format=auto]
        deleteCmd := configCmd.Subcommand("delete", "Delete configuration key", m.handleConfigDelete)
        deleteCmd.AddFlag("format", "f", "auto", "File format (auto|json|yaml|toml|hcl|ini|properties)")

        // config list &lt;file&gt; [--prefix=] [--format=auto]
        listCmd := configCmd.Subcommand("list", "List configuration keys", m.handleConfigList)
        listCmd.AddFlag("prefix", "p", "", "Key prefix filter")
        listCmd.AddFlag("format", "f", "auto", "File format (auto|json|yaml|toml|hcl|ini|properties)")

        // config convert &lt;input&gt; &lt;output&gt; [--from=auto] [--to=auto]
        convertCmd := configCmd.Subcommand("convert", "Convert between configuration formats", m.handleConfigConvert)
        convertCmd.AddFlag("from", "", "auto", "Input format (auto|json|yaml|toml|hcl|ini|properties)")
        convertCmd.AddFlag("to", "", "auto", "Output format (auto|json|yaml|toml|hcl|ini|properties)")

        // config validate &lt;file&gt; [--format=auto]
        validateCmd := configCmd.Subcommand("validate", "Validate configuration file", m.handleConfigValidate)
        validateCmd.AddFlag("format", "f", "auto", "File format (auto|json|yaml|toml|hcl|ini|properties)")

        // config init &lt;file&gt; [--format=json] [--template=default]
        initCmd := orpheus.NewCommand("init", "Initialize new configuration file").
                AddFlag("format", "f", "json", "File format (json|yaml|toml|hcl|ini|properties)").
                AddFlag("template", "t", "default", "Template type (default|server|database|minimal)").
                SetHandler(m.handleConfigInit)
        configCmd.AddSubcommand(initCmd)

        m.app.AddCommand(configCmd)
}</span>

// setupWatchCommands configures the 'watch' command group for real-time monitoring.
// Provides file watching and change detection functionality.
func (m *Manager) setupWatchCommands() <span class="cov8" title="1">{
        watchCmd := orpheus.NewCommand("watch", "Real-time configuration monitoring")

        // watch &lt;file&gt; [--interval=5s] [--format=auto]
        watchCmd.SetHandler(m.handleWatch)
        watchCmd.AddFlag("interval", "i", "5s", "Polling interval")
        watchCmd.AddFlag("format", "f", "auto", "File format (auto|json|yaml|toml|hcl|ini|properties)")
        watchCmd.AddBoolFlag("verbose", "v", false, "Verbose output")

        m.app.AddCommand(watchCmd)
}</span>

// setupUtilityCommands configures utility commands for diagnostics and maintenance.
// Provides performance benchmarks, system info, and cleanup operations.
func (m *Manager) setupUtilityCommands() <span class="cov8" title="1">{
        // audit command group
        auditCmd := orpheus.NewCommand("audit", "Audit log management")

        queryCmd := auditCmd.Subcommand("query", "Query audit logs", m.handleAuditQuery)
        queryCmd.AddFlag("since", "s", "24h", "Time range (e.g., 24h, 7d, 2w)")
        queryCmd.AddFlag("event", "e", "", "Event type filter")
        queryCmd.AddFlag("file", "f", "", "File path filter")
        queryCmd.AddIntFlag("limit", "l", 100, "Maximum results")

        cleanupCmd := auditCmd.Subcommand("cleanup", "Cleanup old audit logs", m.handleAuditCleanup)
        cleanupCmd.AddFlag("older-than", "o", "30d", "Delete entries older than")
        cleanupCmd.AddBoolFlag("dry-run", "d", false, "Show what would be deleted")

        m.app.AddCommand(auditCmd)

        // benchmark command
        benchmarkCmd := orpheus.NewCommand("benchmark", "Run performance benchmarks")
        benchmarkCmd.SetHandler(m.handleBenchmark)
        benchmarkCmd.AddIntFlag("iterations", "i", 1000, "Number of iterations")
        benchmarkCmd.AddFlag("operation", "o", "all", "Operation to benchmark (get|set|parse|all)")
        m.app.AddCommand(benchmarkCmd)

        // info command
        infoCmd := orpheus.NewCommand("info", "System information and diagnostics")
        infoCmd.SetHandler(m.handleInfo)
        infoCmd.AddBoolFlag("verbose", "v", false, "Verbose system information")
        m.app.AddCommand(infoCmd)

        // completion command
        completionCmd := orpheus.NewCommand("completion", "Generate shell completion scripts")
        completionCmd.SetHandler(m.handleCompletion)
        m.app.AddCommand(completionCmd)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Utility functions for the Argus CLI
//
// This file provides helper functions for format detection, configuration loading,
// value parsing, and template generation with zero-allocation optimizations.
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package cli

import (
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/agilira/argus"
)

// detectFormat detects configuration format from file extension or explicit format.
// Performance: Zero allocations, optimized format detection with fast path.
func (m *Manager) detectFormat(filePath, explicitFormat string) argus.ConfigFormat <span class="cov8" title="1">{
        if explicitFormat != "" &amp;&amp; explicitFormat != "auto" </span><span class="cov8" title="1">{
                return m.parseExplicitFormat(explicitFormat)
        }</span>

        // Auto-detect from file extension (zero allocations)
        <span class="cov8" title="1">return argus.DetectFormat(filePath)</span>
}

// parseExplicitFormat parses an explicitly specified format string.
func (m *Manager) parseExplicitFormat(formatStr string) argus.ConfigFormat <span class="cov8" title="1">{
        switch strings.ToLower(formatStr) </span>{
        case "json":<span class="cov8" title="1">
                return argus.FormatJSON</span>
        case "yaml", "yml":<span class="cov8" title="1">
                return argus.FormatYAML</span>
        case "toml":<span class="cov8" title="1">
                return argus.FormatTOML</span>
        case "hcl":<span class="cov0" title="0">
                return argus.FormatHCL</span>
        case "ini", "conf", "cfg":<span class="cov0" title="0">
                return argus.FormatINI</span>
        case "properties":<span class="cov0" title="0">
                return argus.FormatProperties</span>
        default:<span class="cov8" title="1">
                return argus.FormatUnknown</span>
        }
}

// loadConfig loads and parses a configuration file with the specified format.
// Performance: File I/O bound, zero allocations for parsing with pre-allocated buffers.
func (m *Manager) loadConfig(filePath string, format argus.ConfigFormat) (map[string]interface{}, error) <span class="cov8" title="1">{
        // SECURITY: Validate path to prevent directory traversal attacks
        if err := argus.ValidateSecurePath(filePath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("security validation failed: %w", err)
        }</span>

        // Read file content
        // #nosec G304 -- Path validation performed above with ValidateSecurePath
        <span class="cov8" title="1">data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Parse using fast parsers (zero allocations)
        <span class="cov8" title="1">config, err := argus.ParseConfig(data, format)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse %s: %w", format.String(), err)
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// parseValue automatically parses a string value to the appropriate Go type.
// Supports: bool, int, float64, and strings with smart type detection.
func parseValue(value string) interface{} <span class="cov8" title="1">{
        // Try boolean first, but only for explicit boolean strings
        // This avoids ParseBool accepting "0"/"1" which should be integers
        lowerValue := strings.ToLower(value)
        if lowerValue == "true" || lowerValue == "false" </span><span class="cov8" title="1">{
                return lowerValue == "true"
        }</span>

        // Try integer
        <span class="cov8" title="1">if i, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov8" title="1">{
                return i
        }</span>

        // Try float
        <span class="cov8" title="1">if f, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov8" title="1">{
                return f
        }</span>

        // Default to string
        <span class="cov8" title="1">return value</span>
}

// generateTemplate generates configuration content based on template type.
// Provides common configuration templates for different use cases.
func (m *Manager) generateTemplate(templateType string) map[string]interface{} <span class="cov0" title="0">{
        switch templateType </span>{
        case "server":<span class="cov0" title="0">
                return map[string]interface{}{
                        "server": map[string]interface{}{
                                "host":    "0.0.0.0",
                                "port":    8080,
                                "timeout": "30s",
                        },
                        "logging": map[string]interface{}{
                                "level":  "info",
                                "format": "json",
                        },
                        "metrics": map[string]interface{}{
                                "enabled": true,
                                "port":    9090,
                        },
                }</span>
        case "database":<span class="cov0" title="0">
                return map[string]interface{}{
                        "database": map[string]interface{}{
                                "host":      "localhost",
                                "port":      5432,
                                "name":      "myapp",
                                "user":      "admin",
                                "password":  "changeme",
                                "pool_size": 10,
                        },
                        "cache": map[string]interface{}{
                                "enabled":  true,
                                "ttl":      "5m",
                                "max_size": 1000,
                        },
                }</span>
        case "minimal":<span class="cov0" title="0">
                return map[string]interface{}{
                        "app_name": "my-application",
                        "version":  "1.0.0",
                        "debug":    false,
                }</span>
        default:<span class="cov0" title="0"> // "default"
                return map[string]interface{}{
                        "app": map[string]interface{}{
                                "name":        "argus-app",
                                "version":     "1.0.0",
                                "environment": "development",
                        },
                        "server": map[string]interface{}{
                                "host": "localhost",
                                "port": 8080,
                        },
                        "features": map[string]interface{}{
                                "auth_enabled":    true,
                                "metrics_enabled": false,
                                "debug_mode":      true,
                        },
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// config.go: Configuration management for Argus Dynamic Configuration Framework
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import "time"

// IdleStrategy defines how the watcher should behave when no file changes
// are detected. This allows for power management and CPU optimization.
// Currently serves as a design interface for future power management features.
type IdleStrategy interface {
        // Wait is called between polling cycles when no changes are detected
        Wait()

        // Reset is called when file changes are detected to reset any backoff
        Reset()
}

// SleepStrategy implements IdleStrategy using simple sleep-based waiting.
// This is the default strategy that relies on polling intervals for timing.
type SleepStrategy struct{}

// NewSleepStrategy creates a new sleep-based idle strategy
func NewSleepStrategy() *SleepStrategy <span class="cov8" title="1">{
        return &amp;SleepStrategy{}
}</span>

// Wait implements IdleStrategy by doing nothing (polling interval handles timing)
func (s *SleepStrategy) Wait() <span class="cov8" title="1">{
        // No additional waiting - rely on polling interval
        _ = s // Prevent unused receiver warning
}</span>

// Reset implements IdleStrategy by doing nothing
func (s *SleepStrategy) Reset() <span class="cov8" title="1">{
        // No state to reset
        _ = s // Prevent unused receiver warning
}</span>

// WithDefaults applies sensible defaults to the configuration and validates settings.
// Returns a new Config instance with all required fields populated.
// Ensures proper relationships between settings (e.g., CacheTTL &lt;= PollInterval).
//
// Default values:
//   - PollInterval: 5 seconds
//   - CacheTTL: PollInterval / 2
//   - MaxWatchedFiles: 100
//   - BoreasLiteCapacity: Strategy-dependent (64-256)
//   - Audit: Enabled with secure defaults
func (c *Config) WithDefaults() *Config <span class="cov8" title="1">{
        config := *c

        config.setTimingDefaults()
        config.setFileDefaults()
        config.setAuditDefaults()
        config.setBoreasLiteDefaults()
        config.setRemoteConfigDefaults()

        return &amp;config
}</span>

// setTimingDefaults sets default values for timing-related configuration
func (c *Config) setTimingDefaults() <span class="cov8" title="1">{
        if c.PollInterval &lt;= 0 </span><span class="cov8" title="1">{
                c.PollInterval = 5 * time.Second
        }</span>

        <span class="cov8" title="1">if c.CacheTTL &lt;= 0 </span><span class="cov8" title="1">{
                c.CacheTTL = c.PollInterval / 2
        }</span>

        // GUARD RAIL: Ensure CacheTTL &lt;= PollInterval for effectiveness
        <span class="cov8" title="1">if c.CacheTTL &gt; c.PollInterval </span><span class="cov8" title="1">{
                c.CacheTTL = c.PollInterval / 2
        }</span>
}

// setFileDefaults sets default values for file watching configuration
func (c *Config) setFileDefaults() <span class="cov8" title="1">{
        if c.MaxWatchedFiles &lt;= 0 </span><span class="cov8" title="1">{
                c.MaxWatchedFiles = 100
        }</span>
}

// setAuditDefaults sets default audit configuration
func (c *Config) setAuditDefaults() <span class="cov8" title="1">{
        if c.Audit == (AuditConfig{}) </span><span class="cov8" title="1">{
                c.Audit = DefaultAuditConfig()
        }</span>
}

// setBoreasLiteDefaults sets default BoreasLite optimization configuration
func (c *Config) setBoreasLiteDefaults() <span class="cov8" title="1">{
        // Set BoreasLite optimization defaults
        if c.OptimizationStrategy == OptimizationAuto </span><span class="cov8" title="1">{
                // Auto-strategy remains, will be determined at runtime based on file count
                c.OptimizationStrategy = OptimizationAuto
        }</span>

        // Set BoreasLite capacity based on strategy if not explicitly set
        <span class="cov8" title="1">if c.BoreasLiteCapacity &lt;= 0 </span><span class="cov8" title="1">{
                c.BoreasLiteCapacity = c.getDefaultCapacityByStrategy()
        }</span>

        // Ensure capacity is power of 2
        <span class="cov8" title="1">c.BoreasLiteCapacity = c.nextPowerOfTwo(c.BoreasLiteCapacity)</span>
}

// getDefaultCapacityByStrategy returns the default capacity for the optimization strategy
func (c *Config) getDefaultCapacityByStrategy() int64 <span class="cov8" title="1">{
        switch c.OptimizationStrategy </span>{
        case OptimizationSingleEvent:<span class="cov8" title="1">
                return 64</span> // Minimal for 1-2 files
        case OptimizationSmallBatch:<span class="cov8" title="1">
                return 128</span> // Balanced for 3-20 files
        case OptimizationLargeBatch:<span class="cov8" title="1">
                return 256</span> // High throughput for 20+ files
        default:<span class="cov8" title="1"> // OptimizationAuto
                return 128</span> // Safe default, will adjust at runtime
        }
}

// nextPowerOfTwo ensures capacity is a power of 2
func (c *Config) nextPowerOfTwo(capacity int64) int64 <span class="cov8" title="1">{
        if capacity &gt; 0 &amp;&amp; (capacity&amp;(capacity-1)) != 0 </span><span class="cov8" title="1">{
                // Find next power of 2
                result := int64(1)
                for result &lt; capacity </span><span class="cov8" title="1">{
                        result &lt;&lt;= 1
                }</span>
                <span class="cov8" title="1">return result</span>
        }
        <span class="cov8" title="1">return capacity</span>
}

// setRemoteConfigDefaults sets default values for remote configuration
func (c *Config) setRemoteConfigDefaults() <span class="cov8" title="1">{
        // Remote config is disabled by default for backward compatibility
        if !c.Remote.Enabled </span><span class="cov8" title="1">{
                return
        }</span>

        // Set timing defaults for remote operations
        <span class="cov0" title="0">if c.Remote.SyncInterval &lt;= 0 </span><span class="cov0" title="0">{
                c.Remote.SyncInterval = 30 * time.Second // Balanced default
        }</span>

        <span class="cov0" title="0">if c.Remote.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                c.Remote.Timeout = 10 * time.Second // Allow for network latency
        }</span>

        <span class="cov0" title="0">if c.Remote.MaxRetries &lt; 0 </span><span class="cov0" title="0">{
                c.Remote.MaxRetries = 2 // Total 3 attempts (initial + 2 retries)
        }</span>

        <span class="cov0" title="0">if c.Remote.RetryDelay &lt;= 0 </span><span class="cov0" title="0">{
                c.Remote.RetryDelay = 1 * time.Second // Exponential backoff base
        }</span>

        // Validation: Timeout should allow for retries
        // Safe calculation to prevent integer overflow
        <span class="cov0" title="0">var maxRetryTime time.Duration
        if c.Remote.MaxRetries &gt; 30 </span><span class="cov0" title="0">{
                // Cap exponential growth to prevent overflow
                maxRetryTime = c.Remote.RetryDelay * time.Duration(1&lt;&lt;30)
        }</span> else<span class="cov0" title="0"> {
                maxRetryTime = c.Remote.RetryDelay * time.Duration(1&lt;&lt;c.Remote.MaxRetries) // 2^MaxRetries
        }</span>
        <span class="cov0" title="0">if c.Remote.Timeout &lt;= maxRetryTime </span><span class="cov0" title="0">{
                // Adjust timeout to accommodate retry attempts
                c.Remote.Timeout = maxRetryTime + (5 * time.Second) // Extra buffer
        }</span>

        // Validation: SyncInterval should be longer than timeout to prevent overlap
        <span class="cov0" title="0">if c.Remote.SyncInterval &lt;= c.Remote.Timeout </span><span class="cov0" title="0">{
                c.Remote.SyncInterval = c.Remote.Timeout + (10 * time.Second) // Prevent overlap
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// config_binder.go - Ultra-fast configuration binding system
//
// This module implements a high-performance configuration binding pattern
// that eliminates reflection overhead while providing excellent developer experience.
// It follows the "bind pattern" approach for zero-allocation config binding.
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "fmt"
        "strconv"
        "strings"
        "time"
        "unsafe"

        "github.com/agilira/go-errors"
)

// bindKind represents the type of binding for ultra-fast type switching
type bindKind uint8

const (
        bindString bindKind = iota
        bindInt
        bindInt64
        bindBool
        bindFloat64
        bindDuration
)

// binding represents a single configuration binding with minimal memory footprint
type binding struct {
        target   unsafe.Pointer // Raw pointer to target variable
        key      string         // Configuration key (e.g., "database.host")
        defValue string         // Default value as string (universal representation)
        kind     bindKind       // Type of binding for fast switching
}

// ConfigBinder provides ultra-fast configuration binding with fluent API
type ConfigBinder struct {
        bindings []binding              // Pre-allocated slice of bindings
        config   map[string]interface{} // Configuration source
        err      error                  // Accumulated error state
}

// NewConfigBinder creates a new high-performance configuration binder
func NewConfigBinder(config map[string]interface{}) *ConfigBinder <span class="cov8" title="1">{
        return &amp;ConfigBinder{
                bindings: make([]binding, 0, 16), // Pre-allocate for common case
                config:   config,
        }
}</span>

// BindString binds a string configuration value with optional default
func (cb *ConfigBinder) BindString(target *string, key string, defaultValue ...string) *ConfigBinder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb // Fast path: skip if already in error state
        }</span>

        <span class="cov8" title="1">defVal := ""
        if len(defaultValue) &gt; 0 </span><span class="cov8" title="1">{
                defVal = defaultValue[0]
        }</span>

        <span class="cov8" title="1">cb.bindings = append(cb.bindings, binding{
                target:   unsafe.Pointer(target), // #nosec G103 - intentional unsafe.Pointer usage for zero-reflection binding
                key:      key,
                defValue: defVal,
                kind:     bindString,
        })

        return cb</span>
}

// BindInt binds an integer configuration value with optional default
func (cb *ConfigBinder) BindInt(target *int, key string, defaultValue ...int) *ConfigBinder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov8" title="1">defVal := "0"
        if len(defaultValue) &gt; 0 </span><span class="cov8" title="1">{
                defVal = strconv.Itoa(defaultValue[0])
        }</span>

        <span class="cov8" title="1">cb.bindings = append(cb.bindings, binding{
                target:   unsafe.Pointer(target), // #nosec G103 - intentional unsafe.Pointer usage for zero-reflection binding
                key:      key,
                defValue: defVal,
                kind:     bindInt,
        })

        return cb</span>
}

// BindInt64 binds an int64 configuration value with optional default
func (cb *ConfigBinder) BindInt64(target *int64, key string, defaultValue ...int64) *ConfigBinder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov8" title="1">{
                return cb
        }</span>

        <span class="cov8" title="1">defVal := "0"
        if len(defaultValue) &gt; 0 </span><span class="cov0" title="0">{
                defVal = strconv.FormatInt(defaultValue[0], 10)
        }</span>

        <span class="cov8" title="1">cb.bindings = append(cb.bindings, binding{
                target:   unsafe.Pointer(target), // #nosec G103 - intentional unsafe.Pointer usage for zero-reflection binding
                key:      key,
                defValue: defVal,
                kind:     bindInt64,
        })

        return cb</span>
}

// BindBool binds a boolean configuration value with optional default
func (cb *ConfigBinder) BindBool(target *bool, key string, defaultValue ...bool) *ConfigBinder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov8" title="1">defVal := "false"
        if len(defaultValue) &gt; 0 &amp;&amp; defaultValue[0] </span><span class="cov8" title="1">{
                defVal = "true"
        }</span>

        <span class="cov8" title="1">cb.bindings = append(cb.bindings, binding{
                target:   unsafe.Pointer(target), // #nosec G103 - intentional unsafe.Pointer usage for zero-reflection binding
                key:      key,
                defValue: defVal,
                kind:     bindBool,
        })

        return cb</span>
}

// BindFloat64 binds a float64 configuration value with optional default
func (cb *ConfigBinder) BindFloat64(target *float64, key string, defaultValue ...float64) *ConfigBinder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov8" title="1">{
                return cb
        }</span>

        <span class="cov8" title="1">defVal := "0.0"
        if len(defaultValue) &gt; 0 </span><span class="cov0" title="0">{
                defVal = strconv.FormatFloat(defaultValue[0], 'f', -1, 64)
        }</span>

        <span class="cov8" title="1">cb.bindings = append(cb.bindings, binding{
                target:   unsafe.Pointer(target), // #nosec G103 - intentional unsafe.Pointer usage for zero-reflection binding
                key:      key,
                defValue: defVal,
                kind:     bindFloat64,
        })

        return cb</span>
}

// BindDuration binds a time.Duration configuration value with optional default
func (cb *ConfigBinder) BindDuration(target *time.Duration, key string, defaultValue ...time.Duration) *ConfigBinder <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov8" title="1">defVal := "0s"
        if len(defaultValue) &gt; 0 </span><span class="cov8" title="1">{
                defVal = defaultValue[0].String()
        }</span>

        <span class="cov8" title="1">cb.bindings = append(cb.bindings, binding{
                target:   unsafe.Pointer(target), // #nosec G103 - intentional unsafe.Pointer usage for zero-reflection binding
                key:      key,
                defValue: defVal,
                kind:     bindDuration,
        })

        return cb</span>
}

// Apply executes all bindings in a single optimized pass
// This is where the magic happens - ultra-fast batch processing
func (cb *ConfigBinder) Apply() error <span class="cov8" title="1">{
        if cb.err != nil </span><span class="cov8" title="1">{
                return cb.err
        }</span>

        // Single loop - maximum performance
        <span class="cov8" title="1">for _, b := range cb.bindings </span><span class="cov8" title="1">{
                if err := cb.applyBinding(b); err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, ErrCodeInvalidConfig, "failed to bind key '"+b.key+"'")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// applyBinding applies a single binding with zero-allocation type switching
func (cb *ConfigBinder) applyBinding(b binding) error <span class="cov8" title="1">{
        // Get value from config with nested key support
        value, exists := cb.getValue(b.key)
        if !exists </span><span class="cov8" title="1">{
                // Use default value
                value = b.defValue
        }</span>

        // Ultra-fast type switching without reflection
        <span class="cov8" title="1">switch b.kind </span>{
        case bindString:<span class="cov8" title="1">
                *(*string)(b.target) = cb.toString(value)</span>
        case bindInt:<span class="cov8" title="1">
                val, err := cb.toInt(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">*(*int)(b.target) = val</span>
        case bindInt64:<span class="cov8" title="1">
                val, err := cb.toInt64(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">*(*int64)(b.target) = val</span>
        case bindBool:<span class="cov8" title="1">
                val, err := cb.toBool(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">*(*bool)(b.target) = val</span>
        case bindFloat64:<span class="cov8" title="1">
                val, err := cb.toFloat64(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">*(*float64)(b.target) = val</span>
        case bindDuration:<span class="cov8" title="1">
                val, err := cb.toDuration(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">*(*time.Duration)(b.target) = val</span>
        default:<span class="cov0" title="0">
                return errors.New(ErrCodeInvalidConfig, fmt.Sprintf("unsupported binding kind: %d", b.kind))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getValue retrieves a value from config with support for nested keys (e.g., "database.host")
func (cb *ConfigBinder) getValue(key string) (interface{}, bool) <span class="cov8" title="1">{
        if !strings.Contains(key, ".") </span><span class="cov8" title="1">{
                // Simple key - direct lookup
                val, exists := cb.config[key]
                return val, exists
        }</span>

        // Nested key - traverse the map
        <span class="cov8" title="1">parts := strings.Split(key, ".")
        current := cb.config

        for i, part := range parts </span><span class="cov8" title="1">{
                val, exists := current[part]
                if !exists </span><span class="cov8" title="1">{
                        return nil, false
                }</span>

                <span class="cov8" title="1">if i == len(parts)-1 </span><span class="cov8" title="1">{
                        // Last part - return the value
                        return val, true
                }</span>

                // Intermediate part - must be a map
                <span class="cov8" title="1">if nestedMap, ok := val.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        current = nestedMap
                }</span> else<span class="cov8" title="1"> {
                        return nil, false
                }</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}

// Type conversion methods with minimal allocations

func (cb *ConfigBinder) toString(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return v</span>
        case []byte:<span class="cov8" title="1">
                return string(v)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", v)</span>
        }
}

func (cb *ConfigBinder) toInt(value interface{}) (int, error) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return v, nil</span>
        case int64:<span class="cov8" title="1">
                return int(v), nil</span>
        case float64:<span class="cov8" title="1">
                return int(v), nil</span>
        case string:<span class="cov8" title="1">
                return strconv.Atoi(v)</span>
        default:<span class="cov8" title="1">
                return 0, errors.New(ErrCodeInvalidConfig, fmt.Sprintf("cannot convert %T to int", value))</span>
        }
}

func (cb *ConfigBinder) toInt64(value interface{}) (int64, error) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int64:<span class="cov8" title="1">
                return v, nil</span>
        case int:<span class="cov8" title="1">
                return int64(v), nil</span>
        case float64:<span class="cov8" title="1">
                return int64(v), nil</span>
        case string:<span class="cov8" title="1">
                return strconv.ParseInt(v, 10, 64)</span>
        default:<span class="cov8" title="1">
                return 0, errors.New(ErrCodeInvalidConfig, fmt.Sprintf("cannot convert %T to int64", value))</span>
        }
}

func (cb *ConfigBinder) toBool(value interface{}) (bool, error) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case bool:<span class="cov8" title="1">
                return v, nil</span>
        case string:<span class="cov8" title="1">
                return strconv.ParseBool(v)</span>
        case int:<span class="cov8" title="1">
                return v != 0, nil</span>
        case int64:<span class="cov8" title="1">
                return v != 0, nil</span>
        case float64:<span class="cov8" title="1">
                return v != 0, nil</span>
        default:<span class="cov0" title="0">
                return false, errors.New(ErrCodeInvalidConfig, fmt.Sprintf("cannot convert %T to bool", value))</span>
        }
}

func (cb *ConfigBinder) toFloat64(value interface{}) (float64, error) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case float64:<span class="cov8" title="1">
                return v, nil</span>
        case float32:<span class="cov8" title="1">
                return float64(v), nil</span>
        case int:<span class="cov8" title="1">
                return float64(v), nil</span>
        case int64:<span class="cov8" title="1">
                return float64(v), nil</span>
        case string:<span class="cov8" title="1">
                return strconv.ParseFloat(v, 64)</span>
        default:<span class="cov8" title="1">
                return 0, errors.New(ErrCodeInvalidConfig, fmt.Sprintf("cannot convert %T to float64", value))</span>
        }
}

func (cb *ConfigBinder) toDuration(value interface{}) (time.Duration, error) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case time.Duration:<span class="cov8" title="1">
                return v, nil</span>
        case string:<span class="cov8" title="1">
                return time.ParseDuration(v)</span>
        case int64:<span class="cov8" title="1">
                return time.Duration(v), nil</span>
        case int:<span class="cov8" title="1">
                return time.Duration(v), nil</span>
        default:<span class="cov8" title="1">
                return 0, errors.New(ErrCodeInvalidConfig, fmt.Sprintf("cannot convert %T to time.Duration", value))</span>
        }
}

// BindFromConfig creates a new ConfigBinder from a parsed configuration map
// This is the main entry point for users
func BindFromConfig(config map[string]interface{}) *ConfigBinder <span class="cov8" title="1">{
        return NewConfigBinder(config)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// config_validation.go - professional-grade configuration validation for Argus
//
// This module provides comprehensive validation for Argus configuration,
// ensuring safe and reliable operation in production environments with
// detailed error reporting and performance optimization recommendations.
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

// Package argus provides comprehensive configuration validation and constraint checking.
// This file implements professional-grade validation rules for configuration parameters.

package argus

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/agilira/go-errors"
)

// Validation errors - implementing error codes pattern from Iris
var (
        ErrInvalidPollInterval    = errors.New(ErrCodeInvalidPollInterval, "poll interval must be positive")
        ErrInvalidCacheTTL        = errors.New(ErrCodeInvalidCacheTTL, "cache TTL must be positive")
        ErrInvalidMaxWatchedFiles = errors.New(ErrCodeInvalidMaxWatchedFiles, "max watched files must be positive")
        ErrInvalidOptimization    = errors.New(ErrCodeInvalidOptimization, "unknown optimization strategy")
        ErrInvalidAuditConfig     = errors.New(ErrCodeInvalidAuditConfig, "audit configuration is invalid")
        ErrInvalidBufferSize      = errors.New(ErrCodeInvalidBufferSize, "buffer size must be positive")
        ErrInvalidFlushInterval   = errors.New(ErrCodeInvalidFlushInterval, "flush interval must be positive")
        ErrInvalidOutputFile      = errors.New(ErrCodeInvalidOutputFile, "audit output file path is invalid")
        ErrUnwritableOutputFile   = errors.New(ErrCodeUnwritableOutputFile, "audit output file is not writable")
        ErrCacheTTLTooLarge       = errors.New(ErrCodeCacheTTLTooLarge, "cache TTL should not exceed poll interval")
        ErrPollIntervalTooSmall   = errors.New(ErrCodePollIntervalTooSmall, "poll interval should be at least 10ms for stability")
        ErrMaxFilesTooLarge       = errors.New(ErrCodeMaxFilesTooLarge, "max watched files exceeds recommended limit (10000)")
        ErrBoreasCapacityInvalid  = errors.New(ErrCodeBoreasCapacityInvalid, "BoreasLite capacity must be power of 2")
)

// ValidationResult contains the result of configuration validation with detailed feedback.
// Provides comprehensive validation information including errors, warnings, and
// performance recommendations for production deployments.
type ValidationResult struct {
        Valid    bool     `json:"valid"`
        Errors   []string `json:"errors,omitempty"`
        Warnings []string `json:"warnings,omitempty"`
}

// String returns a human-readable representation of validation results
func (vr ValidationResult) String() string <span class="cov8" title="1">{
        if vr.Valid </span><span class="cov8" title="1">{
                if len(vr.Warnings) == 0 </span><span class="cov8" title="1">{
                        return "Configuration is valid"
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("Configuration is valid with %d warning(s)", len(vr.Warnings))</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("Configuration is invalid: %d error(s), %d warning(s)",
                len(vr.Errors), len(vr.Warnings))</span>
}

// Validate performs comprehensive validation of the Argus configuration
// Returns error if configuration is invalid, warnings are included in ValidationResult
func (c *Config) Validate() error <span class="cov8" title="1">{
        result := c.ValidateDetailed()
        if !result.Valid </span><span class="cov8" title="1">{
                // Return first error as the primary validation error
                if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                        // Map the error string back to the original error object
                        firstError := result.Errors[0]
                        switch </span>{
                        case firstError == ErrInvalidPollInterval.Error():<span class="cov8" title="1">
                                return ErrInvalidPollInterval</span>
                        case firstError == ErrPollIntervalTooSmall.Error():<span class="cov8" title="1">
                                return ErrPollIntervalTooSmall</span>
                        case firstError == ErrInvalidCacheTTL.Error():<span class="cov0" title="0">
                                return ErrInvalidCacheTTL</span>
                        case firstError == ErrInvalidMaxWatchedFiles.Error():<span class="cov0" title="0">
                                return ErrInvalidMaxWatchedFiles</span>
                        case firstError == ErrInvalidOptimization.Error():<span class="cov0" title="0">
                                return ErrInvalidOptimization</span>
                        case firstError == ErrBoreasCapacityInvalid.Error():<span class="cov0" title="0">
                                return ErrBoreasCapacityInvalid</span>
                        case firstError == ErrInvalidBufferSize.Error():<span class="cov0" title="0">
                                return ErrInvalidBufferSize</span>
                        case firstError == ErrInvalidFlushInterval.Error():<span class="cov0" title="0">
                                return ErrInvalidFlushInterval</span>
                        case firstError == ErrInvalidOutputFile.Error():<span class="cov8" title="1">
                                return ErrInvalidOutputFile</span>
                        case firstError == ErrUnwritableOutputFile.Error():<span class="cov0" title="0">
                                return ErrUnwritableOutputFile</span>
                        default:<span class="cov0" title="0">
                                // Fallback to generic error
                                return errors.New(ErrCodeInvalidConfig, firstError)</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateDetailed performs comprehensive validation and returns detailed results
// including both errors and warnings for better debugging and monitoring
func (c *Config) ValidateDetailed() ValidationResult <span class="cov8" title="1">{
        result := ValidationResult{
                Valid:    true,
                Errors:   make([]string, 0),
                Warnings: make([]string, 0),
        }

        // Core configuration validation
        c.validateCoreConfig(&amp;result)

        // Optimization strategy validation
        c.validateOptimizationStrategy(&amp;result)

        // BoreasLite capacity validation
        c.validateBoreasCapacity(&amp;result)

        // Audit configuration validation
        c.validateAuditConfig(&amp;result)

        // Performance and operational warnings
        c.validatePerformanceConstraints(&amp;result)

        // Set overall validity
        result.Valid = len(result.Errors) == 0

        return result
}</span>

// validateCoreConfig validates essential configuration parameters
func (c *Config) validateCoreConfig(result *ValidationResult) <span class="cov8" title="1">{
        // Poll interval validation
        pollIntervalValid := true
        if c.PollInterval &lt;= 0 </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ErrInvalidPollInterval.Error())
                pollIntervalValid = false
        }</span> else<span class="cov8" title="1"> if c.PollInterval &lt; 10*time.Millisecond </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ErrPollIntervalTooSmall.Error())
                pollIntervalValid = false
        }</span>

        // Cache TTL validation
        <span class="cov8" title="1">if c.CacheTTL &lt; 0 </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ErrInvalidCacheTTL.Error())
        }</span> else<span class="cov8" title="1"> if pollIntervalValid &amp;&amp; c.CacheTTL &gt; c.PollInterval </span><span class="cov8" title="1">{
                // Only check this if PollInterval is valid
                result.Warnings = append(result.Warnings, ErrCacheTTLTooLarge.Error())
        }</span>

        // Max watched files validation
        <span class="cov8" title="1">if c.MaxWatchedFiles &lt;= 0 </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ErrInvalidMaxWatchedFiles.Error())
        }</span> else<span class="cov8" title="1"> if c.MaxWatchedFiles &gt; 10000 </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ErrMaxFilesTooLarge.Error())
        }</span>
}

// validateOptimizationStrategy validates the optimization strategy setting
func (c *Config) validateOptimizationStrategy(result *ValidationResult) <span class="cov8" title="1">{
        switch c.OptimizationStrategy </span>{
        case OptimizationSingleEvent, OptimizationSmallBatch, OptimizationLargeBatch, OptimizationAuto:<span class="cov8" title="1"></span>
                // Valid strategies (including OptimizationAuto which is 0)
        default:<span class="cov8" title="1">
                result.Errors = append(result.Errors,
                        fmt.Sprintf("%s: '%v'", ErrInvalidOptimization.Error(), c.OptimizationStrategy))</span>
        }
}

// validateBoreasCapacity validates BoreasLite capacity settings
func (c *Config) validateBoreasCapacity(result *ValidationResult) <span class="cov8" title="1">{
        if c.BoreasLiteCapacity &gt; 0 </span><span class="cov8" title="1">{
                // Check if capacity is power of 2
                if c.BoreasLiteCapacity&amp;(c.BoreasLiteCapacity-1) != 0 </span><span class="cov8" title="1">{
                        result.Errors = append(result.Errors, ErrBoreasCapacityInvalid.Error())
                }</span>

                // Warn about very large capacities
                <span class="cov8" title="1">if c.BoreasLiteCapacity &gt; 1024 </span><span class="cov8" title="1">{
                        result.Warnings = append(result.Warnings,
                                "Large BoreasLite capacity may consume significant memory")
                }</span>
        }
}

// validateAuditConfig validates audit configuration if enabled
func (c *Config) validateAuditConfig(result *ValidationResult) <span class="cov8" title="1">{
        if !c.Audit.Enabled </span><span class="cov8" title="1">{
                return // Skip audit validation if disabled
        }</span>

        <span class="cov8" title="1">c.validateAuditBufferSize(result)
        c.validateAuditFlushInterval(result)
        c.validateAuditOutputFile(result)</span>
}

// validateAuditBufferSize validates audit buffer size configuration
func (c *Config) validateAuditBufferSize(result *ValidationResult) <span class="cov8" title="1">{
        if c.Audit.BufferSize &lt; 0 </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ErrInvalidBufferSize.Error())
        }</span> else<span class="cov8" title="1"> if c.Audit.BufferSize == 0 </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings, "Audit buffer size is 0, consider setting to 100-1000 for better performance")
        }</span> else<span class="cov8" title="1"> if c.Audit.BufferSize &gt; 10000 </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings, "Large audit buffer size may consume significant memory")
        }</span>
}

// validateAuditFlushInterval validates audit flush interval configuration
func (c *Config) validateAuditFlushInterval(result *ValidationResult) <span class="cov8" title="1">{
        if c.Audit.FlushInterval &lt; 0 </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ErrInvalidFlushInterval.Error())
        }</span> else<span class="cov8" title="1"> if c.Audit.FlushInterval == 0 </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings, "Audit flush interval is 0, events will be written immediately (may impact performance)")
        }</span>
}

// validateAuditOutputFile validates audit output file configuration
func (c *Config) validateAuditOutputFile(result *ValidationResult) <span class="cov8" title="1">{
        if c.Audit.OutputFile == "" </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, ErrInvalidOutputFile.Error())
                return
        }</span>

        // Validate output file path and writeability
        <span class="cov8" title="1">if err := c.validateOutputFile(c.Audit.OutputFile); err != nil </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, err.Error())
        }</span>
}

// validateOutputFile checks if the audit output file path is valid and writable
func (c *Config) validateOutputFile(outputFile string) error <span class="cov8" title="1">{
        // Clean and validate the path
        cleanPath := filepath.Clean(outputFile)
        if cleanPath == "." || cleanPath == "/" </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig,
                        fmt.Sprintf("path '%s' is not a valid file path", outputFile))
        }</span>

        // Check if directory exists and is writable
        <span class="cov8" title="1">dir := filepath.Dir(cleanPath)
        if dir != "" </span><span class="cov8" title="1">{
                if info, err := os.Stat(dir); err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                return errors.New(ErrCodeInvalidConfig,
                                        fmt.Sprintf("directory '%s' does not exist", dir))
                        }</span>
                        <span class="cov0" title="0">return errors.Wrap(err, ErrCodeInvalidConfig,
                                fmt.Sprintf("cannot access directory '%s'", dir))</span>
                } else<span class="cov8" title="1"> if !info.IsDir() </span><span class="cov0" title="0">{
                        return errors.New(ErrCodeInvalidConfig,
                                fmt.Sprintf("'%s' is not a directory", dir))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validatePerformanceConstraints adds performance-related warnings
func (c *Config) validatePerformanceConstraints(result *ValidationResult) <span class="cov8" title="1">{
        // Warn about performance implications
        if c.PollInterval &lt; 100*time.Millisecond &amp;&amp; c.MaxWatchedFiles &gt; 100 </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings,
                        "Fast polling with many files may impact CPU usage")
        }</span>

        <span class="cov8" title="1">if c.Audit.Enabled &amp;&amp; c.Audit.FlushInterval &lt; time.Second &amp;&amp; c.MaxWatchedFiles &gt; 50 </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings,
                        "Frequent audit flushing with many files may impact I/O performance")
        }</span>

        // Recommend optimization strategy based on configuration
        <span class="cov8" title="1">if c.MaxWatchedFiles &gt; 10 &amp;&amp; c.OptimizationStrategy == OptimizationSingleEvent </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings,
                        "Consider using 'smallbatch' or 'auto' optimization for multiple files")
        }</span>

        <span class="cov8" title="1">if c.MaxWatchedFiles &gt; 100 &amp;&amp; c.OptimizationStrategy != OptimizationLargeBatch &amp;&amp; c.OptimizationStrategy != OptimizationAuto </span><span class="cov8" title="1">{
                result.Warnings = append(result.Warnings,
                        "Consider using 'largebatch' or 'auto' optimization for many files")
        }</span>

        // Memory usage warnings
        <span class="cov8" title="1">totalMemoryEst := (c.MaxWatchedFiles * 256) + int(c.BoreasLiteCapacity*64) + c.Audit.BufferSize*512
        if totalMemoryEst &gt; 50*1024*1024 </span><span class="cov0" title="0">{ // 50MB
                result.Warnings = append(result.Warnings,
                        fmt.Sprintf("Configuration may use ~%dMB memory, consider reducing limits", totalMemoryEst/(1024*1024)))
        }</span>
}

// ValidateEnvironmentConfig validates environment-loaded configuration
// This is a convenience method for validating configs loaded from environment variables
func ValidateEnvironmentConfig() error <span class="cov8" title="1">{
        config, err := LoadConfigFromEnv()
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, ErrCodeInvalidConfig, "failed to load config from environment")
        }</span>

        <span class="cov8" title="1">return config.Validate()</span>
}

// loadConfigFromJSON loads and parses a JSON configuration file with cross-platform path handling
func loadConfigFromJSON(configPath string) (*Config, error) <span class="cov8" title="1">{
        // Read the file content
        data, err := os.ReadFile(configPath) // #nosec G304 - configPath is validated by caller, intentional config file loading
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, ErrCodeFileNotFound, "failed to read config file '"+configPath+"'")
        }</span>

        // Handle cross-platform JSON parsing - normalize Windows path separators
        <span class="cov8" title="1">jsonStr := string(data)

        // On Windows, JSON paths with backslashes need to be properly escaped
        // We normalize by ensuring all backslashes are properly escaped for JSON
        if strings.Contains(jsonStr, "\\") &amp;&amp; !strings.Contains(jsonStr, "\\\\") </span><span class="cov0" title="0">{
                // This is a heuristic - if we see single backslashes but no double backslashes,
                // we likely have Windows paths that need escaping
                jsonStr = strings.ReplaceAll(jsonStr, "\\", "\\\\")
        }</span>

        // Load base config with defaults first
        <span class="cov8" title="1">config := (&amp;Config{}).WithDefaults()

        // Parse JSON into the config
        if err := json.Unmarshal([]byte(jsonStr), config); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "failed to parse JSON config")
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// ValidateConfigFile validates a configuration that would be loaded from a file
// This method performs validation without actually starting file watching
func ValidateConfigFile(configPath string) error <span class="cov8" title="1">{
        if configPath == "" </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "configuration file path cannot be empty")
        }</span>

        // Check if file exists and is readable
        <span class="cov8" title="1">if _, err := os.Stat(configPath); err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return errors.New(ErrCodeConfigNotFound, "configuration file '"+configPath+"' not found")
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, ErrCodeConfigNotFound, "cannot access configuration file '"+configPath+"'")</span>
        }

        // Load and parse the actual config file
        <span class="cov8" title="1">config, err := loadConfigFromJSON(configPath)
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, ErrCodeInvalidConfig, "config parse error")
        }</span>

        // Validate the loaded configuration
        <span class="cov8" title="1">return config.Validate()</span>
}

// GetValidationErrorCode extracts the error code from an Argus validation error
func GetValidationErrorCode(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">errStr := err.Error()

        // Handle go-errors format: [CODE]: Message
        if len(errStr) &gt; 3 &amp;&amp; errStr[0] == '[' </span><span class="cov8" title="1">{
                for idx := 1; idx &lt; len(errStr); idx++ </span><span class="cov8" title="1">{
                        if errStr[idx] == ']' </span><span class="cov8" title="1">{
                                return errStr[1:idx]
                        }</span>
                }
        }

        // Fallback for old format: CODE: Message
        <span class="cov8" title="1">for idx := 0; idx &lt; len(errStr); idx++ </span><span class="cov8" title="1">{
                if errStr[idx] == ':' </span><span class="cov0" title="0">{
                        return errStr[:idx]
                }</span>
        }

        <span class="cov8" title="1">return errStr</span>
}

// IsValidationError checks if an error is an Argus validation error
func IsValidationError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errorStr := err.Error()

        // Handle go-errors format: [ARGUS_*]: Message
        if len(errorStr) &gt; 8 &amp;&amp; errorStr[0] == '[' &amp;&amp; errorStr[1:7] == "ARGUS_" </span><span class="cov8" title="1">{
                return true
        }</span>

        // Fallback for old format: ARGUS_*: Message
        <span class="cov8" title="1">return len(errorStr) &gt; 6 &amp;&amp; errorStr[:6] == "ARGUS_"</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// config_writer.go: Configuration Writing System for Argus
//
// This file implements zero-allocation configuration writing with atomic operations,
// format preservation, and comprehensive audit integration.
//
// Philosophy:
// - Zero allocations in hot paths through pre-allocated buffers
// - Atomic operations to prevent corruption during concurrent access
// - Format preservation maintains original structure and style
// - Comprehensive audit trail for all modifications
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "encoding/json"
        "fmt"
        "hash"
        "hash/fnv"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/agilira/go-errors"
)

// ConfigWriter provides zero-allocation configuration writing capabilities.
// It maintains the original format and structure while enabling programmatic
// modifications with full audit integration.
//
// Performance characteristics:
//   - SetValue: 127 ns/op (0 allocs) for simple keys
//   - WriteConfig: File I/O bound, ~2-5ms typical
//   - Memory usage: Fixed 8KB + config size
//
// Thread safety: Safe for concurrent reads, serialized writes
type ConfigWriter struct {
        // Core configuration
        filePath string
        format   ConfigFormat

        // Pre-allocated buffers for zero-allocation operations
        keyBuffer   []string // Reused for dot-notation parsing
        valueBuffer []byte   // Reused for serialization
        tempBuffer  []byte   // Reused for file operations

        // Current state - copy-on-write semantics
        config       map[string]interface{}
        originalHash uint64 // Fast dirty detection

        // Optional audit integration
        auditLogger *AuditLogger // Optional - can be nil for performance

        // Thread safety
        mu      sync.RWMutex
        writing bool // Prevents concurrent writes
}

// ConfigFormat is already defined in parsers.go - we reuse it here

// newConfigWriter creates a new ConfigWriter instance with pre-allocated buffers.
// Internal constructor - not exposed to prevent misuse.
//
// Performance: 89 ns/op, 1 alloc (for the struct itself)
// NewConfigWriter creates a new zero-allocation configuration writer.
// The buffer sizes are optimized for typical configuration files.
//
// Performance: Zero allocations in hot paths, ~500 ns/op for typical operations
func NewConfigWriter(filePath string, format ConfigFormat, initialConfig map[string]interface{}) (*ConfigWriter, error) <span class="cov8" title="1">{
        return NewConfigWriterWithAudit(filePath, format, initialConfig, nil)
}</span>

// NewConfigWriterWithAudit creates a new configuration writer with optional audit logging.
// Provides the same performance characteristics as NewConfigWriter with optional audit integration.
//
// Parameters:
//   - filePath: Path to the configuration file
//   - format: Configuration format (JSON, YAML, TOML, etc.)
//   - initialConfig: Initial configuration data (can be nil)
//   - auditLogger: Optional audit logger for compliance (can be nil for performance)
//
// Performance: Zero allocations in hot paths, ~500 ns/op when audit is disabled
//
//        ~750 ns/op when audit is enabled (minimal overhead)
func NewConfigWriterWithAudit(filePath string, format ConfigFormat, initialConfig map[string]interface{}, auditLogger *AuditLogger) (*ConfigWriter, error) <span class="cov8" title="1">{
        if filePath == "" </span><span class="cov8" title="1">{
                return nil, errors.New(ErrCodeConfigWriterError, "filePath cannot be empty")
        }</span>

        <span class="cov8" title="1">writer := &amp;ConfigWriter{
                filePath:    filePath,
                format:      format,
                keyBuffer:   make([]string, 0, 8),  // Pre-allocate for deep nesting
                valueBuffer: make([]byte, 0, 1024), // 1KB buffer for serialization
                tempBuffer:  make([]byte, 0, 2048), // 2KB buffer for temp operations
                auditLogger: auditLogger,           // Optional audit integration
        }

        // Initialize with provided configuration
        if initialConfig != nil </span><span class="cov8" title="1">{
                writer.config = deepCopy(initialConfig)
                writer.originalHash = hashConfig(writer.config)
        }</span> else<span class="cov8" title="1"> {
                writer.config = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">return writer, nil</span>
}

// SetValue sets a configuration value using dot notation.
// Supports nested keys like "database.connection.host".
//
// Performance: 127 ns/op, 0 allocs for simple keys
//
//        295 ns/op, 1 alloc for nested keys (map creation)
//
// Examples:
//
//        writer.SetValue("port", 8080)                    // Simple key
//        writer.SetValue("database.host", "localhost")    // Nested key
//        writer.SetValue("features.auth.enabled", true)   // Deep nesting
func (w *ConfigWriter) SetValue(key string, value interface{}) error <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "key cannot be empty")
        }</span>

        <span class="cov8" title="1">w.mu.Lock()
        defer w.mu.Unlock()

        if w.writing </span><span class="cov0" title="0">{
                return errors.New(ErrCodeWatcherBusy, "writer is currently performing atomic write")
        }</span>

        // Parse dot notation using pre-allocated buffer
        <span class="cov8" title="1">w.keyBuffer = w.keyBuffer[:0] // Reset without allocation
        w.keyBuffer = parseDotNotation(key, w.keyBuffer)

        // Take a snapshot before modification for audit purposes
        var oldConfig map[string]interface{}
        if w.auditLogger != nil </span><span class="cov0" title="0">{
                oldConfig = deepCopy(w.config)
        }</span>

        // Apply change to config copy
        <span class="cov8" title="1">if err := w.setNestedValue(w.config, w.keyBuffer, value); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, ErrCodeInvalidConfig, "failed to set nested value")
        }</span>

        // Audit logging for configuration changes (optional, zero overhead when disabled)
        <span class="cov8" title="1">if w.auditLogger != nil </span><span class="cov0" title="0">{
                w.auditLogger.LogConfigChange(w.filePath, oldConfig, w.config)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WriteConfig atomically writes the current configuration to disk.
// Uses temporary file + rename for atomic operation to prevent corruption.
//
// Performance: I/O bound, typically 2-5ms
//
//        Memory: 0 additional allocations for serialization
//
// Atomicity guarantee: Either succeeds completely or leaves original unchanged
func (w *ConfigWriter) WriteConfig() error <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if w.writing </span><span class="cov0" title="0">{
                return errors.New(ErrCodeConfigWriterError, "concurrent write operation in progress")
        }</span>

        <span class="cov8" title="1">w.writing = true
        defer func() </span><span class="cov8" title="1">{ w.writing = false }</span>()

        // Check if changes exist (fast hash comparison)
        <span class="cov8" title="1">currentHash := hashConfig(w.config)
        if currentHash == w.originalHash </span><span class="cov0" title="0">{
                return nil // No changes to write
        }</span>

        // Serialize using pre-allocated buffer
        <span class="cov8" title="1">w.valueBuffer = w.valueBuffer[:0] // Reset without allocation
        serialized, err := w.serializeConfig(w.config, w.valueBuffer)
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, ErrCodeSerializationError, "serialization failed")
        }</span>

        // Atomic write operation
        <span class="cov8" title="1">if err := w.atomicWrite(serialized); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, ErrCodeIOError, "atomic write failed")
        }</span>

        // Update hash after successful write
        <span class="cov8" title="1">w.originalHash = currentHash

        // Audit logging for file write operations (optional)
        if w.auditLogger != nil </span><span class="cov0" title="0">{
                w.auditLogger.LogFileWatch("config_written", w.filePath)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WriteConfigAs writes the configuration to a different file path.
// Useful for backups or exporting to different locations.
//
// The original file path and watcher remain unchanged.
func (w *ConfigWriter) WriteConfigAs(filePath string) error <span class="cov0" title="0">{
        if filePath == "" </span><span class="cov0" title="0">{
                return errors.New(ErrCodeConfigWriterError, "filePath cannot be empty")
        }</span>

        <span class="cov0" title="0">w.mu.RLock()
        defer w.mu.RUnlock()

        // Serialize current config
        w.valueBuffer = w.valueBuffer[:0]
        serialized, err := w.serializeConfig(w.config, w.valueBuffer)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, ErrCodeSerializationError, "serialization failed")
        }</span>

        // Write to target file atomically
        <span class="cov0" title="0">tempPath := filePath + ".tmp." + fmt.Sprintf("%d", time.Now().UnixNano())

        if err := os.WriteFile(tempPath, serialized, 0600); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, ErrCodeIOError, fmt.Sprintf("failed to write temp file: %v", err))
        }</span>

        <span class="cov0" title="0">if err := os.Rename(tempPath, filePath); err != nil </span><span class="cov0" title="0">{
                if removeErr := os.Remove(tempPath); removeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to cleanup temp file %s: %v\n", tempPath, removeErr)
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, ErrCodeIOError, fmt.Sprintf("failed to rename temp file: %v", err))</span>
        }

        // Audit logging for file export operations (optional)
        <span class="cov0" title="0">if w.auditLogger != nil </span><span class="cov0" title="0">{
                w.auditLogger.LogFileWatch("config_exported", filePath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetValue retrieves a configuration value using dot notation.
// Returns nil if the key doesn't exist.
//
// Performance: 89 ns/op, 0 allocs for simple lookups
func (w *ConfigWriter) GetValue(key string) interface{} <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">w.mu.RLock()
        defer w.mu.RUnlock()

        w.keyBuffer = w.keyBuffer[:0]
        w.keyBuffer = parseDotNotation(key, w.keyBuffer)

        return w.getNestedValue(w.config, w.keyBuffer)</span>
}

// HasChanges returns true if the configuration has unsaved changes.
// Uses fast hash comparison for O(1) performance.
func (w *ConfigWriter) HasChanges() bool <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        return hashConfig(w.config) != w.originalHash
}</span>

// GetConfig returns a deep copy of the current configuration.
// This enables CLI operations like list and convert without exposing internal state.
//
// Performance: O(n) where n is config size, allocates new map
func (w *ConfigWriter) GetConfig() map[string]interface{} <span class="cov0" title="0">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        return deepCopy(w.config)
}</span>

// DeleteValue removes a configuration key using dot notation.
// Returns true if the key existed and was deleted, false otherwise.
//
// Performance: 156 ns/op, 0 allocs for simple keys
//
// Examples:
//
//        writer.DeleteValue("port")                    // Delete simple key
//        writer.DeleteValue("database.host")          // Delete nested key
//        writer.DeleteValue("features.auth.enabled")  // Delete deep nested key
func (w *ConfigWriter) DeleteValue(key string) bool <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">w.mu.Lock()
        defer w.mu.Unlock()

        if w.writing </span><span class="cov0" title="0">{
                return false // Cannot delete during write operation
        }</span>

        // Take a snapshot before modification for audit purposes
        <span class="cov8" title="1">var oldConfig map[string]interface{}
        if w.auditLogger != nil </span><span class="cov0" title="0">{
                oldConfig = deepCopy(w.config)
        }</span>

        // Parse dot notation using pre-allocated buffer
        <span class="cov8" title="1">w.keyBuffer = w.keyBuffer[:0]
        w.keyBuffer = parseDotNotation(key, w.keyBuffer)

        // Delete from config
        deleted := w.deleteNestedValue(w.config, w.keyBuffer)

        // Audit logging for configuration changes (optional)
        if deleted &amp;&amp; w.auditLogger != nil </span><span class="cov0" title="0">{
                w.auditLogger.LogConfigChange(w.filePath, oldConfig, w.config)
        }</span>

        <span class="cov8" title="1">return deleted</span>
}

// ListKeys returns all configuration keys in dot notation format.
// Optionally filters by prefix for hierarchical listing.
//
// Performance: O(n) where n is total number of keys
func (w *ConfigWriter) ListKeys(prefix string) []string <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        var keys []string
        w.collectKeys(w.config, "", prefix, &amp;keys)
        return keys
}</span>

// Reset discards all changes and reverts to the last saved state.
// Loads the configuration from the original file to restore its state.
// Useful for canceling operations or handling errors.
//
// Performance: I/O bound, reads and parses original file
func (w *ConfigWriter) Reset() error <span class="cov0" title="0">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if w.writing </span><span class="cov0" title="0">{
                return errors.New(ErrCodeWatcherBusy, "cannot reset during write operation")
        }</span>

        // Take a snapshot before reset for audit purposes
        <span class="cov0" title="0">var oldConfig map[string]interface{}
        if w.auditLogger != nil </span><span class="cov0" title="0">{
                oldConfig = deepCopy(w.config)
        }</span>

        // Try to reload from original file
        <span class="cov0" title="0">if err := w.reloadFromFile(); err != nil </span><span class="cov0" title="0">{
                // If file doesn't exist or can't be read, reset to empty config
                w.config = make(map[string]interface{})
                w.originalHash = hashConfig(w.config)

                // Audit the reset operation (optional)
                if w.auditLogger != nil </span><span class="cov0" title="0">{
                        w.auditLogger.LogConfigChange(w.filePath, oldConfig, w.config)
                }</span>

                <span class="cov0" title="0">return errors.Wrap(err, ErrCodeIOError, "failed to reload from file, reset to empty config")</span>
        }

        // Audit the successful reset operation (optional)
        <span class="cov0" title="0">if w.auditLogger != nil </span><span class="cov0" title="0">{
                w.auditLogger.LogConfigChange(w.filePath, oldConfig, w.config)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// reloadFromFile loads the configuration from the original file.
// Internal method that handles file reading, parsing, and state update.
func (w *ConfigWriter) reloadFromFile() error <span class="cov0" title="0">{
        // Check if file exists
        if _, err := os.Stat(w.filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                // File doesn't exist, reset to empty config
                w.config = make(map[string]interface{})
                w.originalHash = hashConfig(w.config)
                return nil
        }</span>

        // Read file content
        <span class="cov0" title="0">data, err := os.ReadFile(w.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Parse configuration using the same format
        <span class="cov0" title="0">config, err := ParseConfig(data, w.format)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse configuration: %w", err)
        }</span>

        // Update internal state
        <span class="cov0" title="0">w.config = config
        w.originalHash = hashConfig(w.config)

        return nil</span>
}

// parseDotNotation splits a dot-notation key into components.
// Reuses provided buffer to avoid allocations.
//
// Performance: 45 ns/op, 0 allocs when buffer has sufficient capacity
func parseDotNotation(key string, buffer []string) []string <span class="cov8" title="1">{
        if !strings.Contains(key, ".") </span><span class="cov8" title="1">{
                // Simple key - no splitting needed
                return append(buffer, key)
        }</span>

        // Split by dots, reusing buffer
        <span class="cov8" title="1">parts := strings.Split(key, ".")
        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                if part != "" </span><span class="cov8" title="1">{
                        buffer = append(buffer, part)
                }</span>
        }

        <span class="cov8" title="1">return buffer</span>
}

// setNestedValue sets a value in nested map structure using key path.
// Creates intermediate maps as needed.
//
// Complexity: O(depth), typically 2-4 levels
func (w *ConfigWriter) setNestedValue(config map[string]interface{}, keyPath []string, value interface{}) error <span class="cov8" title="1">{
        if len(keyPath) == 0 </span><span class="cov0" title="0">{
                return errors.New(ErrCodeConfigWriterError, "empty key path")
        }</span>

        <span class="cov8" title="1">current := config

        // Navigate to parent of target key
        for i := 0; i &lt; len(keyPath)-1; i++ </span><span class="cov8" title="1">{
                key := keyPath[i]

                next, exists := current[key]
                if !exists </span><span class="cov8" title="1">{
                        // Create intermediate map
                        next = make(map[string]interface{})
                        current[key] = next
                }</span>

                // Type assertion for nested maps
                <span class="cov8" title="1">nextMap, ok := next.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.New(ErrCodeConfigWriterError,
                                fmt.Sprintf("key '%s' is not a map, cannot set nested value", key))
                }</span>

                <span class="cov8" title="1">current = nextMap</span>
        }

        // Set final value
        <span class="cov8" title="1">finalKey := keyPath[len(keyPath)-1]
        current[finalKey] = value

        return nil</span>
}

// getNestedValue retrieves a value from nested map structure.
// Returns nil if path doesn't exist.
//
// Performance: 67 ns/op, 0 allocs
func (w *ConfigWriter) getNestedValue(config map[string]interface{}, keyPath []string) interface{} <span class="cov8" title="1">{
        current := config

        for _, key := range keyPath </span><span class="cov8" title="1">{
                value, exists := current[key]
                if !exists </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // If this is the final key, return the value
                <span class="cov8" title="1">if key == keyPath[len(keyPath)-1] </span><span class="cov8" title="1">{
                        return value
                }</span>

                // Continue navigation
                <span class="cov8" title="1">nextMap, ok := value.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">current = nextMap</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// deleteNestedValue deletes a key from nested map structure using key path.
// Returns true if the key existed and was deleted, false otherwise.
//
// Performance: O(depth), typically 2-4 levels
func (w *ConfigWriter) deleteNestedValue(config map[string]interface{}, keyPath []string) bool <span class="cov8" title="1">{
        if len(keyPath) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Special case: single key
        <span class="cov8" title="1">if len(keyPath) == 1 </span><span class="cov0" title="0">{
                key := keyPath[0]
                if _, exists := config[key]; exists </span><span class="cov0" title="0">{
                        delete(config, key)
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov8" title="1">current := config

        // Navigate to parent of target key
        for i := 0; i &lt; len(keyPath)-1; i++ </span><span class="cov8" title="1">{
                key := keyPath[i]

                next, exists := current[key]
                if !exists </span><span class="cov8" title="1">{
                        return false // Path doesn't exist
                }</span>

                // Type assertion for nested maps
                <span class="cov8" title="1">nextMap, ok := next.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return false // Cannot traverse non-map
                }</span>

                <span class="cov8" title="1">current = nextMap</span>
        }

        // Delete final key
        <span class="cov8" title="1">finalKey := keyPath[len(keyPath)-1]
        if _, exists := current[finalKey]; exists </span><span class="cov8" title="1">{
                delete(current, finalKey)
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// collectKeys recursively collects all keys in dot notation format.
// Filters by prefix if provided.
func (w *ConfigWriter) collectKeys(config map[string]interface{}, currentPrefix, filterPrefix string, keys *[]string) <span class="cov8" title="1">{
        for key, value := range config </span><span class="cov8" title="1">{
                fullKey := key
                if currentPrefix != "" </span><span class="cov8" title="1">{
                        fullKey = currentPrefix + "." + key
                }</span>

                // Apply prefix filter
                <span class="cov8" title="1">if filterPrefix != "" &amp;&amp; !strings.HasPrefix(fullKey, filterPrefix) </span><span class="cov8" title="1">{
                        // Skip if this key doesn't match, but continue for nested structures
                        if nestedMap, ok := value.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                // Check if any nested key could match the prefix
                                if strings.HasPrefix(filterPrefix, fullKey+".") </span><span class="cov0" title="0">{
                                        w.collectKeys(nestedMap, fullKey, filterPrefix, keys)
                                }</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if nestedMap, ok := value.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        // Recursively collect nested keys
                        w.collectKeys(nestedMap, fullKey, filterPrefix, keys)
                }</span> else<span class="cov8" title="1"> {
                        // Add leaf key
                        *keys = append(*keys, fullKey)
                }</span>
        }
}

// atomicWrite performs atomic file write using temporary file + rename.
// This prevents corruption if the process is interrupted during writing.
func (w *ConfigWriter) atomicWrite(data []byte) error <span class="cov8" title="1">{
        dir := filepath.Dir(w.filePath)
        base := filepath.Base(w.filePath)

        // Create temporary file in same directory (ensures same filesystem)
        tempPath := filepath.Join(dir, "."+base+".tmp."+fmt.Sprintf("%d", time.Now().UnixNano()))

        // Write to temporary file
        if err := os.WriteFile(tempPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write temp file: %w", err)
        }</span>

        // Atomic rename
        <span class="cov8" title="1">if err := os.Rename(tempPath, w.filePath); err != nil </span><span class="cov0" title="0">{
                if removeErr := os.Remove(tempPath); removeErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Failed to cleanup temp file %s: %v\n", tempPath, removeErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to rename temp file: %w", err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// serializeConfig converts the configuration map to the original format.
// Uses pre-allocated buffer to minimize allocations.
func (w *ConfigWriter) serializeConfig(config map[string]interface{}, buffer []byte) ([]byte, error) <span class="cov8" title="1">{
        switch w.format </span>{
        case FormatJSON:<span class="cov8" title="1">
                return serializeJSON(config, buffer)</span>
        case FormatYAML:<span class="cov8" title="1">
                return serializeYAML(config, buffer)</span>
        case FormatTOML:<span class="cov8" title="1">
                return serializeTOML(config, buffer)</span>
        case FormatHCL:<span class="cov8" title="1">
                return serializeHCL(config, buffer)</span>
        case FormatINI:<span class="cov8" title="1">
                return serializeINI(config, buffer)</span>
        case FormatProperties:<span class="cov8" title="1">
                return serializeProperties(config, buffer)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported format: %v", w.format)</span>
        }
}

// Helper functions for zero-allocation operations

// deepCopy creates a deep copy of the configuration map.
// Uses pre-allocated buffers where possible.
func deepCopy(src map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if src == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">dst := make(map[string]interface{}, len(src))
        for k, v := range src </span><span class="cov8" title="1">{
                switch val := v.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        dst[k] = deepCopy(val)</span>
                case []interface{}:<span class="cov0" title="0">
                        dst[k] = deepCopySlice(val)</span>
                default:<span class="cov8" title="1">
                        dst[k] = val</span>
                }
        }
        <span class="cov8" title="1">return dst</span>
}

// deepCopySlice creates a deep copy of a slice.
func deepCopySlice(src []interface{}) []interface{} <span class="cov0" title="0">{
        if src == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">dst := make([]interface{}, len(src))
        for i, v := range src </span><span class="cov0" title="0">{
                switch val := v.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        dst[i] = deepCopy(val)</span>
                case []interface{}:<span class="cov0" title="0">
                        dst[i] = deepCopySlice(val)</span>
                default:<span class="cov0" title="0">
                        dst[i] = val</span>
                }
        }
        <span class="cov0" title="0">return dst</span>
}

// hashConfig computes a fast hash of the configuration for change detection.
// Uses FNV-1a for speed and good distribution.
//
// Performance: ~200 ns/op for typical configs
func hashConfig(config map[string]interface{}) uint64 <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">h := fnv.New64a()
        hashValue(h, config)
        return h.Sum64()</span>
}

// hashValue recursively hashes a configuration value.
func hashValue(h hash.Hash64, v interface{}) <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case nil:<span class="cov0" title="0">
                _, _ = h.Write([]byte("nil"))</span> // #nosec G104 -- hash.Write never fails
        case bool:<span class="cov8" title="1">
                if val </span><span class="cov8" title="1">{
                        _, _ = h.Write([]byte("true")) // #nosec G104 -- hash.Write never fails
                }</span> else<span class="cov0" title="0"> {
                        _, _ = h.Write([]byte("false")) // #nosec G104 -- hash.Write never fails
                }</span>
        case int:<span class="cov8" title="1">
                _, _ = h.Write([]byte(fmt.Sprintf("%d", val)))</span> // #nosec G104 -- hash.Write never fails
        case int64:<span class="cov0" title="0">
                _, _ = h.Write([]byte(fmt.Sprintf("%d", val)))</span> // #nosec G104 -- hash.Write never fails
        case float64:<span class="cov8" title="1">
                _, _ = h.Write([]byte(fmt.Sprintf("%f", val)))</span> // #nosec G104 -- hash.Write never fails
        case string:<span class="cov8" title="1">
                _, _ = h.Write([]byte(val))</span> // #nosec G104 -- hash.Write never fails
        case map[string]interface{}:<span class="cov8" title="1">
                // Sort keys for consistent hashing
                keys := make([]string, 0, len(val))
                for k := range val </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>

                <span class="cov8" title="1">for _, k := range keys </span><span class="cov8" title="1">{
                        _, _ = h.Write([]byte(k)) // #nosec G104 -- hash.Write never fails
                        hashValue(h, val[k])
                }</span>
        case []interface{}:<span class="cov0" title="0">
                for _, item := range val </span><span class="cov0" title="0">{
                        hashValue(h, item)
                }</span>
        default:<span class="cov0" title="0">
                _, _ = h.Write([]byte(fmt.Sprintf("%v", val)))</span> // #nosec G104 -- hash.Write never fails
        }
}

// serializeJSON converts configuration to JSON format with proper indentation.
// Reuses the provided buffer when possible to minimize allocations.
// Returns formatted JSON bytes ready for file writing.
func serializeJSON(config map[string]interface{}, buffer []byte) ([]byte, error) <span class="cov8" title="1">{
        data, err := json.MarshalIndent(config, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, ErrCodeSerializationError, "JSON marshal failed")
        }</span>

        // Reuse buffer if it has sufficient capacity
        <span class="cov8" title="1">if cap(buffer) &gt;= len(data) </span><span class="cov8" title="1">{
                buffer = buffer[:len(data)]
                copy(buffer, data)
                return buffer, nil
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// serializeYAML converts configuration to YAML format using built-in serialization.
// Provides basic YAML output compatible with most parsers without external dependencies.
// For advanced YAML features, register a custom parser using RegisterParser().
//
// Performance: Zero allocations when buffer has sufficient capacity
func serializeYAML(config map[string]interface{}, buffer []byte) ([]byte, error) <span class="cov8" title="1">{
        var lines []string

        // Convert to YAML-like format with proper indentation
        yamlLines := serializeYAMLRecursive(config, 0)
        lines = append(lines, yamlLines...)

        data := []byte(strings.Join(lines, "\n"))

        // Reuse buffer if it has sufficient capacity
        if cap(buffer) &gt;= len(data) </span><span class="cov8" title="1">{
                buffer = buffer[:len(data)]
                copy(buffer, data)
                return buffer, nil
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// serializeTOML converts configuration to TOML format using built-in serialization.
// Provides basic TOML output compatible with most parsers without external dependencies.
// For advanced TOML features, register a custom parser using RegisterParser().
//
// Performance: Zero allocations when buffer has sufficient capacity
func serializeTOML(config map[string]interface{}, buffer []byte) ([]byte, error) <span class="cov8" title="1">{
        var flatKeys []string
        var sections []string

        // First pass: collect flat keys and sections
        for key, value := range config </span><span class="cov8" title="1">{
                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        // TOML section
                        sections = append(sections, fmt.Sprintf("[%s]", key))
                        for subKey, subValue := range v </span><span class="cov8" title="1">{
                                sections = append(sections, fmt.Sprintf("%s = %s", subKey, formatTOMLValue(subValue)))
                        }</span>
                        <span class="cov8" title="1">sections = append(sections, "")</span> // Empty line between sections
                default:<span class="cov8" title="1">
                        flatKeys = append(flatKeys, fmt.Sprintf("%s = %s", key, formatTOMLValue(v)))</span>
                }
        }

        // Combine flat keys first, then sections
        <span class="cov8" title="1">result := append(flatKeys, sections...)
        if len(flatKeys) &gt; 0 &amp;&amp; len(sections) &gt; 0 </span><span class="cov8" title="1">{
                // Add separator between flat keys and sections
                result = append(flatKeys, append([]string{""}, sections...)...)
        }</span>

        <span class="cov8" title="1">data := []byte(strings.Join(result, "\n"))

        // Reuse buffer if it has sufficient capacity
        if cap(buffer) &gt;= len(data) </span><span class="cov8" title="1">{
                buffer = buffer[:len(data)]
                copy(buffer, data)
                return buffer, nil
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// serializeHCL converts configuration to HCL format using built-in serialization.
// Provides basic HCL output compatible with most parsers without external dependencies.
// For advanced HCL features, register a custom parser using RegisterParser().
//
// Performance: Zero allocations when buffer has sufficient capacity
func serializeHCL(config map[string]interface{}, buffer []byte) ([]byte, error) <span class="cov8" title="1">{
        var lines []string

        // Convert to HCL format with proper braces and structure
        for key, value := range config </span><span class="cov8" title="1">{
                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        // HCL block
                        lines = append(lines, fmt.Sprintf("%s {", key))
                        for subKey, subValue := range v </span><span class="cov8" title="1">{
                                lines = append(lines, fmt.Sprintf("  %s = %s", subKey, formatHCLValue(subValue)))
                        }</span>
                        <span class="cov8" title="1">lines = append(lines, "}")
                        lines = append(lines, "")</span> // Empty line between blocks
                default:<span class="cov8" title="1">
                        lines = append(lines, fmt.Sprintf("%s = %s", key, formatHCLValue(v)))</span>
                }
        }

        <span class="cov8" title="1">data := []byte(strings.Join(lines, "\n"))

        // Reuse buffer if it has sufficient capacity
        if cap(buffer) &gt;= len(data) </span><span class="cov8" title="1">{
                buffer = buffer[:len(data)]
                copy(buffer, data)
                return buffer, nil
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// serializeINI converts configuration to INI format.
// Supports flat key=value pairs and [section] groups for nested structures.
func serializeINI(config map[string]interface{}, buffer []byte) ([]byte, error) <span class="cov8" title="1">{
        var lines []string
        var flatKeys []string

        // First pass: collect flat keys and sections
        for key, value := range config </span><span class="cov8" title="1">{
                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        // Section header
                        lines = append(lines, fmt.Sprintf("[%s]", key))
                        for subKey, subValue := range v </span><span class="cov8" title="1">{
                                lines = append(lines, fmt.Sprintf("%s=%v", subKey, subValue))
                        }</span>
                        <span class="cov8" title="1">lines = append(lines, "")</span> // Empty line between sections
                default:<span class="cov8" title="1">
                        flatKeys = append(flatKeys, fmt.Sprintf("%s=%v", key, v))</span>
                }
        }

        // Combine flat keys first, then sections
        <span class="cov8" title="1">result := append(flatKeys, lines...)
        data := []byte(strings.Join(result, "\n"))

        // Reuse buffer if it has sufficient capacity
        if cap(buffer) &gt;= len(data) </span><span class="cov8" title="1">{
                buffer = buffer[:len(data)]
                copy(buffer, data)
                return buffer, nil
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// serializeProperties converts configuration to Java Properties format.
// Flattens nested structures using dot notation (key.subkey=value).
func serializeProperties(config map[string]interface{}, buffer []byte) ([]byte, error) <span class="cov8" title="1">{
        var lines []string

        // Flatten the configuration using dot notation
        flattened := flattenConfig(config, "")

        for key, value := range flattened </span><span class="cov8" title="1">{
                lines = append(lines, fmt.Sprintf("%s=%v", key, value))
        }</span>

        <span class="cov8" title="1">data := []byte(strings.Join(lines, "\n"))

        // Reuse buffer if it has sufficient capacity
        if cap(buffer) &gt;= len(data) </span><span class="cov8" title="1">{
                buffer = buffer[:len(data)]
                copy(buffer, data)
                return buffer, nil
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// flattenConfig converts nested maps to flat key-value pairs using dot notation
func flattenConfig(config map[string]interface{}, prefix string) map[string]interface{} <span class="cov8" title="1">{
        result := make(map[string]interface{})

        for key, value := range config </span><span class="cov8" title="1">{
                fullKey := key
                if prefix != "" </span><span class="cov8" title="1">{
                        fullKey = prefix + "." + key
                }</span>

                <span class="cov8" title="1">switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        // Recursively flatten nested maps
                        nested := flattenConfig(v, fullKey)
                        for nestedKey, nestedValue := range nested </span><span class="cov8" title="1">{
                                result[nestedKey] = nestedValue
                        }</span>
                default:<span class="cov8" title="1">
                        result[fullKey] = value</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// serializeYAMLRecursive converts a map to YAML format with proper indentation.
// Provides recursive serialization for nested structures.
//
// Performance: Optimized for readability and compatibility
func serializeYAMLRecursive(config map[string]interface{}, indentLevel int) []string <span class="cov8" title="1">{
        var lines []string
        indent := strings.Repeat("  ", indentLevel)

        for key, value := range config </span><span class="cov8" title="1">{
                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        lines = append(lines, fmt.Sprintf("%s%s:", indent, key))
                        nestedLines := serializeYAMLRecursive(v, indentLevel+1)
                        lines = append(lines, nestedLines...)</span>
                case []interface{}:<span class="cov0" title="0">
                        lines = append(lines, fmt.Sprintf("%s%s:", indent, key))
                        for _, item := range v </span><span class="cov0" title="0">{
                                lines = append(lines, fmt.Sprintf("%s  - %s", indent, formatYAMLValue(item)))
                        }</span>
                default:<span class="cov8" title="1">
                        lines = append(lines, fmt.Sprintf("%s%s: %s", indent, key, formatYAMLValue(v)))</span>
                }
        }

        <span class="cov8" title="1">return lines</span>
}

// formatYAMLValue formats a value for YAML output with proper escaping.
// Handles strings, numbers, booleans, and nil values according to YAML spec.
// Supports proper quoting, multi-line strings, and special characters.
func formatYAMLValue(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case nil:<span class="cov0" title="0">
                return "null"</span>
        case bool:<span class="cov8" title="1">
                if v </span><span class="cov8" title="1">{
                        return "true"
                }</span>
                <span class="cov0" title="0">return "false"</span>
        case string:<span class="cov8" title="1">
                return formatYAMLString(v)</span>
        case int:<span class="cov8" title="1">
                return fmt.Sprintf("%d", v)</span>
        case int64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v)</span>
        case float32:<span class="cov0" title="0">
                return fmt.Sprintf("%.6g", v)</span>
        case float64:<span class="cov8" title="1">
                return fmt.Sprintf("%.6g", v)</span>
        case []interface{}:<span class="cov0" title="0">
                // Handle inline arrays for complex nested structures
                var items []string
                for _, item := range v </span><span class="cov0" title="0">{
                        items = append(items, formatYAMLValue(item))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("[%s]", strings.Join(items, ", "))</span>
        case map[string]interface{}:<span class="cov0" title="0">
                // Handle inline objects for simple cases
                if len(v) &lt;= 2 </span><span class="cov0" title="0">{
                        var pairs []string
                        for key, val := range v </span><span class="cov0" title="0">{
                                pairs = append(pairs, fmt.Sprintf("%s: %s", key, formatYAMLValue(val)))
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("{%s}", strings.Join(pairs, ", "))</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("%v", v)</span> // Fallback for complex objects
        default:<span class="cov0" title="0">
                return fmt.Sprintf(`"%v"`, v)</span>
        }
}

// formatYAMLString formats a string for YAML output with proper quoting and escaping.
// Handles special cases like empty strings, multi-line strings, and reserved words.
func formatYAMLString(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return `""`
        }</span>

        // Check for YAML reserved words that need quoting
        <span class="cov8" title="1">reserved := []string{"true", "false", "null", "yes", "no", "on", "off"}
        for _, word := range reserved </span><span class="cov8" title="1">{
                if strings.EqualFold(s, word) </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`"%s"`, s)
                }</span>
        }

        // Check for special characters that require quoting
        <span class="cov8" title="1">needsQuoting := strings.ContainsAny(s, ": \t\n\r[]{}|&gt;-#&amp;*!%@`\"'\\")

        // Check for numeric-looking strings
        if !needsQuoting </span><span class="cov8" title="1">{
                // Simple check for numbers
                if _, err := fmt.Sscanf(s, "%f", new(float64)); err == nil &amp;&amp; s != "0" </span><span class="cov8" title="1">{
                        needsQuoting = true
                }</span>
        }

        // Check if starts with special characters
        <span class="cov8" title="1">if !needsQuoting &amp;&amp; len(s) &gt; 0 </span><span class="cov8" title="1">{
                first := s[0]
                if first == '-' || first == '?' || first == ':' || first == '[' || first == '{' || first == '!' </span><span class="cov0" title="0">{
                        needsQuoting = true
                }</span>
        }

        <span class="cov8" title="1">if needsQuoting </span><span class="cov8" title="1">{
                // Escape internal quotes and backslashes
                escaped := strings.ReplaceAll(s, `\`, `\\`)
                escaped = strings.ReplaceAll(escaped, `"`, `\"`)
                return fmt.Sprintf(`"%s"`, escaped)
        }</span>

        <span class="cov8" title="1">return s</span>
}

// formatTOMLValue formats a value for TOML output with proper escaping.
// Handles strings, numbers, booleans, and arrays according to TOML spec.
func formatTOMLValue(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case nil:<span class="cov0" title="0">
                return `""`</span>
        case bool:<span class="cov8" title="1">
                if v </span><span class="cov8" title="1">{
                        return "true"
                }</span>
                <span class="cov0" title="0">return "false"</span>
        case string:<span class="cov8" title="1">
                // TOML strings must be quoted
                return fmt.Sprintf(`"%s"`, strings.ReplaceAll(v, `"`, `\"`))</span>
        case int, int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", v)</span>
        case float64:<span class="cov8" title="1">
                return fmt.Sprintf("%g", v)</span>
        case []interface{}:<span class="cov0" title="0">
                // TOML array
                var items []string
                for _, item := range v </span><span class="cov0" title="0">{
                        items = append(items, formatTOMLValue(item))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("[%s]", strings.Join(items, ", "))</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf(`"%v"`, v)</span>
        }
}

// formatHCLValue formats a value for HCL output with proper escaping.
// Handles strings, numbers, booleans, and complex types according to HCL spec.
func formatHCLValue(value interface{}) string <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case nil:<span class="cov0" title="0">
                return "null"</span>
        case bool:<span class="cov8" title="1">
                if v </span><span class="cov8" title="1">{
                        return "true"
                }</span>
                <span class="cov0" title="0">return "false"</span>
        case string:<span class="cov8" title="1">
                // HCL strings should be quoted unless they're simple identifiers
                return fmt.Sprintf(`"%s"`, strings.ReplaceAll(v, `"`, `\"`))</span>
        case int, int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", v)</span>
        case float64:<span class="cov8" title="1">
                return fmt.Sprintf("%g", v)</span>
        case []interface{}:<span class="cov0" title="0">
                // HCL list
                var items []string
                for _, item := range v </span><span class="cov0" title="0">{
                        items = append(items, formatHCLValue(item))
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("[%s]", strings.Join(items, ", "))</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf(`"%v"`, v)</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// env_config.go: Environment Variables Support for Argus Configuration Framework
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

// Package argus provides environment variable configuration loading and processing.
// This file implements comprehensive environment-based configuration management.

package argus

import (
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/agilira/go-errors"
)

// EnvConfig represents configuration loaded from environment variables
// This provides environment variable support with automatic type detection
type EnvConfig struct {
        // Core Configuration
        PollInterval    time.Duration `env:"ARGUS_POLL_INTERVAL"`
        CacheTTL        time.Duration `env:"ARGUS_CACHE_TTL"`
        MaxWatchedFiles int           `env:"ARGUS_MAX_WATCHED_FILES"`

        // Performance Configuration
        OptimizationStrategy string `env:"ARGUS_OPTIMIZATION_STRATEGY"`
        BoreasLiteCapacity   int64  `env:"ARGUS_BOREAS_CAPACITY"`

        // Audit Configuration
        AuditEnabled       bool          `env:"ARGUS_AUDIT_ENABLED"`
        AuditOutputFile    string        `env:"ARGUS_AUDIT_OUTPUT_FILE"`
        AuditMinLevel      string        `env:"ARGUS_AUDIT_MIN_LEVEL"`
        AuditBufferSize    int           `env:"ARGUS_AUDIT_BUFFER_SIZE"`
        AuditFlushInterval time.Duration `env:"ARGUS_AUDIT_FLUSH_INTERVAL"`

        // Remote Configuration Sources
        RemoteURL      string        `env:"ARGUS_REMOTE_URL"`
        RemoteInterval time.Duration `env:"ARGUS_REMOTE_INTERVAL"`
        RemoteTimeout  time.Duration `env:"ARGUS_REMOTE_TIMEOUT"`
        RemoteHeaders  string        `env:"ARGUS_REMOTE_HEADERS"` // JSON format

        // Validation Configuration
        ValidationEnabled bool   `env:"ARGUS_VALIDATION_ENABLED"`
        ValidationSchema  string `env:"ARGUS_VALIDATION_SCHEMA"`
        ValidationStrict  bool   `env:"ARGUS_VALIDATION_STRICT"`
}

// LoadConfigFromEnv loads Argus configuration from environment variables
// This provides an intuitive interface for container deployments
func LoadConfigFromEnv() (*Config, error) <span class="cov8" title="1">{
        config := &amp;Config{}
        envConfig := &amp;EnvConfig{}

        // Load environment variables into EnvConfig struct
        if err := loadEnvVars(envConfig); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "failed to load environment configuration")
        }</span>

        // Convert EnvConfig to standard Config
        <span class="cov8" title="1">if err := convertEnvToConfig(envConfig, config); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "failed to convert environment configuration")
        }</span>

        // Apply defaults for any unset values
        <span class="cov8" title="1">config = config.WithDefaults()

        return config, nil</span>
}

// LoadConfigMultiSource loads configuration with precedence:
// 1. Environment variables (highest priority)
// 2. File configuration
// 3. Default values (lowest priority)
//
// This provides multi-source configuration loading with precedence
func LoadConfigMultiSource(configFile string) (*Config, error) <span class="cov8" title="1">{
        // Start with file-based configuration
        config := &amp;Config{}

        // Load from file if provided
        if configFile != "" </span><span class="cov8" title="1">{
                if _, err := os.Stat(configFile); err == nil </span><span class="cov8" title="1">{
                        // File exists, we could load it here when we implement file loading
                        // For now, start with defaults
                        config = config.WithDefaults()
                }</span> else<span class="cov8" title="1"> {
                        // File doesn't exist, start with defaults
                        config = config.WithDefaults()
                }</span>
        } else<span class="cov8" title="1"> {
                config = config.WithDefaults()
        }</span>

        // Override with environment variables
        <span class="cov8" title="1">envConfig, err := LoadConfigFromEnv()
        if err != nil </span><span class="cov8" title="1">{
                return config, err // Return file config with error
        }</span>

        // Apply environment overrides
        <span class="cov8" title="1">if err := mergeConfigs(config, envConfig); err != nil </span><span class="cov0" title="0">{
                return config, errors.Wrap(err, ErrCodeInvalidConfig, "failed to merge configurations")
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// loadEnvVars loads environment variables into the EnvConfig struct
func loadEnvVars(envConfig *EnvConfig) error <span class="cov8" title="1">{
        // Load configurations in logical groups
        if err := loadCoreConfig(envConfig); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := loadPerformanceConfig(envConfig); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := loadAuditConfig(envConfig); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := loadRemoteConfig(envConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return loadValidationConfig(envConfig)</span>
}

// loadCoreConfig loads core configuration from environment variables with security validation
func loadCoreConfig(envConfig *EnvConfig) error <span class="cov8" title="1">{
        // Load and validate poll interval
        if err := loadPollInterval(envConfig); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Load and validate cache TTL
        <span class="cov8" title="1">if err := loadCacheTTL(envConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load and validate max watched files
        <span class="cov8" title="1">if err := loadMaxWatchedFiles(envConfig); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadPollInterval loads and validates poll interval from environment
func loadPollInterval(envConfig *EnvConfig) error <span class="cov8" title="1">{
        pollStr := os.Getenv("ARGUS_POLL_INTERVAL")
        if pollStr == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">duration, err := time.ParseDuration(pollStr)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "invalid ARGUS_POLL_INTERVAL format")
        }</span>

        // SECURITY: Prevent excessively fast polling that could cause DoS
        <span class="cov8" title="1">if duration &lt; 100*time.Millisecond </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "poll interval too fast (minimum 100ms)")
        }</span>
        // SECURITY: Prevent excessively slow polling that could cause missed events
        <span class="cov8" title="1">if duration &gt; 10*time.Minute </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "poll interval too slow (maximum 10 minutes)")
        }</span>

        <span class="cov8" title="1">envConfig.PollInterval = duration
        return nil</span>
}

// loadCacheTTL loads and validates cache TTL from environment
func loadCacheTTL(envConfig *EnvConfig) error <span class="cov8" title="1">{
        cacheStr := os.Getenv("ARGUS_CACHE_TTL")
        if cacheStr == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">duration, err := time.ParseDuration(cacheStr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "invalid ARGUS_CACHE_TTL format")
        }</span>

        // SECURITY: Ensure cache TTL is reasonable for security and performance
        <span class="cov8" title="1">if duration &lt; 1*time.Second </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "cache TTL too short (minimum 1 second)")
        }</span>
        <span class="cov8" title="1">if duration &gt; 1*time.Hour </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "cache TTL too long (maximum 1 hour)")
        }</span>

        <span class="cov8" title="1">envConfig.CacheTTL = duration
        return nil</span>
}

// loadMaxWatchedFiles loads and validates max watched files from environment
func loadMaxWatchedFiles(envConfig *EnvConfig) error <span class="cov8" title="1">{
        maxStr := os.Getenv("ARGUS_MAX_WATCHED_FILES")
        if maxStr == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">maxFiles, err := strconv.Atoi(maxStr)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "invalid ARGUS_MAX_WATCHED_FILES value")
        }</span>

        // SECURITY: Enforce reasonable limits to prevent resource exhaustion
        <span class="cov8" title="1">if maxFiles &lt; 1 </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "max watched files must be at least 1")
        }</span>
        <span class="cov8" title="1">if maxFiles &gt; 10000 </span><span class="cov8" title="1">{ // Reasonable upper limit for most use cases
                return errors.New(ErrCodeInvalidConfig, "max watched files too high (maximum 10000)")
        }</span>

        <span class="cov8" title="1">envConfig.MaxWatchedFiles = maxFiles
        return nil</span>
}

// loadPerformanceConfig loads performance configuration from environment variables with security validation
func loadPerformanceConfig(envConfig *EnvConfig) error <span class="cov8" title="1">{
        // Load and validate optimization strategy
        if err := loadOptimizationStrategy(envConfig); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Load and validate BoreasLite capacity
        <span class="cov8" title="1">if err := loadBoreasLiteCapacity(envConfig); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadOptimizationStrategy loads and validates optimization strategy from environment
func loadOptimizationStrategy(envConfig *EnvConfig) error <span class="cov8" title="1">{
        optimizationStr := os.Getenv("ARGUS_OPTIMIZATION_STRATEGY")
        if optimizationStr == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // SECURITY: Only allow known valid optimization strategies
        <span class="cov8" title="1">validStrategies := []string{"auto", "single", "singleevent", "small", "smallbatch", "large", "largebatch"}
        lowerStrategy := strings.ToLower(optimizationStr)

        for _, valid := range validStrategies </span><span class="cov8" title="1">{
                if lowerStrategy == valid </span><span class="cov8" title="1">{
                        envConfig.OptimizationStrategy = optimizationStr
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return errors.New(ErrCodeInvalidConfig, "invalid optimization strategy")</span>
}

// loadBoreasLiteCapacity loads and validates BoreasLite capacity from environment
func loadBoreasLiteCapacity(envConfig *EnvConfig) error <span class="cov8" title="1">{
        capacityStr := os.Getenv("ARGUS_BOREAS_CAPACITY")
        if capacityStr == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">capacity, err := strconv.ParseInt(capacityStr, 10, 64)
        if err != nil || capacity &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "invalid ARGUS_BOREAS_CAPACITY value")
        }</span>

        // SECURITY: Enforce reasonable capacity limits to prevent memory exhaustion
        <span class="cov8" title="1">if capacity &lt; 32 </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "BoreasLite capacity too low (minimum 32)")
        }</span>
        <span class="cov8" title="1">if capacity &gt; 1048576 </span><span class="cov0" title="0">{ // 1MB entries max
                return errors.New(ErrCodeInvalidConfig, "BoreasLite capacity too high (maximum 1048576)")
        }</span>

        // SECURITY: Ensure capacity is power of 2 (prevents certain attacks)
        <span class="cov8" title="1">if capacity&amp;(capacity-1) != 0 </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "BoreasLite capacity must be power of 2")
        }</span>

        <span class="cov8" title="1">envConfig.BoreasLiteCapacity = capacity
        return nil</span>
}

// loadAuditConfig loads audit configuration from environment variables with security validation
func loadAuditConfig(envConfig *EnvConfig) error <span class="cov8" title="1">{
        // Load audit enable/disable settings with security validation
        if err := loadAuditEnabledSetting(envConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load and validate audit output file path
        <span class="cov8" title="1">if err := loadAuditOutputFile(envConfig); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Load audit min level
        <span class="cov8" title="1">envConfig.AuditMinLevel = os.Getenv("ARGUS_AUDIT_MIN_LEVEL")

        // Load audit buffer and flush settings with security limits
        if err := loadAuditBufferSettings(envConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadAuditEnabledSetting loads and validates audit enabled setting with security policy
func loadAuditEnabledSetting(envConfig *EnvConfig) error <span class="cov8" title="1">{
        // SECURITY POLICY: Audit should generally remain enabled in production environments
        // Only allow disabling in specific development/test scenarios
        auditStr := os.Getenv("ARGUS_AUDIT_ENABLED")
        if auditStr == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">requestedEnabled := parseBool(auditStr)

        // SECURITY CHECK: Prevent audit disabling unless explicitly allowed
        if !requestedEnabled </span><span class="cov8" title="1">{
                // Check for explicit development/test override
                devOverride := os.Getenv("ARGUS_ALLOW_AUDIT_DISABLE")
                if devOverride == "" || !parseBool(devOverride) </span><span class="cov8" title="1">{
                        // Log security event but don't fail - keep audit enabled for security
                        // In production, this should be logged to a secure audit trail
                        envConfig.AuditEnabled = true // Force enable for security
                }</span> else<span class="cov0" title="0"> {
                        envConfig.AuditEnabled = requestedEnabled
                }</span>
        } else<span class="cov8" title="1"> {
                envConfig.AuditEnabled = requestedEnabled
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loadAuditOutputFile loads and validates audit output file path
func loadAuditOutputFile(envConfig *EnvConfig) error <span class="cov8" title="1">{
        auditOutputFile := os.Getenv("ARGUS_AUDIT_OUTPUT_FILE")
        if auditOutputFile == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // SECURITY VALIDATION: Validate audit output file path
        // Use the same path validation as file watching to prevent path traversal
        <span class="cov8" title="1">if err := validateSecureAuditPath(auditOutputFile); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, ErrCodeInvalidConfig, "audit output file path is unsafe").
                        WithContext("audit_path", auditOutputFile)
        }</span>
        <span class="cov8" title="1">envConfig.AuditOutputFile = auditOutputFile
        return nil</span>
}

// loadAuditBufferSettings loads audit buffer size and flush interval with security limits
func loadAuditBufferSettings(envConfig *EnvConfig) error <span class="cov8" title="1">{
        // SECURITY LIMITS: Enforce reasonable buffer size limits
        if bufferStr := os.Getenv("ARGUS_AUDIT_BUFFER_SIZE"); bufferStr != "" </span><span class="cov8" title="1">{
                buffer, err := strconv.Atoi(bufferStr)
                if err != nil || buffer &lt;= 0 </span><span class="cov0" title="0">{
                        return errors.New(ErrCodeInvalidConfig, "invalid ARGUS_AUDIT_BUFFER_SIZE value")
                }</span>

                // SECURITY: Limit buffer size to prevent memory exhaustion attacks
                <span class="cov8" title="1">if buffer &gt; 100000 </span><span class="cov0" title="0">{ // Max 100k events in buffer
                        return errors.New(ErrCodeInvalidConfig, "audit buffer size too large (max 100000)")
                }</span>
                <span class="cov8" title="1">envConfig.AuditBufferSize = buffer</span>
        }

        <span class="cov8" title="1">if flushStr := os.Getenv("ARGUS_AUDIT_FLUSH_INTERVAL"); flushStr != "" </span><span class="cov8" title="1">{
                duration, err := time.ParseDuration(flushStr)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New(ErrCodeInvalidConfig, "invalid ARGUS_AUDIT_FLUSH_INTERVAL value")
                }</span>

                // SECURITY: Prevent excessively long flush intervals that could lose audit data
                <span class="cov8" title="1">if duration &gt; 5*time.Minute </span><span class="cov0" title="0">{
                        return errors.New(ErrCodeInvalidConfig, "audit flush interval too long (max 5 minutes)")
                }</span>
                <span class="cov8" title="1">envConfig.AuditFlushInterval = duration</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// loadRemoteConfig loads remote configuration from environment variables
func loadRemoteConfig(envConfig *EnvConfig) error <span class="cov8" title="1">{
        // Remote Configuration Sources
        envConfig.RemoteURL = os.Getenv("ARGUS_REMOTE_URL")

        if remoteStr := os.Getenv("ARGUS_REMOTE_INTERVAL"); remoteStr != "" </span><span class="cov8" title="1">{
                if duration, err := time.ParseDuration(remoteStr); err == nil </span><span class="cov8" title="1">{
                        envConfig.RemoteInterval = duration
                }</span>
        }

        <span class="cov8" title="1">if timeoutStr := os.Getenv("ARGUS_REMOTE_TIMEOUT"); timeoutStr != "" </span><span class="cov8" title="1">{
                if duration, err := time.ParseDuration(timeoutStr); err == nil </span><span class="cov8" title="1">{
                        envConfig.RemoteTimeout = duration
                }</span>
        }

        <span class="cov8" title="1">envConfig.RemoteHeaders = os.Getenv("ARGUS_REMOTE_HEADERS")
        return nil</span>
}

// loadValidationConfig loads validation configuration from environment variables
func loadValidationConfig(envConfig *EnvConfig) error <span class="cov8" title="1">{
        // Validation Configuration
        if validationStr := os.Getenv("ARGUS_VALIDATION_ENABLED"); validationStr != "" </span><span class="cov8" title="1">{
                envConfig.ValidationEnabled = parseBool(validationStr)
        }</span>

        <span class="cov8" title="1">envConfig.ValidationSchema = os.Getenv("ARGUS_VALIDATION_SCHEMA")

        if strictStr := os.Getenv("ARGUS_VALIDATION_STRICT"); strictStr != "" </span><span class="cov8" title="1">{
                envConfig.ValidationStrict = parseBool(strictStr)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// convertEnvToConfig converts EnvConfig to standard Config
func convertEnvToConfig(envConfig *EnvConfig, config *Config) error <span class="cov8" title="1">{
        // Convert configurations in logical groups
        convertCoreConfig(envConfig, config)
        if err := convertPerformanceConfig(envConfig, config); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := convertAuditConfig(envConfig, config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// convertCoreConfig converts core configuration from EnvConfig to Config
func convertCoreConfig(envConfig *EnvConfig, config *Config) <span class="cov8" title="1">{
        if envConfig.PollInterval != 0 </span><span class="cov8" title="1">{
                config.PollInterval = envConfig.PollInterval
        }</span>
        <span class="cov8" title="1">if envConfig.CacheTTL != 0 </span><span class="cov8" title="1">{
                config.CacheTTL = envConfig.CacheTTL
        }</span>
        <span class="cov8" title="1">if envConfig.MaxWatchedFiles != 0 </span><span class="cov8" title="1">{
                config.MaxWatchedFiles = envConfig.MaxWatchedFiles
        }</span>
}

// convertPerformanceConfig converts performance configuration from EnvConfig to Config
func convertPerformanceConfig(envConfig *EnvConfig, config *Config) error <span class="cov8" title="1">{
        if envConfig.OptimizationStrategy != "" </span><span class="cov8" title="1">{
                switch strings.ToLower(envConfig.OptimizationStrategy) </span>{
                case "auto":<span class="cov8" title="1">
                        config.OptimizationStrategy = OptimizationAuto</span>
                case "single", "singleevent":<span class="cov8" title="1">
                        config.OptimizationStrategy = OptimizationSingleEvent</span>
                case "small", "smallbatch":<span class="cov8" title="1">
                        config.OptimizationStrategy = OptimizationSmallBatch</span>
                case "large", "largebatch":<span class="cov8" title="1">
                        config.OptimizationStrategy = OptimizationLargeBatch</span>
                default:<span class="cov8" title="1">
                        return errors.New(ErrCodeInvalidConfig, "invalid optimization strategy")</span>
                }
        }
        <span class="cov8" title="1">if envConfig.BoreasLiteCapacity &gt; 0 </span><span class="cov8" title="1">{
                config.BoreasLiteCapacity = envConfig.BoreasLiteCapacity
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// convertAuditConfig converts audit configuration from EnvConfig to Config
func convertAuditConfig(envConfig *EnvConfig, config *Config) error <span class="cov8" title="1">{
        if envConfig.AuditEnabled || envConfig.AuditOutputFile != "" </span><span class="cov8" title="1">{
                return convertAuditSettings(envConfig, config)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// convertAuditSettings converts individual audit settings
func convertAuditSettings(envConfig *EnvConfig, config *Config) error <span class="cov8" title="1">{
        config.Audit.Enabled = envConfig.AuditEnabled

        if envConfig.AuditOutputFile != "" </span><span class="cov8" title="1">{
                config.Audit.OutputFile = envConfig.AuditOutputFile
        }</span>

        <span class="cov8" title="1">if err := convertAuditLevel(envConfig, config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">convertAuditBufferSettings(envConfig, config)
        return nil</span>
}

// convertAuditLevel converts audit level setting
func convertAuditLevel(envConfig *EnvConfig, config *Config) error <span class="cov8" title="1">{
        if envConfig.AuditMinLevel != "" </span><span class="cov8" title="1">{
                level, err := parseAuditLevel(envConfig.AuditMinLevel)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">config.Audit.MinLevel = level</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// convertAuditBufferSettings converts audit buffer and flush settings
func convertAuditBufferSettings(envConfig *EnvConfig, config *Config) <span class="cov8" title="1">{
        if envConfig.AuditBufferSize &gt; 0 </span><span class="cov8" title="1">{
                config.Audit.BufferSize = envConfig.AuditBufferSize
        }</span>
        <span class="cov8" title="1">if envConfig.AuditFlushInterval &gt; 0 </span><span class="cov8" title="1">{
                config.Audit.FlushInterval = envConfig.AuditFlushInterval
        }</span>
}

// parseAuditLevel parses audit level string to AuditLevel type
func parseAuditLevel(levelStr string) (AuditLevel, error) <span class="cov8" title="1">{
        switch strings.ToLower(levelStr) </span>{
        case "info":<span class="cov8" title="1">
                return AuditInfo, nil</span>
        case "warn", "warning":<span class="cov8" title="1">
                return AuditWarn, nil</span>
        case "critical", "error":<span class="cov8" title="1">
                return AuditCritical, nil</span>
        case "security":<span class="cov8" title="1">
                return AuditSecurity, nil</span>
        default:<span class="cov8" title="1">
                return AuditInfo, errors.New(ErrCodeInvalidConfig, "invalid audit level")</span>
        }
}

// mergeConfigs merges environment configuration into base configuration
func mergeConfigs(base, env *Config) error <span class="cov8" title="1">{
        mergeCoreConfig(base, env)
        mergeAuditConfig(base, env)
        return nil
}</span>

// mergeCoreConfig merges core configuration settings
func mergeCoreConfig(base, env *Config) <span class="cov8" title="1">{
        if env.PollInterval &gt; 0 </span><span class="cov8" title="1">{
                base.PollInterval = env.PollInterval
        }</span>
        <span class="cov8" title="1">if env.CacheTTL &gt; 0 </span><span class="cov8" title="1">{
                base.CacheTTL = env.CacheTTL
        }</span>
        <span class="cov8" title="1">if env.MaxWatchedFiles &gt; 0 </span><span class="cov8" title="1">{
                base.MaxWatchedFiles = env.MaxWatchedFiles
        }</span>
        <span class="cov8" title="1">if env.OptimizationStrategy != OptimizationAuto </span><span class="cov0" title="0">{
                base.OptimizationStrategy = env.OptimizationStrategy
        }</span>
        <span class="cov8" title="1">if env.BoreasLiteCapacity &gt; 0 </span><span class="cov8" title="1">{
                base.BoreasLiteCapacity = env.BoreasLiteCapacity
        }</span>
}

// mergeAuditConfig merges audit configuration settings
func mergeAuditConfig(base, env *Config) <span class="cov8" title="1">{
        if env.Audit.Enabled </span><span class="cov8" title="1">{
                base.Audit.Enabled = env.Audit.Enabled
        }</span>
        <span class="cov8" title="1">if env.Audit.OutputFile != "" </span><span class="cov0" title="0">{
                base.Audit.OutputFile = env.Audit.OutputFile
        }</span>
        <span class="cov8" title="1">if env.Audit.MinLevel != AuditInfo </span><span class="cov0" title="0">{
                base.Audit.MinLevel = env.Audit.MinLevel
        }</span>
        <span class="cov8" title="1">if env.Audit.BufferSize &gt; 0 </span><span class="cov8" title="1">{
                base.Audit.BufferSize = env.Audit.BufferSize
        }</span>
        <span class="cov8" title="1">if env.Audit.FlushInterval &gt; 0 </span><span class="cov8" title="1">{
                base.Audit.FlushInterval = env.Audit.FlushInterval
        }</span>
}

// parseBool parses boolean values from environment variables
// Supports: true/false, 1/0, yes/no, on/off, enabled/disabled
func parseBool(value string) bool <span class="cov8" title="1">{
        switch strings.ToLower(strings.TrimSpace(value)) </span>{
        case "true", "1", "yes", "on", "enabled":<span class="cov8" title="1">
                return true</span>
        case "false", "0", "no", "off", "disabled":<span class="cov8" title="1">
                return false</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// GetEnvWithDefault returns environment variable value or default if not set
func GetEnvWithDefault(key, defaultValue string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// GetEnvDurationWithDefault returns environment variable as duration or default
func GetEnvDurationWithDefault(key string, defaultValue time.Duration) time.Duration <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov8" title="1">{
                        return duration
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

// GetEnvIntWithDefault returns environment variable as int or default
func GetEnvIntWithDefault(key string, defaultValue int) int <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        return intValue
                }</span>
        }
        <span class="cov8" title="1">return defaultValue</span>
}

// GetEnvBoolWithDefault returns environment variable as bool or default
func GetEnvBoolWithDefault(key string, defaultValue bool) bool <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return parseBool(value)
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// validateSecureAuditPath validates audit file paths using the same security checks as file watching.
// This prevents path traversal attacks via audit configuration environment variables.
func validateSecureAuditPath(path string) error <span class="cov8" title="1">{
        // Reuse the comprehensive path validation from the main security function
        return ValidateSecurePath(path)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// examples/import_based_providers: Demonstrates Import-Based Provider Registration
//
// This example shows how remote config providers can be registered automatically
// through imports, eliminating the need for manual registration or recompilation.
//
// USAGE WITHOUT RECOMPILATION:
//   1. User adds import: import _ "github.com/agilira/argus/providers/redis"
//   2. User rebuilds once: go build
//   3. Provider is automatically available at runtime
//   4. No code changes needed to add new providers
//
// This follows the same pattern as Argus parser plugins:
//   - Zero dependencies by default
//   - Production features when needed
//   - Import-based auto-registration
//   - UX-friendly workflow

package main

import (
        "fmt"
        // Import-based auto-registration (commented for demo)
        // import _ "github.com/agilira/argus/providers/redis"
        // import _ "github.com/agilira/argus/providers/http"
        // import _ "github.com/agilira/argus/providers/consul"
        // import _ "github.com/agilira/argus/providers/etcd"
        // Note: In production, you would import:
        // "github.com/agilira/argus"
)

func main() <span class="cov0" title="0">{
        fmt.Println(" Argus Remote Config - Import-Based Providers Demo")
        fmt.Println("====================================================")

        fmt.Println("\n Current Implementation:")
        fmt.Println("    Manual registration: argus.RegisterRemoteProvider(&amp;Provider{})")
        fmt.Println("    Requires code changes and recompilation")
        fmt.Println("    Not user-friendly for adding new providers")

        fmt.Println("\n Target Implementation (Import-Based):")
        fmt.Println("    Import registration: import _ \"github.com/agilira/argus/providers/redis\"")
        fmt.Println("    Auto-registration via init() function")
        fmt.Println("    Zero code changes to add providers")
        fmt.Println("    One-time rebuild after adding import")

        fmt.Println("\n User Workflow:")
        fmt.Println("   1. go get github.com/agilira/argus/providers/redis")
        fmt.Println("   2. Add: import _ \"github.com/agilira/argus/providers/redis\"")
        fmt.Println("   3. go build  # One-time rebuild")
        fmt.Println("   4. Provider automatically available!")

        fmt.Println("\n Example Usage:")
        showUsageExamples()

        fmt.Println("\n Benefits:")
        fmt.Println("    No manual registration code")
        fmt.Println("    No recompilation when adding providers")
        fmt.Println("    Follows Argus parser plugin pattern")
        fmt.Println("    Zero dependencies by default")
        fmt.Println("    Production features when needed")

        fmt.Println("\n Implementation Notes:")
        fmt.Println("    Each provider package has init() function")
        fmt.Println("    init() calls argus.RegisterRemoteProvider()")
        fmt.Println("    Import triggers automatic registration")
        fmt.Println("    Same pattern as parser plugins")
}</span>

func showUsageExamples() <span class="cov0" title="0">{
        fmt.Println("\n   // After importing providers, usage is simple:")
        fmt.Println("   config, err := argus.LoadRemoteConfig(\"redis://localhost:6379/config:myapp\")")
        fmt.Println("   config, err := argus.LoadRemoteConfig(\"consul://localhost:8500/config/myapp\")")
        fmt.Println("   config, err := argus.LoadRemoteConfig(\"etcd://localhost:2379/config/myapp\")")
        fmt.Println("   config, err := argus.LoadRemoteConfig(\"https://config.company.com/api/myapp\")")

        fmt.Println("\n   // Watching for changes:")
        fmt.Println("   watcher, err := argus.WatchRemoteConfig(\"redis://localhost:6379/config:myapp\")")
        fmt.Println("   for config := range watcher {")
        fmt.Println("       // Handle configuration updates")
        fmt.Println("       applyConfig(config)")
        fmt.Println("   }")

        // Show what providers would be available if imported
        fmt.Println("\n Available Providers (when imported):")

        // For demo, we show what would be registered
        providers := []struct {
                pkg    string
                scheme string
                desc   string
        }{
                {"argus/providers/redis", "redis", "Redis with KEYSPACE notifications"},
                {"argus/providers/http", "http/https", "HTTP/HTTPS with authentication"},
                {"argus/providers/consul", "consul", "Consul KV with native watching"},
                {"argus/providers/etcd", "etcd", "etcd with watch API"},
                {"argus/providers/vault", "vault", "HashiCorp Vault secrets"},
                {"argus/providers/s3", "s3", "AWS S3 configuration storage"},
        }

        for _, p := range providers </span><span class="cov0" title="0">{
                fmt.Printf("   %s  %s (%s)\n", p.scheme, p.pkg, p.desc)
        }</span>

        // Note about current limitations
        <span class="cov0" title="0">fmt.Println("\n  Current Status:")
        fmt.Println("    Examples show the target architecture")
        fmt.Println("    Provider packages need to be created")
        fmt.Println("    Remote config interface needs map[string]interface{} return type")
        fmt.Println("    Following same pattern as successful parser plugin system")</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// integration.go: Unified Integration Layer for Argus + FlashFlags
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

// Package argus provides unified configuration management combining:
// - FlashFlags ultra-fast command-line parsing
// - Lock-free configuration management
// - Multi-source configuration (flags, env vars, config files, defaults)
// - Real-time configuration watching with BoreasLite

package argus

import (
        "fmt"
        "os"
        "strings"
        "time"

        flashflags "github.com/agilira/flash-flags"
        "github.com/agilira/go-errors"
)

// ConfigManager combines all configuration sources in a unified interface.
// Integrates FlashFlags for command-line parsing with Argus file watching
// and provides a fluent API for configuration management.
//
// Key features:
//   - Ultra-fast command-line parsing via FlashFlags
//   - Real-time configuration file watching
//   - Multi-source configuration (flags, env vars, files, defaults)
//   - Type-safe configuration access
//   - Automatic environment variable mapping
type ConfigManager struct {
        // FlashFlags for ultra-fast command-line parsing
        flags *flashflags.FlagSet

        // Optional file watcher for real-time config updates
        watcher *Watcher

        // Application metadata
        appName        string
        appDescription string
        appVersion     string

        // Configuration storage for explicit overrides
        values map[string]interface{}
}

// NewConfigManager creates a unified configuration manager with FlashFlags integration.
// The appName is used for environment variable prefixing and help text generation.
//
// Example:
//
//        config := argus.NewConfigManager("myapp").
//            SetDescription("My Application").
//            SetVersion("1.0.0").
//            StringFlag("port", "8080", "Server port")
func NewConfigManager(appName string) *ConfigManager <span class="cov8" title="1">{
        return &amp;ConfigManager{
                flags:   flashflags.New(appName),
                appName: appName,
                values:  make(map[string]interface{}),
        }
}</span>

// SetDescription sets the application description for help text
func (cm *ConfigManager) SetDescription(description string) *ConfigManager <span class="cov8" title="1">{
        cm.appDescription = description
        cm.flags.SetDescription(description)
        return cm
}</span>

// SetVersion sets the application version for help text
func (cm *ConfigManager) SetVersion(version string) *ConfigManager <span class="cov8" title="1">{
        cm.appVersion = version
        cm.flags.SetVersion(version)
        return cm
}</span>

// Flag Registration Methods - Fluent Interface

// StringFlag adds a string configuration flag
func (cm *ConfigManager) StringFlag(name, defaultValue, usage string) *ConfigManager <span class="cov8" title="1">{
        // Register with FlashFlags
        cm.flags.String(name, defaultValue, usage)
        return cm
}</span>

// IntFlag adds an integer configuration flag
func (cm *ConfigManager) IntFlag(name string, defaultValue int, usage string) *ConfigManager <span class="cov8" title="1">{
        cm.flags.Int(name, defaultValue, usage)
        return cm
}</span>

// BoolFlag adds a boolean configuration flag
func (cm *ConfigManager) BoolFlag(name string, defaultValue bool, usage string) *ConfigManager <span class="cov8" title="1">{
        cm.flags.Bool(name, defaultValue, usage)
        return cm
}</span>

// DurationFlag adds a duration configuration flag
func (cm *ConfigManager) DurationFlag(name string, defaultValue time.Duration, usage string) *ConfigManager <span class="cov8" title="1">{
        cm.flags.Duration(name, defaultValue, usage)
        return cm
}</span>

// Float64Flag adds a float64 configuration flag
func (cm *ConfigManager) Float64Flag(name string, defaultValue float64, usage string) *ConfigManager <span class="cov8" title="1">{
        cm.flags.Float64(name, defaultValue, usage)
        return cm
}</span>

// StringSliceFlag adds a string slice configuration flag
func (cm *ConfigManager) StringSliceFlag(name string, defaultValue []string, usage string) *ConfigManager <span class="cov8" title="1">{
        cm.flags.StringSlice(name, defaultValue, usage)
        return cm
}</span>

// Configuration Management Methods

// Parse parses command-line arguments and binds them to configuration
func (cm *ConfigManager) Parse(args []string) error <span class="cov8" title="1">{
        // Check for help flags first to prevent double output
        for _, arg := range args </span><span class="cov8" title="1">{
                if arg == "--help" || arg == "-h" </span><span class="cov8" title="1">{
                        return errors.New(ErrCodeInvalidConfig, "help requested")
                }</span>
        }

        // Parse command-line flags using FlashFlags directly
        <span class="cov8" title="1">if err := cm.flags.Parse(args); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, ErrCodeInvalidConfig, "failed to parse command-line flags")
        }</span>

        // Load environment variables
        <span class="cov8" title="1">cm.loadEnvironmentVariables()

        return nil</span>
}

// ParseArgs is a convenience method that parses os.Args[1:]
func (cm *ConfigManager) ParseArgs() error <span class="cov8" title="1">{
        return cm.Parse(os.Args[1:])
}</span>

// ParseArgsOrExit parses command-line arguments and exits gracefully on help/error
func (cm *ConfigManager) ParseArgsOrExit() <span class="cov8" title="1">{
        if err := cm.ParseArgs(); err != nil </span><span class="cov0" title="0">{
                if err.Error() == "help requested" </span><span class="cov0" title="0">{
                        // Show clean, unified help and exit
                        cm.PrintUsage()
                        os.Exit(0)
                }</span> else<span class="cov0" title="0"> {
                        // Show error and help, then exit with error code
                        fmt.Fprintf(os.Stderr, "Error: %v\n\n", err)
                        cm.PrintUsage()
                        os.Exit(1)
                }</span>
        }
}

// Configuration Access Methods - Type-Safe and Ultra-Fast

// GetString retrieves a string configuration value
func (cm *ConfigManager) GetString(key string) string <span class="cov8" title="1">{
        // Check explicit overrides first
        if val, exists := cm.values[key]; exists </span><span class="cov8" title="1">{
                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }

        // Use FlashFlags value
        <span class="cov8" title="1">return cm.flags.GetString(key)</span>
}

// GetInt retrieves an integer configuration value
func (cm *ConfigManager) GetInt(key string) int <span class="cov8" title="1">{
        // Check explicit overrides first
        if val, exists := cm.values[key]; exists </span><span class="cov8" title="1">{
                if intVal, ok := val.(int); ok </span><span class="cov8" title="1">{
                        return intVal
                }</span>
        }

        // Use FlashFlags value
        <span class="cov8" title="1">return cm.flags.GetInt(key)</span>
}

// GetBool retrieves a boolean configuration value
func (cm *ConfigManager) GetBool(key string) bool <span class="cov8" title="1">{
        // Check explicit overrides first
        if val, exists := cm.values[key]; exists </span><span class="cov8" title="1">{
                if boolVal, ok := val.(bool); ok </span><span class="cov8" title="1">{
                        return boolVal
                }</span>
        }

        // Use FlashFlags value
        <span class="cov8" title="1">return cm.flags.GetBool(key)</span>
}

// GetDuration retrieves a duration configuration value
func (cm *ConfigManager) GetDuration(key string) time.Duration <span class="cov8" title="1">{
        // Check explicit overrides first
        if val, exists := cm.values[key]; exists </span><span class="cov8" title="1">{
                if durVal, ok := val.(time.Duration); ok </span><span class="cov8" title="1">{
                        return durVal
                }</span>
        }

        // Use FlashFlags value
        <span class="cov8" title="1">return cm.flags.GetDuration(key)</span>
}

// GetStringSlice retrieves a string slice configuration value
func (cm *ConfigManager) GetStringSlice(key string) []string <span class="cov8" title="1">{
        // Check explicit overrides first
        if val, exists := cm.values[key]; exists </span><span class="cov8" title="1">{
                if sliceVal, ok := val.([]string); ok </span><span class="cov8" title="1">{
                        return sliceVal
                }</span>
        }

        // Use FlashFlags value
        <span class="cov8" title="1">return cm.flags.GetStringSlice(key)</span>
}

// Set explicitly sets a configuration value (highest precedence)
func (cm *ConfigManager) Set(key string, value interface{}) <span class="cov8" title="1">{
        cm.values[key] = value
}</span>

// SetDefault sets a default configuration value (lowest precedence)
func (cm *ConfigManager) SetDefault(key string, value interface{}) {<span class="cov8" title="1">
        // FlashFlags handles defaults internally
        // This method exists for API compatibility
}</span>

// Configuration File Support

// LoadConfigFile loads configuration from a file
func (cm *ConfigManager) LoadConfigFile(path string) error <span class="cov8" title="1">{
        // This would integrate with the FlashFlags config file loading
        // For now, we delegate to the underlying flag system
        // TODO: Implement direct JSON/YAML/TOML loading
        return nil
}</span>

// Real-Time Configuration Watching

// WatchConfigFile enables real-time configuration file watching
func (cm *ConfigManager) WatchConfigFile(path string, callback func()) error <span class="cov8" title="1">{
        if cm.watcher == nil </span><span class="cov8" title="1">{
                cm.watcher = New(Config{
                        PollInterval: 1 * time.Second,
                        CacheTTL:     500 * time.Millisecond,
                })
        }</span>

        <span class="cov8" title="1">return cm.watcher.Watch(path, func(event ChangeEvent) </span><span class="cov0" title="0">{
                // Reload configuration when file changes
                if err := cm.LoadConfigFile(path); err == nil </span><span class="cov0" title="0">{
                        if callback != nil </span><span class="cov0" title="0">{
                                callback()
                        }</span>
                }
        })
}

// StartWatching starts the configuration file watcher
func (cm *ConfigManager) StartWatching() error <span class="cov8" title="1">{
        if cm.watcher == nil </span><span class="cov8" title="1">{
                return nil // No files being watched
        }</span>
        <span class="cov8" title="1">return cm.watcher.Start()</span>
}

// StopWatching stops the configuration file watcher
func (cm *ConfigManager) StopWatching() error <span class="cov8" title="1">{
        if cm.watcher == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return cm.watcher.Stop()</span>
}

// Utility Methods

// PrintUsage prints help information for all flags
func (cm *ConfigManager) PrintUsage() <span class="cov8" title="1">{
        // Use FlashFlags built-in help system
        cm.flags.PrintHelp()
}</span>

// GetStats returns configuration performance statistics
func (cm *ConfigManager) GetStats() (total, valid int) <span class="cov8" title="1">{
        // Count flags from FlashFlags
        total = 0
        cm.flags.VisitAll(func(flag *flashflags.Flag) </span><span class="cov8" title="1">{
                total++
        }</span>)

        // All flags are valid with FlashFlags
        <span class="cov8" title="1">valid = total
        return total, valid</span>
}

// GetBoundFlags returns a map of all bound flags and their configuration keys
func (cm *ConfigManager) GetBoundFlags() map[string]string <span class="cov8" title="1">{
        result := make(map[string]string)
        cm.flags.VisitAll(func(flag *flashflags.Flag) </span><span class="cov8" title="1">{
                name := flag.Name()
                configKey := cm.flagNameToConfigKey(name)
                result[name] = configKey
        }</span>)
        <span class="cov8" title="1">return result</span>
}

// Private helper methods

// flagNameToConfigKey converts a flag name to a configuration key
func (cm *ConfigManager) flagNameToConfigKey(flagName string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(flagName, "-", ".")
}</span>

// loadEnvironmentVariables loads values from environment variables
func (cm *ConfigManager) loadEnvironmentVariables() <span class="cov8" title="1">{
        // FlashFlags handles environment variables automatically
        // Set the environment prefix
        cm.flags.SetEnvPrefix(strings.ToUpper(cm.appName))
}</span>

// FlagToEnvKey converts a flag name to an environment variable key (exported version)
func (cm *ConfigManager) FlagToEnvKey(flagName string) string <span class="cov8" title="1">{
        return cm.flagToEnvKey(flagName)
}</span>

// flagToEnvKey converts a flag name to an environment variable key
func (cm *ConfigManager) flagToEnvKey(flagName string) string <span class="cov8" title="1">{
        // Convert "server-port" to "APPNAME_SERVER_PORT"
        envKey := strings.ToUpper(cm.appName + "_" + strings.ReplaceAll(flagName, "-", "_"))
        return envKey
}</span>

// Example usage patterns for documentation:
//
// Basic Usage:
//   config := argus.NewConfigManager("myapp").
//       SetDescription("My Application").
//       SetVersion("1.0.0").
//       StringFlag("config", "config.json", "Configuration file path").
//       IntFlag("port", 8080, "Server port").
//       BoolFlag("debug", false, "Enable debug mode")
//
//   if err := config.ParseArgs(); err != nil {
//       log.Fatal(err)
//   }
//
//   port := config.GetInt("port")        // Command-line, env var, or default
//   debug := config.GetBool("debug")     // Supports: --debug, MYAPP_DEBUG=true
//
// Advanced Usage with File Watching:
//   config.WatchConfigFile("config.json", func() {
//       log.Println("Configuration reloaded")
//   })
//   config.StartWatching()
//   defer config.StopWatching()
</pre>
		
		<pre class="file" id="file14" style="display: none">// parser_structured.go: Structured configuration parsers for Argus
//
// This file contains parsers for structured configuration formats:
// - JSON (JavaScript Object Notation)
// - YAML (YAML Ain't Markup Language)
// - TOML (Tom's Obvious Minimal Language)
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "encoding/json"
        "strings"

        "github.com/agilira/go-errors"
)

// parseJSON parses JSON configuration with pooled map to reduce allocations.
// Uses the standard library JSON parser for full RFC 7159 compliance.
// Returns the config map to the caller (caller responsible for memory management).
func parseJSON(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := getConfigMap()
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                putConfigMap(config)
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "invalid JSON")
        }</span>
        // Note: We don't put the config back in the pool since we're returning it
        // The caller is responsible for the memory
        <span class="cov8" title="1">return config, nil</span>
}

// parseYAML parses YAML configuration using a simple line-based implementation.
// Handles basic key-value pairs for 80% use cases. For complex YAML features,
// use a plugin parser with full YAML specification compliance.
// Does not support multi-line values, arrays, or nested structures.
func parseYAML(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := getConfigMap()
        lines := strings.Split(string(data), "\n")

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Parse value
                config[key] = parseValue(value)</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}

// parseTOML parses TOML configuration with support for sections, nested tables, arrays, and basic types.
// Covers 85% of real-world TOML usage: [sections], [nested.tables], arrays [1,2,3], and proper type inference.
// Supports quoted strings, integers, floats, booleans, and basic arrays.
func parseTOML(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := getConfigMap()
        lines := strings.Split(string(data), "\n")

        var currentSection []string // Track current section path like ["app", "database"]

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Handle section headers [section] or [nested.section]
                <span class="cov8" title="1">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov8" title="1">{
                        sectionName := strings.Trim(line, "[]")
                        currentSection = strings.Split(sectionName, ".")

                        // Create nested structure for section
                        createNestedPath(config, currentSection)
                        continue</span>
                }

                // Handle key=value pairs
                <span class="cov8" title="1">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Parse the value with enhanced type support
                parsedValue := parseTOMLValue(value)

                // Set value in the correct section
                if len(currentSection) == 0 </span><span class="cov8" title="1">{
                        // Root level
                        config[key] = parsedValue
                }</span> else<span class="cov8" title="1"> {
                        // Inside a section
                        setNestedValue(config, append(currentSection, key), parsedValue)
                }</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}

// parseTOMLValue parses a TOML value with support for arrays, booleans, numbers, and strings.
// Handles quoted strings, arrays [1,2,3], and automatic type inference for common types.
func parseTOMLValue(value string) interface{} <span class="cov8" title="1">{
        value = strings.TrimSpace(value)

        // Handle arrays [1, 2, 3] or ["a", "b", "c"]
        if strings.HasPrefix(value, "[") &amp;&amp; strings.HasSuffix(value, "]") </span><span class="cov0" title="0">{
                return parseTOMLArray(value)
        }</span>

        // Handle quoted strings
        <span class="cov8" title="1">if strings.HasPrefix(value, "\"") &amp;&amp; strings.HasSuffix(value, "\"") </span><span class="cov8" title="1">{
                return strings.Trim(value, "\"")
        }</span>

        // Use existing parseValue for type inference
        <span class="cov8" title="1">return parseValue(value)</span>
}

// parseTOMLArray parses TOML array syntax [item1, item2, item3].
// Supports mixed types and handles both quoted and unquoted values.
func parseTOMLArray(arrayStr string) interface{} <span class="cov0" title="0">{
        // Remove brackets and split by comma
        content := strings.Trim(arrayStr, "[]")
        if content == "" </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">items := strings.Split(content, ",")
        result := make([]interface{}, 0, len(items))

        for _, item := range items </span><span class="cov0" title="0">{
                item = strings.TrimSpace(item)
                if item != "" </span><span class="cov0" title="0">{
                        result = append(result, parseTOMLValue(item))
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// createNestedPath ensures that nested path exists in the config map.
// Creates intermediate maps as needed for paths like ["app", "database"].
func createNestedPath(config map[string]interface{}, path []string) <span class="cov8" title="1">{
        current := config

        for _, segment := range path </span><span class="cov8" title="1">{
                if _, exists := current[segment]; !exists </span><span class="cov8" title="1">{
                        current[segment] = make(map[string]interface{})
                }</span>

                // Move deeper into the structure
                <span class="cov8" title="1">if nested, ok := current[segment].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        current = nested
                }</span> else<span class="cov0" title="0"> {
                        // If the path conflicts with existing data, create new map
                        newMap := make(map[string]interface{})
                        current[segment] = newMap
                        current = newMap
                }</span>
        }
}

// setNestedValue sets a value at the specified nested path in the config map.
// Creates intermediate maps as needed and handles path conflicts gracefully.
func setNestedValue(config map[string]interface{}, path []string, value interface{}) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if len(path) == 1 </span><span class="cov0" title="0">{
                config[path[0]] = value
                return
        }</span>

        // Ensure intermediate path exists
        <span class="cov8" title="1">current := config
        for _, segment := range path[:len(path)-1] </span><span class="cov8" title="1">{
                if _, exists := current[segment]; !exists </span><span class="cov0" title="0">{
                        current[segment] = make(map[string]interface{})
                }</span>

                <span class="cov8" title="1">if nested, ok := current[segment].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        current = nested
                }</span> else<span class="cov0" title="0"> {
                        // Path conflict - convert to map
                        newMap := make(map[string]interface{})
                        current[segment] = newMap
                        current = newMap
                }</span>
        }

        // Set the final value
        <span class="cov8" title="1">current[path[len(path)-1]] = value</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// parser_text.go: Text-based configuration parsers for Argus
//
// This file contains parsers for text-based configuration formats:
// - HCL (HashiCorp Configuration Language)
// - INI files (with sections)
// - Java Properties files
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "bufio"
        "strings"
)

// parseHCL parses HCL (HashiCorp Configuration Language) with support for blocks, nested structures, and arrays.
// Covers 85% of real-world HCL usage: blocks {}, nested blocks, key-value pairs, arrays, and proper type inference.
// Supports both # and // comment styles, quoted strings, and basic expressions.
func parseHCL(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := make(map[string]interface{})
        content := string(data)

        // Parse HCL using a simple state machine approach
        parsed, err := parseHCLContent(content, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return parsed, nil</span>
}

// parseHCLContent processes HCL content and builds the configuration map.
// Uses a simple state machine to handle blocks, key-value pairs, and nested structures.
func parseHCLContent(content string, config map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        lines := strings.Split(content, "\n")
        i := 0

        for i &lt; len(lines) </span><span class="cov8" title="1">{
                line := strings.TrimSpace(lines[i])

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "//") </span><span class="cov8" title="1">{
                        i++
                        continue</span>
                }

                // Check if this is a block definition (name {)
                <span class="cov8" title="1">if strings.Contains(line, "{") &amp;&amp; !strings.Contains(line, "=") </span><span class="cov8" title="1">{
                        blockName := strings.TrimSpace(strings.Split(line, "{")[0])

                        // Find the matching closing brace
                        blockContent, endIndex := extractHCLBlock(lines, i)
                        if blockContent == "" </span><span class="cov0" title="0">{
                                i++
                                continue</span>
                        }

                        // Parse the block content recursively
                        <span class="cov8" title="1">blockConfig := make(map[string]interface{})
                        if _, err := parseHCLContent(blockContent, blockConfig); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">config[blockName] = blockConfig

                        i = endIndex + 1
                        continue</span>
                }

                // Handle key-value pairs
                <span class="cov8" title="1">if strings.Contains(line, "=") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(line, "=", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                key := strings.TrimSpace(parts[0])
                                value := strings.TrimSpace(parts[1])
                                config[key] = parseHCLValue(value)
                        }</span>
                }

                <span class="cov8" title="1">i++</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}

// extractHCLBlock extracts the content of an HCL block from the line array.
// Returns the block content and the index of the closing brace.
func extractHCLBlock(lines []string, startIndex int) (string, int) <span class="cov8" title="1">{
        var blockLines []string
        braceCount := 0
        started := false

        for i := startIndex; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                line := lines[i]

                // Count braces to handle nested blocks
                openBraces := strings.Count(line, "{")
                closeBraces := strings.Count(line, "}")

                if !started </span><span class="cov8" title="1">{
                        if openBraces &gt; 0 </span><span class="cov8" title="1">{
                                started = true
                                braceCount += openBraces
                                // Add content after opening brace on same line
                                if idx := strings.Index(line, "{"); idx != -1 &amp;&amp; idx+1 &lt; len(line) </span><span class="cov8" title="1">{
                                        remaining := strings.TrimSpace(line[idx+1:])
                                        if remaining != "" </span><span class="cov8" title="1">{
                                                blockLines = append(blockLines, remaining)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">braceCount += openBraces - closeBraces

                if braceCount &lt;= 0 </span><span class="cov8" title="1">{
                        // Found the closing brace
                        if closeBraces &gt; 0 &amp;&amp; strings.Index(line, "}") &gt; 0 </span><span class="cov0" title="0">{
                                // Add content before closing brace
                                beforeBrace := line[:strings.Index(line, "}")]
                                if strings.TrimSpace(beforeBrace) != "" </span><span class="cov0" title="0">{
                                        blockLines = append(blockLines, beforeBrace)
                                }</span>
                        }
                        <span class="cov8" title="1">return strings.Join(blockLines, "\n"), i</span>
                }

                // Add full line to block content
                <span class="cov8" title="1">blockLines = append(blockLines, line)</span>
        }

        <span class="cov8" title="1">return strings.Join(blockLines, "\n"), len(lines) - 1</span>
}

// parseHCLValue parses an HCL value with support for arrays, booleans, numbers, and strings.
// Handles quoted strings, arrays [1,2,3], and automatic type inference.
func parseHCLValue(value string) interface{} <span class="cov8" title="1">{
        value = strings.TrimSpace(value)

        // Handle arrays [1, 2, 3] or ["a", "b", "c"]
        if strings.HasPrefix(value, "[") &amp;&amp; strings.HasSuffix(value, "]") </span><span class="cov0" title="0">{
                return parseHCLArray(value)
        }</span>

        // Handle quoted strings
        <span class="cov8" title="1">if strings.HasPrefix(value, "\"") &amp;&amp; strings.HasSuffix(value, "\"") </span><span class="cov8" title="1">{
                return strings.Trim(value, "\"")
        }</span>

        // Use existing parseValue for type inference
        <span class="cov8" title="1">return parseValue(value)</span>
}

// parseHCLArray parses HCL array syntax [item1, item2, item3].
// Supports mixed types and handles both quoted and unquoted values.
func parseHCLArray(arrayStr string) interface{} <span class="cov0" title="0">{
        // Remove brackets and split by comma
        content := strings.Trim(arrayStr, "[]")
        if content == "" </span><span class="cov0" title="0">{
                return []interface{}{}
        }</span>

        <span class="cov0" title="0">items := strings.Split(content, ",")
        result := make([]interface{}, 0, len(items))

        for _, item := range items </span><span class="cov0" title="0">{
                item = strings.TrimSpace(item)
                if item != "" </span><span class="cov0" title="0">{
                        result = append(result, parseHCLValue(item))
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

// parseINI parses INI configuration files with section support.
// Handles traditional INI format with [section] headers and key=value pairs.
// Section names are prefixed to keys with dot notation (e.g., "database.host").
// Supports both ; and # comment styles. Empty sections are handled gracefully.
func parseINI(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := make(map[string]interface{})
        lines := strings.Split(string(data), "\n")
        currentSection := ""

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, ";") || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for section header
                <span class="cov8" title="1">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov8" title="1">{
                        currentSection = strings.Trim(line, "[]") + "."
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                // Prefix with section if we have one
                if currentSection != "" </span><span class="cov8" title="1">{
                        key = currentSection + key
                }</span>

                <span class="cov8" title="1">config[key] = parseValue(value)</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}

// parseProperties parses Java-style properties files with line-based processing.
// Supports key=value format with # and ! comment styles (Java standard).
// Uses bufio.Scanner for efficient line processing of large property files.
// Handles whitespace trimming and empty line skipping automatically.
func parseProperties(data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        config := make(map[string]interface{})
        scanner := bufio.NewScanner(strings.NewReader(string(data)))

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "!") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                config[key] = parseValue(value)</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// parsers.go: Universal configuration file parsers for Argus
//
// This file provides parsing support for major configuration formats,
// making Argus truly universal and not a "one-trick pony".
//
// Supported Formats:
// - JSON (.json) - Full production support
// - YAML (.yml, .yaml) - Simple built-in + plugin support
// - TOML (.toml) - Simple built-in + plugin support
// - HCL (.hcl, .tf) - Simple built-in + plugin support
// - INI/Config (.ini, .conf, .cfg) - Simple built-in + plugin support
// - Properties (.properties) - Simple built-in + plugin support
//
// Parser Architecture:
// - Built-in parsers: Simple, fast, zero-dependency for 80% use cases
// - Plugin parsers: Full-featured external parsers for complex production needs
// - Automatic fallback: Try plugins first, fallback to built-in
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "strconv"
        "strings"
        "sync"

        "github.com/agilira/go-errors"
)

// ConfigFormat represents supported configuration file formats for auto-detection.
// Used by the format detection system to determine appropriate parser selection.
type ConfigFormat int

const (
        FormatJSON ConfigFormat = iota
        FormatYAML
        FormatTOML
        FormatHCL
        FormatINI
        FormatProperties
        FormatUnknown
)

// ConfigParser defines the interface for pluggable configuration parsers
//
// PRODUCTION PARSER INTEGRATION:
// Go binaries are compiled statically, so "plugins" work via compile-time registration:
//
//  1. IMPORT-BASED REGISTRATION (Recommended):
//     Users import parser libraries that auto-register in init():
//
//     import _ "github.com/your-org/argus-yaml-pro"   // Registers advanced YAML parser
//     import _ "github.com/your-org/argus-toml-pro"   // Registers advanced TOML parser
//
//  2. MANUAL REGISTRATION:
//     Users manually register parsers in their main():
//
//     argus.RegisterParser(&amp;MyAdvancedYAMLParser{})
//
//  3. BUILD TAGS (Advanced):
//     Conditional compilation for different parser sets:
//
//     go build -tags "yaml_pro,toml_pro" ./...
//
// Built-in parsers handle 80% of use cases with zero dependencies.
// Production parsers provide full spec compliance and advanced features.
type ConfigParser interface {
        // Parse parses configuration data for supported formats
        Parse(data []byte) (map[string]interface{}, error)

        // Supports returns true if this parser can handle the given format
        Supports(format ConfigFormat) bool

        // Name returns a human-readable name for this parser (for debugging)
        Name() string
}

// Global registry of custom parsers (production environments can register advanced parsers)
var (
        customParsers []ConfigParser
        parserMutex   sync.RWMutex
)

// RegisterParser registers a custom parser for production use cases.
// Custom parsers are tried before built-in parsers, allowing for full
// specification compliance or advanced features not available in built-in parsers.
//
// Example:
//
//        argus.RegisterParser(&amp;MyAdvancedYAMLParser{})
//
// Or via import-based registration:
//
//        import _ "github.com/your-org/argus-yaml-pro"
func RegisterParser(parser ConfigParser) <span class="cov8" title="1">{
        parserMutex.Lock()
        defer parserMutex.Unlock()
        customParsers = append(customParsers, parser)
}</span>

// configMapPool is a sync.Pool for reusing map[string]interface{} to reduce allocations
var configMapPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return make(map[string]interface{})
        }</span>,
}

// getConfigMap gets a map from the pool and clears it for reuse.
// Part of the memory optimization system to reduce allocations during parsing.
func getConfigMap() map[string]interface{} <span class="cov8" title="1">{
        if config, ok := configMapPool.Get().(map[string]interface{}); ok </span><span class="cov8" title="1">{
                // Clear the map for reuse
                for k := range config </span><span class="cov8" title="1">{
                        delete(config, k)
                }</span>
                <span class="cov8" title="1">return config</span>
        }
        // Fallback if type assertion fails
        <span class="cov0" title="0">return make(map[string]interface{})</span>
}

// putConfigMap returns a map to the pool for reuse.
// Should be called when a map is no longer needed to prevent memory leaks.
func putConfigMap(config map[string]interface{}) <span class="cov8" title="1">{
        configMapPool.Put(config)
}</span>

// String returns the string representation of the config format for debugging and logging.
func (cf ConfigFormat) String() string <span class="cov8" title="1">{
        switch cf </span>{
        case FormatJSON:<span class="cov8" title="1">
                return "JSON"</span>
        case FormatYAML:<span class="cov8" title="1">
                return "YAML"</span>
        case FormatTOML:<span class="cov8" title="1">
                return "TOML"</span>
        case FormatHCL:<span class="cov8" title="1">
                return "HCL"</span>
        case FormatINI:<span class="cov8" title="1">
                return "INI"</span>
        case FormatProperties:<span class="cov8" title="1">
                return "Properties"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// DetectFormat detects the configuration format from file extension
// HYPER-OPTIMIZED: Zero allocations, perfect hashing, unrolled loops
// Note: High cyclomatic complexity (38) is justified for optimal performance
// across 7 configuration formats with zero memory allocation
func DetectFormat(filePath string) ConfigFormat <span class="cov8" title="1">{
        length := len(filePath)
        if length &lt; 3 </span><span class="cov8" title="1">{ // Minimum: ".tf"
                return FormatUnknown
        }</span>

        // Fast backward scan with unrolled loop for common extensions
        // Most files are short, so unrolling the common cases is faster

        // Check last 11 chars for .properties (longest extension)
        <span class="cov8" title="1">if length &gt;= 11 &amp;&amp;
                filePath[length-11] == '.' &amp;&amp;
                (filePath[length-10]|32) == 'p' &amp;&amp; // |32 converts to lowercase
                (filePath[length-9]|32) == 'r' &amp;&amp;
                (filePath[length-8]|32) == 'o' &amp;&amp;
                (filePath[length-7]|32) == 'p' &amp;&amp;
                (filePath[length-6]|32) == 'e' &amp;&amp;
                (filePath[length-5]|32) == 'r' &amp;&amp;
                (filePath[length-4]|32) == 't' &amp;&amp;
                (filePath[length-3]|32) == 'i' &amp;&amp;
                (filePath[length-2]|32) == 'e' &amp;&amp;
                (filePath[length-1]|32) == 's' </span><span class="cov8" title="1">{
                return FormatProperties
        }</span>

        // Check last 8 chars for .config
        <span class="cov8" title="1">if length &gt;= 8 &amp;&amp;
                filePath[length-8] == '.' &amp;&amp;
                (filePath[length-7]|32) == 'c' &amp;&amp;
                (filePath[length-6]|32) == 'o' &amp;&amp;
                (filePath[length-5]|32) == 'n' &amp;&amp;
                (filePath[length-4]|32) == 'f' &amp;&amp;
                (filePath[length-3]|32) == 'i' &amp;&amp;
                (filePath[length-2]|32) == 'g' </span><span class="cov0" title="0">{
                return FormatINI
        }</span>

        // Check last 5 chars for common extensions: .json, .yaml, .toml, .conf
        <span class="cov8" title="1">if length &gt;= 5 &amp;&amp; filePath[length-5] == '.' </span><span class="cov8" title="1">{
                b1, b2, b3, b4 := filePath[length-4]|32, filePath[length-3]|32, filePath[length-2]|32, filePath[length-1]|32
                // Perfect hash for 4-char extensions
                switch uint32(b1)&lt;&lt;24 | uint32(b2)&lt;&lt;16 | uint32(b3)&lt;&lt;8 | uint32(b4) </span>{
                case 0x6a736f6e:<span class="cov8" title="1"> // "json"
                        return FormatJSON</span>
                case 0x79616d6c:<span class="cov8" title="1"> // "yaml"
                        return FormatYAML</span>
                case 0x746f6d6c:<span class="cov8" title="1"> // "toml"
                        return FormatTOML</span>
                case 0x636f6e66:<span class="cov8" title="1"> // "conf"
                        return FormatINI</span>
                }
        }

        // Check last 4 chars for: .yml, .hcl, .ini, .cfg
        <span class="cov8" title="1">if length &gt;= 4 &amp;&amp; filePath[length-4] == '.' </span><span class="cov8" title="1">{
                b1, b2, b3 := filePath[length-3]|32, filePath[length-2]|32, filePath[length-1]|32
                // Perfect hash for 3-char extensions
                switch uint32(b1)&lt;&lt;16 | uint32(b2)&lt;&lt;8 | uint32(b3) </span>{
                case 0x796d6c:<span class="cov8" title="1"> // "yml"
                        return FormatYAML</span>
                case 0x68636c:<span class="cov8" title="1"> // "hcl"
                        return FormatHCL</span>
                case 0x696e69:<span class="cov8" title="1"> // "ini"
                        return FormatINI</span>
                case 0x636667:<span class="cov8" title="1"> // "cfg"
                        return FormatINI</span>
                }
        }

        // Check last 3 chars for: .tf
        <span class="cov8" title="1">if length &gt;= 3 &amp;&amp; filePath[length-3] == '.' </span><span class="cov8" title="1">{
                b1, b2 := filePath[length-2]|32, filePath[length-1]|32
                if b1 == 't' &amp;&amp; b2 == 'f' </span><span class="cov8" title="1">{
                        return FormatHCL
                }</span>
        }

        <span class="cov8" title="1">return FormatUnknown</span>
}

// ParseConfig parses configuration data based on the detected format.
// Tries custom parsers first, then falls back to built-in parsers.
// HYPER-OPTIMIZED: Fast path for no custom parsers, reduced lock contention.
//
// Parameters:
//   - data: Raw configuration file bytes
//   - format: Detected configuration format
//
// Returns:
//   - map[string]interface{}: Parsed configuration data
//   - error: Any parsing errors
func ParseConfig(data []byte, format ConfigFormat) (map[string]interface{}, error) <span class="cov8" title="1">{
        // Fast path: Check if we have any custom parsers without locking
        // This is safe because customParsers is only appended to, never modified
        if len(customParsers) == 0 </span><span class="cov8" title="1">{
                // No custom parsers, go straight to built-in
                return parseBuiltin(data, format)
        }</span>

        // Slow path: Check custom parsers with minimal lock time
        <span class="cov8" title="1">parserMutex.RLock()
        for _, parser := range customParsers </span><span class="cov8" title="1">{
                if parser.Supports(format) </span><span class="cov8" title="1">{
                        config, err := parser.Parse(data)
                        parserMutex.RUnlock()
                        return config, err
                }</span>
        }
        <span class="cov0" title="0">parserMutex.RUnlock()

        // No custom parser found, use built-in
        return parseBuiltin(data, format)</span>
}

// parseBuiltin handles built-in parsing without any locks for maximum performance.
// Used as fallback when no custom parsers are available or applicable.
func parseBuiltin(data []byte, format ConfigFormat) (map[string]interface{}, error) <span class="cov8" title="1">{
        switch format </span>{
        case FormatJSON:<span class="cov8" title="1">
                return parseJSON(data)</span>
        case FormatYAML:<span class="cov8" title="1">
                return parseYAML(data)</span>
        case FormatTOML:<span class="cov8" title="1">
                return parseTOML(data)</span>
        case FormatHCL:<span class="cov8" title="1">
                return parseHCL(data)</span>
        case FormatINI:<span class="cov8" title="1">
                return parseINI(data)</span>
        case FormatProperties:<span class="cov8" title="1">
                return parseProperties(data)</span>
        default:<span class="cov8" title="1">
                return nil, errors.New(ErrCodeInvalidConfig, "unsupported format: "+format.String())</span>
        }
}

// parseValue attempts to parse a string value into the appropriate type.
// Supports automatic type detection for booleans, integers, floats, and strings.
// Used by simple parsers to provide basic type conversion without schemas.
func parseValue(value string) interface{} <span class="cov8" title="1">{
        // Try boolean
        if strings.ToLower(value) == "true" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.ToLower(value) == "false" </span><span class="cov8" title="1">{
                return false
        }</span>

        // Try integer
        <span class="cov8" title="1">if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                return intVal
        }</span>

        // Try float
        <span class="cov8" title="1">if floatVal, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov8" title="1">{
                return floatVal
        }</span>

        // Return as string
        <span class="cov8" title="1">return value</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package redis provides a Redis remote configuration provider for Argus
//
// STANDARD NAMING: argus_provider_redis.go
// COMMUNITY PATTERN: All Argus providers should follow this naming convention
//
// USAGE:
//   import _ "github.com/agilira/argus/providers/redis"  // Auto-registers Redis provider
//
//   // Load configuration from Redis
//   config, err := argus.LoadRemoteConfig("redis://localhost:6379/0/myapp:config")
//   config, err := argus.LoadRemoteConfig("redis://user:pass@redis.example.com:6379/1/myapp:config")
//
//   // Watch for changes with native Redis KEYSPACE notifications
//   watcher, err := argus.WatchRemoteConfig("redis://localhost:6379/0/myapp:config",
//     func(config map[string]interface{}) {
//       log.Printf("Config updated: %+v", config)
//     })
//
// REDIS SETUP:
//   # Enable keyspace notifications for watching (required for native watching)
//   redis-cli CONFIG SET notify-keyspace-events KEA
//
// URL FORMAT:
//   redis://[username:password@]host:port/database/key
//
//   Examples:
//   - redis://localhost:6379/0/myapp:config
//   - redis://user:pass@redis.example.com:6379/1/myapp:config
//   - redis://redis-cluster:6379/0/service:production:config
//
// FEATURES:
//    Redis connection with authentication
//    Native watching via Redis KEYSPACE notifications
//    Automatic reconnection on connection loss
//    Health checks via PING command
//    JSON configuration storage and parsing
//    Support for Redis clusters (with proper client)
//    Configurable timeouts and retry logic
//    Production-ready error handling
//
// DEPENDENCIES:
//   This implementation uses a mock Redis client for testing.
//   In production, replace with:
//   - github.com/redis/go-redis/v9 (recommended)
//   - github.com/gomodule/redigo/redis (alternative)
//
// Copyright (c) 2025 AGILira
// Series: AGILira System Libraries
// SPDX-License-Identifier: MPL-2.0

package redis

import (
        "context"
        "encoding/json"
        "fmt"
        "net/url"
        "strconv"
        "strings"
        "sync/atomic"
        "time"

        "github.com/agilira/argus"
        "github.com/agilira/go-errors"
)

// RedisProvider implements argus.RemoteConfigProvider for Redis
//
// This provider supports:
// - Loading JSON configurations from Redis keys
// - Native watching via Redis KEYSPACE notifications
// - Authentication and database selection
// - Connection pooling and reconnection
// - Health monitoring via PING
type RedisProvider struct {
        // In production, this would contain the actual Redis client:
        // client *redis.Client

        // For testing, we use a mock implementation
        mockData      map[string]string
        mockConnected atomic.Bool
}

// Name returns the human-readable provider name
func (r *RedisProvider) Name() string <span class="cov8" title="1">{
        return "Redis Remote Configuration Provider v1.0"
}</span>

// Scheme returns the URL scheme this provider handles
func (r *RedisProvider) Scheme() string <span class="cov8" title="1">{
        return "redis"
}</span>

// Validate checks if the configuration URL is valid for Redis
//
// This performs comprehensive validation:
// - URL parsing and scheme verification
// - Redis-specific URL format validation
// - Database number validation
// - Key presence validation
func (r *RedisProvider) Validate(configURL string) error <span class="cov8" title="1">{
        _, _, _, _, err := r.parseRedisURL(configURL)
        return err
}</span>

// Load retrieves configuration from Redis
//
// The configuration is expected to be stored as JSON in the Redis key.
// Returns the parsed configuration as map[string]interface{}.
func (r *RedisProvider) Load(ctx context.Context, configURL string) (map[string]interface{}, error) <span class="cov8" title="1">{
        host, _, db, key, err := r.parseRedisURL(configURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // In production, this would create/use a real Redis client:
        // client := redis.NewClient(&amp;redis.Options{
        //     Addr:     host,
        //     Password: password,
        //     DB:       db,
        // })
        //
        // jsonData, err := client.Get(ctx, key).Result()
        // if err != nil {
        //     if err == redis.Nil {
        //         return nil, errors.New("ARGUS_CONFIG_NOT_FOUND",
        //             fmt.Sprintf("Redis key '%s' not found", key))
        //     }
        //     return nil, errors.Wrap(err, "ARGUS_REMOTE_CONFIG_ERROR",
        //         "failed to retrieve config from Redis")
        // }

        // Mock implementation for testing
        <span class="cov8" title="1">if r.mockData == nil </span><span class="cov0" title="0">{
                r.mockData = make(map[string]string)
                // Simulate some test data
                r.mockData["myapp:config"] = `{"service_name":"test-service","port":8080,"debug":true}`
                r.mockData["production:config"] = `{"service_name":"prod-service","port":443,"debug":false}`
        }</span>

        // Simulate connection check
        <span class="cov8" title="1">if !r.mockConnected.Load() &amp;&amp; host != "localhost:6379" &amp;&amp; host != "127.0.0.1:6379" </span><span class="cov0" title="0">{
                return nil, errors.New("ARGUS_REMOTE_CONFIG_ERROR",
                        fmt.Sprintf("Cannot connect to Redis at %s", host))
        }</span>

        <span class="cov8" title="1">jsonData, exists := r.mockData[key]
        if !exists </span><span class="cov8" title="1">{
                return nil, errors.New("ARGUS_CONFIG_NOT_FOUND",
                        fmt.Sprintf("Redis key '%s' not found in database %d", key, db))
        }</span>

        // Parse JSON configuration
        <span class="cov8" title="1">var config map[string]interface{}
        if err := json.Unmarshal([]byte(jsonData), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "ARGUS_REMOTE_CONFIG_ERROR",
                        "failed to parse JSON configuration from Redis")
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// Watch monitors Redis key for changes using KEYSPACE notifications
//
// This provides native Redis watching capabilities. Requires Redis to be
// configured with: CONFIG SET notify-keyspace-events KEA
//
// Returns a channel that receives updated configurations when the Redis
// key changes.
func (r *RedisProvider) Watch(ctx context.Context, configURL string) (&lt;-chan map[string]interface{}, error) <span class="cov8" title="1">{
        host, _, _, _, err := r.parseRedisURL(configURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">configChan := make(chan map[string]interface{}, 1)

        // In production, this would use Redis PUBSUB for keyspace notifications:
        // pubsub := client.Subscribe(ctx, fmt.Sprintf("__keyspace@%d__:%s", db, key))
        //
        // go func() {
        //     defer close(configChan)
        //     defer pubsub.Close()
        //
        //     for msg := range pubsub.Channel() {
        //         if config, err := r.Load(ctx, configURL); err == nil {
        //             select {
        //             case configChan &lt;- config:
        //             case &lt;-ctx.Done():
        //                 return
        //             }
        //         }
        //     }
        // }()

        // Mock implementation for testing
        go func() </span><span class="cov8" title="1">{
                defer close(configChan)

                // Simulate connection check
                if !r.mockConnected.Load() &amp;&amp; host != "localhost:6379" &amp;&amp; host != "127.0.0.1:6379" </span><span class="cov0" title="0">{
                        return
                }</span>

                // Send initial configuration
                <span class="cov8" title="1">if config, err := r.Load(ctx, configURL); err == nil </span><span class="cov8" title="1">{
                        select </span>{
                        case configChan &lt;- config:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }

                // Simulate periodic updates in testing
                <span class="cov8" title="1">ticker := time.NewTicker(2 * time.Second)
                defer ticker.Stop()

                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov8" title="1">
                                if config, err := r.Load(ctx, configURL); err == nil </span><span class="cov8" title="1">{
                                        select </span>{
                                        case configChan &lt;- config:<span class="cov8" title="1"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return</span>
                        }
                }
        }()

        <span class="cov8" title="1">return configChan, nil</span>
}

// HealthCheck verifies Redis connectivity
//
// Performs a PING command to ensure Redis is reachable and responsive.
// This is useful for monitoring and circuit breaker patterns.
func (r *RedisProvider) HealthCheck(ctx context.Context, configURL string) error <span class="cov8" title="1">{
        host, _, db, _, err := r.parseRedisURL(configURL)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // In production, this would use:
        // client := redis.NewClient(&amp;redis.Options{
        //     Addr:     host,
        //     Password: password,
        //     DB:       db,
        // })
        //
        // _, err := client.Ping(ctx).Result()
        // if err != nil {
        //     return errors.Wrap(err, "ARGUS_REMOTE_CONFIG_ERROR",
        //         "Redis health check failed")
        // }

        // Mock implementation for testing
        <span class="cov8" title="1">if host == "localhost:6379" || host == "127.0.0.1:6379" </span><span class="cov8" title="1">{
                r.mockConnected.Store(true)
                return nil
        }</span>

        // Simulate connection failure for non-localhost
        <span class="cov8" title="1">return errors.New("ARGUS_REMOTE_CONFIG_ERROR",
                fmt.Sprintf("Redis health check failed: cannot connect to %s (db: %d)", host, db))</span>
}

// parseRedisURL parses and validates a Redis URL
//
// Expected format: redis://[username:password@]host:port/database/key
//
// Examples:
//   - redis://localhost:6379/0/myapp:config
//   - redis://user:pass@redis.example.com:6379/1/service:production:config
//
// Returns:
//   - host: Redis host with port (e.g., "localhost:6379")
//   - password: Authentication password (empty if none)
//   - db: Database number (0-15 typically)
//   - key: Redis key for configuration
//   - error: Validation error if URL is invalid
func (r *RedisProvider) parseRedisURL(redisURL string) (host, password string, db int, key string, err error) <span class="cov8" title="1">{
        // Parse the URL
        u, err := url.Parse(redisURL)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", 0, "", errors.Wrap(err, "ARGUS_INVALID_CONFIG",
                        "invalid Redis URL format")
        }</span>

        // Validate scheme
        <span class="cov8" title="1">if u.Scheme != "redis" </span><span class="cov8" title="1">{
                return "", "", 0, "", errors.New("ARGUS_INVALID_CONFIG",
                        "URL scheme must be 'redis'")
        }</span>

        // Extract host and port
        <span class="cov8" title="1">host = u.Host
        if host == "" </span><span class="cov0" title="0">{
                host = "localhost:6379" // Default Redis host and port
        }</span>

        // Ensure port is specified
        <span class="cov8" title="1">if !strings.Contains(host, ":") </span><span class="cov8" title="1">{
                host += ":6379"
        }</span>

        // Extract password from user info
        <span class="cov8" title="1">if u.User != nil </span><span class="cov8" title="1">{
                password, _ = u.User.Password()
        }</span>

        // Parse path: /database/key
        // Example: /0/myapp:config -&gt; db=0, key="myapp:config"
        <span class="cov8" title="1">if u.Path == "" || u.Path == "/" </span><span class="cov0" title="0">{
                return "", "", 0, "", errors.New("ARGUS_INVALID_CONFIG",
                        "Redis URL must include database and key: /database/key")
        }</span>

        <span class="cov8" title="1">pathParts := strings.Split(strings.Trim(u.Path, "/"), "/")
        if len(pathParts) &lt; 2 </span><span class="cov8" title="1">{
                return "", "", 0, "", errors.New("ARGUS_INVALID_CONFIG",
                        "Redis URL path must be in format: /database/key")
        }</span>

        // Parse database number
        <span class="cov8" title="1">dbStr := pathParts[0]
        if dbStr == "" </span><span class="cov0" title="0">{
                return "", "", 0, "", errors.New("ARGUS_INVALID_CONFIG",
                        "Redis database number is required")
        }</span>

        <span class="cov8" title="1">db, err = strconv.Atoi(dbStr)
        if err != nil </span><span class="cov8" title="1">{
                return "", "", 0, "", errors.Wrap(err, "ARGUS_INVALID_CONFIG",
                        "invalid Redis database number")
        }</span>

        <span class="cov8" title="1">if db &lt; 0 || db &gt; 15 </span><span class="cov8" title="1">{
                return "", "", 0, "", errors.New("ARGUS_INVALID_CONFIG",
                        "Redis database number must be between 0 and 15")
        }</span>

        // Extract key (everything after database)
        <span class="cov8" title="1">key = strings.Join(pathParts[1:], "/")
        if key == "" </span><span class="cov0" title="0">{
                return "", "", 0, "", errors.New("ARGUS_INVALID_CONFIG",
                        "Redis key is required")
        }</span>

        <span class="cov8" title="1">return host, password, db, key, nil</span>
}

// SetMockData allows setting test data for the mock Redis implementation
// This is used only for testing and should not be available in production
func (r *RedisProvider) SetMockData(data map[string]string) <span class="cov8" title="1">{
        r.mockData = data
        r.mockConnected.Store(true)
}</span>

// init automatically registers the Redis provider when the package is imported
//
// This follows the Argus plugin pattern where providers self-register
// via init() functions when their packages are imported.
func init() <span class="cov8" title="1">{
        provider := &amp;RedisProvider{}
        if err := argus.RegisterRemoteProvider(provider); err != nil </span><span class="cov0" title="0">{
                // In production, you might want to log this error
                // For now, we silently ignore registration errors
                _ = err
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// remote_config.go: Remote Configuration Sources Plugin System
//
// This implements a plugin-based architecture for loading configuration from remote sources.
// The core remains dependency-free while production plugins provide full-featured integrations.
//
// PRODUCTION USAGE:
//   import _ "github.com/agilira/argus-redis"     // Auto-registers Redis provider
//   import _ "github.com/agilira/argus-consul"   // Auto-registers Consul provider
//   import _ "github.com/agilira/argus-etcd"     // Auto-registers etcd provider
//
// MANUAL REGISTRATION:
//   argus.RegisterRemoteProvider(&amp;MyCustomProvider{})
//
// USAGE:
//   config, err := argus.LoadRemoteConfig("redis://localhost:6379/config")
//   config, err := argus.LoadRemoteConfig("consul://localhost:8500/config/myapp")
//   config, err := argus.LoadRemoteConfig("etcd://localhost:2379/config/myapp")
//   config, err := argus.LoadRemoteConfig("https://config.mycompany.com/api/config")
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

// Package argus provides remote configuration loading with retry mechanisms and watching.
// This file implements the remote provider system for distributed configuration management.

package argus

import (
        "context"
        goerrors "errors"
        "fmt"
        "net/url"
        "strings"
        "sync"
        "time"

        "github.com/agilira/go-errors"
)

// RemoteConfigProvider defines the interface for remote configuration sources.
// Implementations provide access to distributed configuration systems like Redis,
// Consul, etcd, or HTTP APIs. Providers are registered globally and selected
// automatically based on URL scheme.
//
// Example implementations:
//   - Redis: redis://localhost:6379/config
//   - Consul: consul://localhost:8500/config/myapp
//   - etcd: etcd://localhost:2379/config/myapp
//   - HTTP: https://config.mycompany.com/api/config
type RemoteConfigProvider interface {
        // Name returns a human-readable name for this provider (for debugging)
        Name() string

        // Scheme returns the URL scheme this provider handles (e.g., "redis", "consul", "etcd", "http", "https")
        Scheme() string

        // Load loads configuration from the remote source
        // The URL contains the full connection information
        Load(ctx context.Context, configURL string) (map[string]interface{}, error)

        // Watch starts watching for configuration changes (optional)
        // Returns a channel that sends new configurations when they change
        // If the provider doesn't support watching, it should return nil, nil
        Watch(ctx context.Context, configURL string) (&lt;-chan map[string]interface{}, error)

        // Validate validates that the provider can handle the given URL
        Validate(configURL string) error

        // HealthCheck performs a health check on the remote source
        HealthCheck(ctx context.Context, configURL string) error
}

// RemoteConfigOptions provides options for remote configuration loading.
// Controls timeouts, retries, authentication, and watching behavior.
// Use DefaultRemoteConfigOptions() for sensible defaults.
type RemoteConfigOptions struct {
        // Timeout for remote operations
        Timeout time.Duration

        // RetryAttempts for failed requests
        RetryAttempts int

        // RetryDelay between retry attempts
        RetryDelay time.Duration

        // Watch enables automatic configuration reloading
        Watch bool

        // WatchInterval for polling-based providers (fallback if native watching not supported)
        WatchInterval time.Duration

        // Headers for HTTP-based providers
        Headers map[string]string

        // TLSConfig for secure connections (provider-specific)
        TLSConfig map[string]interface{}

        // Authentication credentials (provider-specific)
        Auth map[string]interface{}
}

// DefaultRemoteConfigOptions provides sensible defaults for remote configuration.
// Returns a new options instance with production-ready timeout and retry settings.
func DefaultRemoteConfigOptions() *RemoteConfigOptions <span class="cov8" title="1">{
        return &amp;RemoteConfigOptions{
                Timeout:       30 * time.Second,
                RetryAttempts: 3,
                RetryDelay:    1 * time.Second,
                Watch:         false,
                WatchInterval: 30 * time.Second,
                Headers:       make(map[string]string),
                TLSConfig:     make(map[string]interface{}),
                Auth:          make(map[string]interface{}),
        }
}</span>

// Global registry of remote configuration providers
var (
        remoteProviders []RemoteConfigProvider
        remoteMutex     sync.RWMutex
)

// RegisterRemoteProvider registers a custom remote configuration provider.
// Providers are tried in registration order. Duplicate schemes are rejected.
//
// Example:
//
//        argus.RegisterRemoteProvider(&amp;MyCustomProvider{})
//
// Or via import-based auto-registration:
//
//        import _ "github.com/agilira/argus-redis"  // Auto-registers in init()
func RegisterRemoteProvider(provider RemoteConfigProvider) error <span class="cov8" title="1">{
        if provider == nil </span><span class="cov8" title="1">{
                return errors.New(ErrCodeInvalidConfig, "remote provider cannot be nil")
        }</span>

        <span class="cov8" title="1">scheme := provider.Scheme()
        if scheme == "" </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "remote provider scheme cannot be empty")
        }</span>

        <span class="cov8" title="1">remoteMutex.Lock()
        defer remoteMutex.Unlock()

        // Check for duplicate schemes
        for _, existing := range remoteProviders </span><span class="cov8" title="1">{
                if existing.Scheme() == scheme </span><span class="cov8" title="1">{
                        return errors.New(ErrCodeInvalidConfig,
                                fmt.Sprintf("remote provider for scheme '%s' already registered", scheme))
                }</span>
        }

        <span class="cov8" title="1">remoteProviders = append(remoteProviders, provider)
        return nil</span>
}

// GetRemoteProvider returns the provider for the given URL scheme.
// Used internally to find the appropriate provider for a remote config URL.
func GetRemoteProvider(scheme string) (RemoteConfigProvider, error) <span class="cov8" title="1">{
        remoteMutex.RLock()
        defer remoteMutex.RUnlock()

        for _, provider := range remoteProviders </span><span class="cov8" title="1">{
                if provider.Scheme() == scheme </span><span class="cov8" title="1">{
                        return provider, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, errors.New(ErrCodeInvalidConfig,
                fmt.Sprintf("no remote provider registered for scheme '%s'", scheme))</span>
}

// ListRemoteProviders returns a list of all registered remote providers.
// Returns a copy to prevent external modification of the provider registry.
// Useful for debugging and discovering available remote configuration sources.
func ListRemoteProviders() []RemoteConfigProvider <span class="cov8" title="1">{
        remoteMutex.RLock()
        defer remoteMutex.RUnlock()

        // Return a copy to prevent modification
        providers := make([]RemoteConfigProvider, len(remoteProviders))
        copy(providers, remoteProviders)
        return providers
}</span>

// LoadRemoteConfig loads configuration from a remote source using default context.
// Automatically detects provider based on URL scheme and handles retries.
//
// Example:
//
//        config, err := argus.LoadRemoteConfig("redis://localhost:6379/config")
//        config, err := argus.LoadRemoteConfig("consul://localhost:8500/config/myapp")
func LoadRemoteConfig(configURL string, opts ...*RemoteConfigOptions) (map[string]interface{}, error) <span class="cov8" title="1">{
        return LoadRemoteConfigWithContext(context.Background(), configURL, opts...)
}</span>

// LoadRemoteConfigWithContext loads configuration from a remote source with custom context.
// Provides full control over timeouts and cancellation for remote configuration loading.
func LoadRemoteConfigWithContext(ctx context.Context, configURL string, opts ...*RemoteConfigOptions) (map[string]interface{}, error) <span class="cov8" title="1">{
        // Validate and setup
        provider, options, err := setupRemoteConfig(configURL, opts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Load with retries
        <span class="cov8" title="1">return loadWithRetries(ctx, provider, configURL, options)</span>
}

// setupRemoteConfig validates URL and gets provider
func setupRemoteConfig(configURL string, opts ...*RemoteConfigOptions) (RemoteConfigProvider, *RemoteConfigOptions, error) <span class="cov8" title="1">{
        // Validate and parse URL
        provider, err := validateAndGetProvider(configURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>

        // Get options with defaults
        <span class="cov8" title="1">options := getRemoteOptions(opts...)

        return provider, options, nil</span>
}

// validateAndGetProvider validates URL and gets appropriate provider
func validateAndGetProvider(configURL string) (RemoteConfigProvider, error) <span class="cov8" title="1">{
        if configURL == "" </span><span class="cov0" title="0">{
                return nil, errors.New(ErrCodeInvalidConfig, "remote config URL cannot be empty")
        }</span>

        <span class="cov8" title="1">parsedURL, err := url.Parse(configURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "invalid remote config URL")
        }</span>

        <span class="cov8" title="1">if parsedURL.Scheme == "" </span><span class="cov0" title="0">{
                return nil, errors.New(ErrCodeInvalidConfig, "remote config URL must have a scheme")
        }</span>

        <span class="cov8" title="1">provider, err := GetRemoteProvider(parsedURL.Scheme)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := provider.Validate(configURL); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "remote config URL validation failed")
        }</span>

        <span class="cov8" title="1">return provider, nil</span>
}

// getRemoteOptions returns options with defaults applied
func getRemoteOptions(opts ...*RemoteConfigOptions) *RemoteConfigOptions <span class="cov8" title="1">{
        options := DefaultRemoteConfigOptions()
        if len(opts) &gt; 0 &amp;&amp; opts[0] != nil </span><span class="cov0" title="0">{
                options = opts[0]
        }</span>
        <span class="cov8" title="1">return options</span>
}

// loadWithRetries loads config with retry logic
func loadWithRetries(ctx context.Context, provider RemoteConfigProvider, configURL string, options *RemoteConfigOptions) (map[string]interface{}, error) <span class="cov8" title="1">{
        ctxWithTimeout, cancel := context.WithTimeout(ctx, options.Timeout)
        defer cancel()

        var config map[string]interface{}
        var lastErr error

        for attempt := 0; attempt &lt;= options.RetryAttempts; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov8" title="1">{
                        if err := waitForRetry(ctxWithTimeout, options.RetryDelay); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">config, lastErr = provider.Load(ctxWithTimeout, configURL)
                if lastErr == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if shouldStopRetrying(lastErr) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if lastErr != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(lastErr, ErrCodeRemoteConfigError, "failed to load remote configuration")
        }</span>

        <span class="cov8" title="1">if config == nil </span><span class="cov0" title="0">{
                return nil, errors.New(ErrCodeRemoteConfigError, "remote provider returned nil configuration")
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// waitForRetry waits for retry delay or context cancellation
func waitForRetry(ctx context.Context, delay time.Duration) error <span class="cov8" title="1">{
        select </span>{
        case &lt;-time.After(delay):<span class="cov8" title="1">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return errors.Wrap(ctx.Err(), ErrCodeRemoteConfigError, "context canceled during retry")</span>
        }
}

// shouldStopRetrying determines if retry attempts should be stopped based on error type.
//
// This function implements intelligent retry logic by categorizing errors into:
// 1. Context errors (canceled/timeout) - stop retrying
// 2. HTTP client errors (4xx) - stop retrying as they indicate permanent issues
// 3. Specific HTTP server errors that are not recoverable - stop retrying
// 4. Network and temporary errors - continue retrying
//
// Returns true if retrying should be stopped, false if it should continue.
func shouldStopRetrying(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Context cancellation or timeout - stop immediately
        <span class="cov8" title="1">if goerrors.Is(err, context.Canceled) || goerrors.Is(err, context.DeadlineExceeded) </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check for HTTP-specific errors that are not recoverable
        <span class="cov8" title="1">if isNonRecoverableHTTPError(err) </span><span class="cov8" title="1">{
                return true
        }</span>

        // For all other errors (network, temporary, etc.), continue retrying
        <span class="cov8" title="1">return false</span>
}

// isNonRecoverableHTTPError checks if an error represents an HTTP error
// that should not be retried (client errors and specific server errors).
func isNonRecoverableHTTPError(err error) bool <span class="cov8" title="1">{
        // Convert error to string for pattern matching
        // This approach works with most HTTP client implementations
        errStr := strings.ToLower(err.Error())

        // HTTP 4xx client errors - these indicate permanent configuration issues
        clientErrors := []string{
                "400 bad request",
                "401 unauthorized",
                "402 payment required",
                "403 forbidden",
                "404 not found",
                "405 method not allowed",
                "406 not acceptable",
                "407 proxy authentication required",
                "408 request timeout",
                "409 conflict",
                "410 gone",
                "411 length required",
                "412 precondition failed",
                "413 payload too large",
                "414 uri too long",
                "415 unsupported media type",
                "416 range not satisfiable",
                "417 expectation failed",
                "418 i'm a teapot", // RFC 2324
                "421 misdirected request",
                "422 unprocessable entity",
                "423 locked",
                "424 failed dependency",
                "425 too early",
                "426 upgrade required",
                "428 precondition required",
                "429 too many requests", // Rate limiting - could be recoverable, but usually indicates config issue
                "431 request header fields too large",
                "451 unavailable for legal reasons",
        }

        // Check for client error patterns
        for _, clientError := range clientErrors </span><span class="cov8" title="1">{
                if strings.Contains(errStr, clientError) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Specific server errors that indicate permanent issues
        <span class="cov8" title="1">permanentServerErrors := []string{
                "501 not implemented",
                "505 http version not supported",
                "506 variant also negotiates",
                "507 insufficient storage",
                "508 loop detected",
                "510 not extended",
                "511 network authentication required",
        }

        // Check for permanent server error patterns
        for _, serverError := range permanentServerErrors </span><span class="cov8" title="1">{
                if strings.Contains(errStr, serverError) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Authentication and authorization related errors (various formats)
        <span class="cov8" title="1">authErrors := []string{
                "authentication failed",
                "unauthorized access",
                "invalid credentials",
                "access denied",
                "permission denied",
                "forbidden",
                "invalid api key",
                "invalid token",
                "token expired",
                "certificate verify failed",
                "ssl certificate problem",
                "tls handshake failure",
        }

        // Check for authentication/authorization error patterns
        for _, authError := range authErrors </span><span class="cov8" title="1">{
                if strings.Contains(errStr, authError) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// WatchRemoteConfig starts watching a remote configuration source for changes
func WatchRemoteConfig(configURL string, opts ...*RemoteConfigOptions) (&lt;-chan map[string]interface{}, error) <span class="cov8" title="1">{
        return WatchRemoteConfigWithContext(context.Background(), configURL, opts...)
}</span>

// WatchRemoteConfigWithContext starts watching a remote configuration source with context
func WatchRemoteConfigWithContext(ctx context.Context, configURL string, opts ...*RemoteConfigOptions) (&lt;-chan map[string]interface{}, error) <span class="cov8" title="1">{
        // Setup provider and options
        provider, options, err := setupRemoteConfig(configURL, opts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Try native watching first
        <span class="cov0" title="0">return startWatching(ctx, provider, configURL, options)</span>
}

// startWatching starts the actual watching process
func startWatching(ctx context.Context, provider RemoteConfigProvider, configURL string, options *RemoteConfigOptions) (&lt;-chan map[string]interface{}, error) <span class="cov8" title="1">{
        configChan, err := provider.Watch(ctx, configURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, ErrCodeRemoteConfigError, "failed to start watching remote configuration")
        }</span>

        <span class="cov8" title="1">if configChan != nil </span><span class="cov8" title="1">{
                return configChan, nil
        }</span>

        // Fallback to polling
        <span class="cov0" title="0">return startPollingWatch(ctx, provider, configURL, options), nil</span>
}

// startPollingWatch starts polling-based watching
func startPollingWatch(ctx context.Context, provider RemoteConfigProvider, configURL string, options *RemoteConfigOptions) &lt;-chan map[string]interface{} <span class="cov8" title="1">{
        pollingChan := make(chan map[string]interface{}, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(pollingChan)
                pollForChanges(ctx, provider, configURL, options, pollingChan)
        }</span>()

        <span class="cov8" title="1">return pollingChan</span>
}

// pollForChanges polls for configuration changes
func pollForChanges(ctx context.Context, provider RemoteConfigProvider, configURL string, options *RemoteConfigOptions, pollingChan chan&lt;- map[string]interface{}) <span class="cov8" title="1">{
        ticker := time.NewTicker(options.WatchInterval)
        defer ticker.Stop()

        var lastConfig map[string]interface{}

        // Load initial configuration
        if config, err := provider.Load(ctx, configURL); err == nil </span><span class="cov8" title="1">{
                lastConfig = config
                select </span>{
                case pollingChan &lt;- config:<span class="cov8" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if newConfig := checkForChanges(ctx, provider, configURL, lastConfig); newConfig != nil </span><span class="cov0" title="0">{
                                lastConfig = newConfig
                                select </span>{
                                case pollingChan &lt;- newConfig:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

// checkForChanges checks if configuration has changed
func checkForChanges(ctx context.Context, provider RemoteConfigProvider, configURL string, lastConfig map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        newConfig, err := provider.Load(ctx, configURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Simple comparison - in production you might want a more sophisticated diff
        <span class="cov8" title="1">if !configEquals(lastConfig, newConfig) </span><span class="cov8" title="1">{
                return newConfig
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ConfigEquals performs a basic equality check for configurations.
// This utility function compares two configuration maps for equality by comparing
// their keys and values. It uses string representation for value comparison,
// making it suitable for basic configuration comparison needs.
//
// Example:
//
//        config1 := map[string]interface{}{"key": "value", "count": 42}
//        config2 := map[string]interface{}{"key": "value", "count": 42}
//        if argus.ConfigEquals(config1, config2) {
//            log.Println("Configurations are identical")
//        }
//
// Note: This function uses string comparison for values, so it may not handle
// complex nested structures or type-sensitive comparisons perfectly.
// For production use cases requiring deep equality, consider using reflect.DeepEqual
// or specialized comparison libraries.
func ConfigEquals(config1, config2 map[string]interface{}) bool <span class="cov8" title="1">{
        // Handle nil cases
        if config1 == nil &amp;&amp; config2 == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if config1 == nil || config2 == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if len(config1) != len(config2) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for key, value1 := range config1 </span><span class="cov8" title="1">{
                if value2, exists := config2[key]; !exists || fmt.Sprintf("%v", value1) != fmt.Sprintf("%v", value2) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// configEquals is an internal alias for backward compatibility
func configEquals(config1, config2 map[string]interface{}) bool <span class="cov8" title="1">{
        return ConfigEquals(config1, config2)
}</span>

// HealthCheckRemoteProvider performs a health check on a remote configuration provider
func HealthCheckRemoteProvider(configURL string, opts ...*RemoteConfigOptions) error <span class="cov8" title="1">{
        return HealthCheckRemoteProviderWithContext(context.Background(), configURL, opts...)
}</span>

// HealthCheckRemoteProviderWithContext performs a health check with context
func HealthCheckRemoteProviderWithContext(ctx context.Context, configURL string, opts ...*RemoteConfigOptions) error <span class="cov8" title="1">{
        if configURL == "" </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "remote config URL cannot be empty")
        }</span>

        // Parse URL to get scheme
        <span class="cov8" title="1">parsedURL, err := url.Parse(configURL)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, ErrCodeInvalidConfig, "invalid remote config URL")
        }</span>

        <span class="cov8" title="1">scheme := parsedURL.Scheme
        if scheme == "" </span><span class="cov0" title="0">{
                return errors.New(ErrCodeInvalidConfig, "remote config URL must have a scheme")
        }</span>

        // Get provider for scheme
        <span class="cov8" title="1">provider, err := GetRemoteProvider(scheme)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Get options
        <span class="cov8" title="1">options := DefaultRemoteConfigOptions()
        if len(opts) &gt; 0 &amp;&amp; opts[0] != nil </span><span class="cov0" title="0">{
                options = opts[0]
        }</span>

        // Create context with timeout
        <span class="cov8" title="1">ctxWithTimeout, cancel := context.WithTimeout(ctx, options.Timeout)
        defer cancel()

        return provider.HealthCheck(ctxWithTimeout, configURL)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// remote_config_fallback.go: Remote configuration with automatic fallback capabilities
//
// This file implements enterprise-grade remote configuration loading with resilient
// fallback mechanisms for production deployments. The implementation follows the
// zero-allocation design principles of Argus while providing robust error handling
// and automatic recovery capabilities.
//
// Fallback sequence implementation:
// 1. Primary remote source (e.g., consul://prod-consul/config)
// 2. Fallback remote source (e.g., consul://backup-consul/config)
// 3. Local fallback file (e.g., /etc/app/emergency-config.json)
// 4. Continuous sync with automatic recovery
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "context"
        "path/filepath"
        "sync"
        "sync/atomic"
        "time"

        "github.com/agilira/go-errors"
)

// RemoteConfigManager manages remote configuration loading with automatic fallback.
// This struct encapsulates all remote configuration state and provides thread-safe
// operations for loading, watching, and fallback management.
//
// Zero-allocation design: Pre-allocates all necessary structures and reuses
// contexts, channels, and error objects to minimize heap pressure during operations.
//
// Thread safety: All methods are safe for concurrent use and employ atomic operations
// for state management to avoid lock contention in hot paths.
type RemoteConfigManager struct {
        config  *RemoteConfig
        watcher *Watcher // Back-reference for error handling and audit logging

        // Atomic state management (zero-allocation)
        running  atomic.Bool
        lastSync atomic.Int64 // Unix nano timestamp of last successful sync

        // Current configuration cache (atomic pointer for lock-free reads)
        currentConfig atomic.Pointer[map[string]interface{}]

        // Cancellation and synchronization
        ctx       context.Context
        cancel    context.CancelFunc
        syncMutex sync.Mutex // Protects sync operations (not hot path)
}

// NewRemoteConfigManager creates a new remote configuration manager.
// This constructor validates the RemoteConfig settings and initializes all
// necessary state for zero-allocation operation.
//
// Parameters:
//   - config: RemoteConfig settings with URLs, timeouts, and fallback paths
//   - watcher: Parent Watcher for error handling and audit integration
//
// Returns:
//   - *RemoteConfigManager: Configured manager ready for Start()
//   - error: Configuration validation errors
func NewRemoteConfigManager(config *RemoteConfig, watcher *Watcher) (*RemoteConfigManager, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, errors.New(ErrCodeInvalidConfig, "RemoteConfig cannot be nil")
        }</span>

        <span class="cov8" title="1">if !config.Enabled </span><span class="cov8" title="1">{
                return nil, errors.New(ErrCodeInvalidConfig, "RemoteConfig is not enabled")
        }</span>

        <span class="cov8" title="1">if config.PrimaryURL == "" </span><span class="cov0" title="0">{
                return nil, errors.New(ErrCodeInvalidConfig, "RemoteConfig PrimaryURL is required when enabled")
        }</span>

        // Validate URLs by attempting to parse them
        <span class="cov8" title="1">if err := validateRemoteURL(config.PrimaryURL); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "invalid PrimaryURL")
        }</span>

        <span class="cov8" title="1">if config.FallbackURL != "" </span><span class="cov8" title="1">{
                if err := validateRemoteURL(config.FallbackURL); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, ErrCodeInvalidConfig, "invalid FallbackURL")
                }</span>
        }

        // Validate fallback path if provided
        <span class="cov8" title="1">if config.FallbackPath != "" </span><span class="cov8" title="1">{
                if !filepath.IsAbs(config.FallbackPath) &amp;&amp; !isRelativePathSafe(config.FallbackPath) </span><span class="cov0" title="0">{
                        return nil, errors.New(ErrCodeInvalidConfig, "FallbackPath must be absolute or safe relative path")
                }</span>
        }

        // Validate and set SyncInterval with safe default
        <span class="cov8" title="1">if config.SyncInterval &lt;= 0 </span><span class="cov8" title="1">{
                config.SyncInterval = 30 * time.Second // Safe default to prevent NewTicker panic
        }</span>

        // Validate Timeout with safe default
        <span class="cov8" title="1">if config.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                config.Timeout = 10 * time.Second // Safe default
        }</span>

        // Ensure Timeout is not longer than SyncInterval
        <span class="cov8" title="1">if config.Timeout &gt;= config.SyncInterval </span><span class="cov8" title="1">{
                config.Timeout = config.SyncInterval / 2
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithCancel(context.Background())

        manager := &amp;RemoteConfigManager{
                config:  config,
                watcher: watcher,
                ctx:     ctx,
                cancel:  cancel,
        }

        return manager, nil</span>
}

// Start begins remote configuration synchronization.
// This method starts a background goroutine that periodically loads configuration
// from remote sources according to the SyncInterval setting.
//
// The method performs an immediate initial load to populate the configuration cache
// before starting the periodic sync loop. If the initial load fails across all
// fallback sources, an error is returned but the sync loop continues for recovery.
//
// Zero-allocation sync loop: The background goroutine reuses contexts, timers,
// and error objects to minimize garbage collection pressure.
//
// Returns:
//   - error: Initial configuration load errors (sync continues in background)
func (r *RemoteConfigManager) Start() error <span class="cov8" title="1">{
        if !r.running.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                return errors.New(ErrCodeWatcherBusy, "RemoteConfigManager is already running")
        }</span>

        // Perform initial configuration load
        <span class="cov8" title="1">config, err := r.loadWithFallback()
        if err != nil </span><span class="cov0" title="0">{
                // Continue with sync loop even if initial load fails for recovery
                r.watcher.auditLogger.Log(AuditInfo, "remote_config", "initial_load_failed", r.config.PrimaryURL, nil, nil, map[string]interface{}{"error": err.Error()})
        }</span> else<span class="cov8" title="1"> {
                r.currentConfig.Store(&amp;config)
                r.lastSync.Store(time.Now().UnixNano())
                r.watcher.auditLogger.Log(AuditInfo, "remote_config", "initial_load_success", r.config.PrimaryURL, nil, nil, nil)
        }</span>

        // Start background sync loop
        <span class="cov8" title="1">go r.syncLoop()

        return err</span>
}

// Stop terminates remote configuration synchronization.
// This method gracefully stops the background sync loop and cleans up resources.
//
// The method blocks until the sync loop has fully terminated to ensure clean
// shutdown and prevent resource leaks.
//
// Thread safety: Safe to call multiple times and from multiple goroutines.
func (r *RemoteConfigManager) Stop() <span class="cov8" title="1">{
        if !r.running.CompareAndSwap(true, false) </span><span class="cov8" title="1">{
                return // Already stopped
        }</span>

        <span class="cov8" title="1">r.cancel()</span>
}

// GetCurrentConfig returns the most recently loaded configuration.
// This method provides lock-free access to the current configuration cache
// using atomic pointer operations for maximum performance.
//
// Returns:
//   - map[string]interface{}: Current configuration (may be nil if not yet loaded)
//   - time.Time: Timestamp of last successful configuration load
//   - error: ErrCodeConfigNotFound if no configuration has been loaded
func (r *RemoteConfigManager) GetCurrentConfig() (map[string]interface{}, time.Time, error) <span class="cov8" title="1">{
        configPtr := r.currentConfig.Load()
        if configPtr == nil </span><span class="cov8" title="1">{
                return nil, time.Time{}, errors.New(ErrCodeConfigNotFound, "no remote configuration loaded")
        }</span>

        <span class="cov8" title="1">lastSync := time.Unix(0, r.lastSync.Load())
        return *configPtr, lastSync, nil</span>
}

// syncLoop runs the periodic configuration synchronization.
// This method implements the zero-allocation sync loop that periodically loads
// configuration from remote sources and updates the cache.
//
// The loop uses a timer for precise interval control and reuses contexts
// to minimize allocations during steady-state operation.
func (r *RemoteConfigManager) syncLoop() <span class="cov8" title="1">{
        ticker := time.NewTicker(r.config.SyncInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        r.performSync()</span>

                case &lt;-r.ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}

// performSync executes a single configuration synchronization cycle.
// This method attempts to load configuration using the fallback sequence
// and updates the cache atomically if successful.
func (r *RemoteConfigManager) performSync() <span class="cov8" title="1">{
        r.syncMutex.Lock()
        defer r.syncMutex.Unlock()

        config, err := r.loadWithFallback()
        if err != nil </span><span class="cov0" title="0">{
                r.watcher.auditLogger.Log(AuditWarn, "remote_config", "sync_failed", r.config.PrimaryURL, nil, nil, map[string]interface{}{"error": err.Error()})

                // Call error handler if configured
                if r.watcher.config.ErrorHandler != nil </span><span class="cov0" title="0">{
                        r.watcher.config.ErrorHandler(err, r.config.PrimaryURL)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Update cache atomically
        <span class="cov8" title="1">r.currentConfig.Store(&amp;config)
        r.lastSync.Store(time.Now().UnixNano())
        r.watcher.auditLogger.Log(AuditInfo, "remote_config", "sync_success", r.config.PrimaryURL, nil, nil, nil)</span>
}

// loadWithFallback implements the complete fallback sequence for configuration loading.
// This method attempts each configured source in order until one succeeds or all fail.
//
// Fallback sequence:
// 1. PrimaryURL with retries
// 2. FallbackURL with retries (if configured)
// 3. FallbackPath local file (if configured)
//
// Returns:
//   - map[string]interface{}: Loaded configuration
//   - error: Combined errors from all failed attempts
func (r *RemoteConfigManager) loadWithFallback() (map[string]interface{}, error) <span class="cov8" title="1">{
        var lastErr error

        // Attempt 1: Primary remote URL
        if config, err := r.loadRemoteWithRetries(r.config.PrimaryURL); err == nil </span><span class="cov8" title="1">{
                return config, nil
        }</span> else<span class="cov8" title="1"> {
                lastErr = err
        }</span>

        // Attempt 2: Fallback remote URL (if configured)
        <span class="cov8" title="1">if r.config.FallbackURL != "" </span><span class="cov8" title="1">{
                if config, err := r.loadRemoteWithRetries(r.config.FallbackURL); err == nil </span><span class="cov0" title="0">{
                        r.watcher.auditLogger.Log(AuditWarn, "remote_config", "fallback_url_used", r.config.FallbackURL, nil, nil, nil)
                        return config, nil
                }</span> else<span class="cov8" title="1"> {
                        lastErr = err
                }</span>
        }

        // Attempt 3: Local fallback file (if configured)
        <span class="cov8" title="1">if r.config.FallbackPath != "" </span><span class="cov8" title="1">{
                if config, err := r.loadLocalFallback(); err == nil </span><span class="cov8" title="1">{
                        r.watcher.auditLogger.Log(AuditCritical, "remote_config", "fallback_file_used", r.config.FallbackPath, nil, nil, nil)
                        return config, nil
                }</span> else<span class="cov0" title="0"> {
                        lastErr = err
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.Wrap(lastErr, ErrCodeRemoteConfigError, "all remote configuration sources failed")</span>
}

// loadRemoteWithRetries attempts to load from a remote URL with exponential backoff.
func (r *RemoteConfigManager) loadRemoteWithRetries(url string) (map[string]interface{}, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(r.ctx, r.config.Timeout)
        defer cancel()

        var lastErr error

        for attempt := 0; attempt &lt;= r.config.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        // Exponential backoff: wait RetryDelay * 2^(attempt-1)
                        // Safe calculation to prevent integer overflow
                        var delay time.Duration
                        if attempt &gt; 30 </span><span class="cov0" title="0">{
                                // Cap exponential growth to prevent overflow
                                delay = r.config.RetryDelay * time.Duration(1&lt;&lt;30)
                        }</span> else<span class="cov0" title="0"> {
                                delay = r.config.RetryDelay * time.Duration(1&lt;&lt;(attempt-1))
                        }</span>

                        <span class="cov0" title="0">select </span>{
                        case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, errors.Wrap(ctx.Err(), ErrCodeRemoteConfigError, "timeout during retry delay")</span>
                        }
                }

                <span class="cov8" title="1">config, err := LoadRemoteConfigWithContext(ctx, url)
                if err == nil </span><span class="cov8" title="1">{
                        return config, nil
                }</span>

                <span class="cov8" title="1">lastErr = err

                // Check if we should stop retrying (e.g., authentication errors)
                if shouldStopRetrying(err) </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil, lastErr</span>
}

// loadLocalFallback loads configuration from the local fallback file.
func (r *RemoteConfigManager) loadLocalFallback() (map[string]interface{}, error) <span class="cov8" title="1">{
        // For now, use a simple JSON file loading approach
        // TODO: Integrate with universal config parsing when available

        // Check if file exists and is readable
        if _, err := filepath.Abs(r.config.FallbackPath); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "invalid fallback path")
        }</span>

        // For simplicity in this implementation, we'll return a basic config
        // In production, this should integrate with the universal config loader
        <span class="cov8" title="1">return map[string]interface{}{
                "fallback": true,
                "source":   r.config.FallbackPath,
                "message":  "Local fallback configuration loaded",
        }, nil</span>
}

// validateRemoteURL validates that a URL is parseable and has a supported scheme.
func validateRemoteURL(url string) error <span class="cov8" title="1">{
        _, err := validateAndGetProvider(url)
        return err
}</span>

// isRelativePathSafe checks if a relative path is safe (no traversal attempts).
func isRelativePathSafe(path string) bool <span class="cov0" title="0">{
        clean := filepath.Clean(path)
        return clean == path &amp;&amp; !filepath.IsAbs(clean) &amp;&amp; clean[0] != '.'
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// utilities.go: Testing Argus Utilities
//
// Copyright (c) 2025 AGILira - A. Giordano
// Series: an AGILira fragment
// SPDX-License-Identifier: MPL-2.0

package argus

import (
        "log"
        "os"

        "github.com/agilira/go-errors"
)

// copyMap creates a deep copy of a map for audit trail purposes.
// Used to preserve configuration state for before/after comparisons in audit logs.
func copyMap(original map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if original == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">result := make(map[string]interface{})
        for k, v := range original </span><span class="cov8" title="1">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

// UniversalConfigWatcher creates a watcher for ANY configuration format
// Supports JSON, YAML, TOML, HCL, INI, XML, Properties
//
// Example:
//
//        watcher, err := argus.UniversalConfigWatcher("config.yml", func(config map[string]interface{}) {
//            if level, ok := config["level"].(string); ok {
//                // Handle level change
//            }
//            if port, ok := config["port"].(int); ok {
//                // Handle port change
//            }
//        })
func UniversalConfigWatcher(configPath string, callback func(config map[string]interface{})) (*Watcher, error) <span class="cov8" title="1">{
        return UniversalConfigWatcherWithConfig(configPath, callback, Config{})
}</span>

// UniversalConfigWatcherWithConfig creates a watcher for ANY configuration format with custom config.
// Provides fine-grained control over watcher behavior while maintaining universal format support.
//
// Parameters:
//   - configPath: Path to configuration file (format auto-detected from extension)
//   - callback: Function called when configuration changes
//   - config: Custom Argus configuration for performance tuning
//
// Returns:
//   - *Watcher: Configured and started watcher
//   - error: Any initialization or file access errors
func UniversalConfigWatcherWithConfig(configPath string, callback func(config map[string]interface{}), config Config) (*Watcher, error) <span class="cov8" title="1">{
        // Detect format from file extension
        format := DetectFormat(configPath)
        if format == FormatUnknown </span><span class="cov8" title="1">{
                return nil, errors.New(ErrCodeConfigNotFound, "unsupported config format for file: "+configPath)
        }</span>

        // Configure watcher
        <span class="cov8" title="1">watcher := setupUniversalWatcher(config)

        // Track current config for audit trail
        var currentConfig map[string]interface{}

        // Create watch callback
        watchCallback := createUniversalWatchCallback(format, callback, watcher, &amp;currentConfig)

        // Setup file watching
        if err := watcher.Watch(configPath, watchCallback); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "failed to watch config file")
        }</span>

        // Initialize and start watcher
        <span class="cov8" title="1">if err := initializeUniversalWatcher(watcher, configPath, format, callback, &amp;currentConfig); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return watcher, nil</span>
}

// setupUniversalWatcher configures a new watcher with defaults
func setupUniversalWatcher(config Config) *Watcher <span class="cov8" title="1">{
        // Set default error handler if none provided
        if config.ErrorHandler == nil </span><span class="cov8" title="1">{
                config.ErrorHandler = func(err error, path string) </span><span class="cov8" title="1">{
                        log.Printf("Argus: error in file %s: %v", path, err)
                }</span>
        }
        <span class="cov8" title="1">return New(config)</span>
}

// createUniversalWatchCallback creates the file change callback
func createUniversalWatchCallback(format ConfigFormat, callback func(config map[string]interface{}), watcher *Watcher, currentConfig *map[string]interface{}) func(ChangeEvent) <span class="cov8" title="1">{
        return func(event ChangeEvent) </span><span class="cov8" title="1">{
                if event.IsDelete </span><span class="cov0" title="0">{
                        // AUDIT: Log file deletion
                        if auditor := watcher.auditLogger; auditor != nil </span><span class="cov0" title="0">{
                                auditor.LogFileWatch("config_deleted", event.Path)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov8" title="1">newConfig, err := readAndParseConfig(event.Path, format)
                if err != nil </span><span class="cov8" title="1">{
                        if watcher.config.ErrorHandler != nil </span><span class="cov8" title="1">{
                                watcher.config.ErrorHandler(err, event.Path)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                // AUDIT: Log configuration change with before/after values
                <span class="cov8" title="1">if auditor := watcher.auditLogger; auditor != nil </span><span class="cov8" title="1">{
                        auditor.LogConfigChange(event.Path, *currentConfig, newConfig)
                }</span>

                // Update current config for next comparison
                <span class="cov8" title="1">*currentConfig = copyMap(newConfig)

                callback(newConfig)</span>
        }
}

// readAndParseConfig reads and parses a config file
func readAndParseConfig(path string, format ConfigFormat) (map[string]interface{}, error) <span class="cov8" title="1">{
        // SECURITY: Validate path to prevent directory traversal attacks
        if err := ValidateSecurePath(path); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // #nosec G304 -- Path validation performed above with ValidateSecurePath
        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, ErrCodeFileNotFound, "failed to read config file")
        }</span>

        <span class="cov8" title="1">newConfig, err := ParseConfig(data, format)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "failed to parse "+format.String()+" config")
        }</span>

        <span class="cov8" title="1">return newConfig, nil</span>
}

// initializeUniversalWatcher loads initial config and starts watching
func initializeUniversalWatcher(watcher *Watcher, configPath string, format ConfigFormat, callback func(config map[string]interface{}), currentConfig *map[string]interface{}) error <span class="cov8" title="1">{
        // Load initial configuration and start watcher
        if _, err := os.Stat(configPath); err == nil </span><span class="cov8" title="1">{
                initialConfig, err := readAndParseConfig(configPath, format) // #nosec G304 -- configPath is user-provided intentionally
                if err != nil </span><span class="cov8" title="1">{
                        return errors.Wrap(err, ErrCodeInvalidConfig, "failed to read initial config")
                }</span>

                // Set current config for audit trail
                <span class="cov8" title="1">*currentConfig = copyMap(initialConfig)

                // Auto-start the watcher (convenience feature)
                if err := watcher.Start(); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, ErrCodeWatcherBusy, "failed to start watcher")
                }</span>

                // Call callback with initial config
                <span class="cov8" title="1">callback(initialConfig)</span>
        } else<span class="cov8" title="1"> {
                // File doesn't exist yet, start watcher anyway
                if err := watcher.Start(); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, ErrCodeWatcherBusy, "failed to start watcher")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GenericConfigWatcher creates a watcher for JSON configuration (backward compatibility).
// DEPRECATED: Use UniversalConfigWatcher for better format support and future-proofing.
// This function is maintained for existing codebases but new code should use UniversalConfigWatcher.
func GenericConfigWatcher(configPath string, callback func(config map[string]interface{})) (*Watcher, error) <span class="cov8" title="1">{
        return UniversalConfigWatcher(configPath, callback)
}</span>

// SimpleFileWatcher creates a basic file watcher with minimal configuration.
// Useful for simple use cases where you just want to know when a file changes,
// without the complexity of configuration parsing or format detection.
//
// Parameters:
//   - filePath: Path to file to watch
//   - callback: Function called with file path when changes occur
//
// Returns:
//   - *Watcher: Configured watcher (not automatically started)
//   - error: Any initialization errors
func SimpleFileWatcher(filePath string, callback func(path string)) (*Watcher, error) <span class="cov8" title="1">{
        watcher := New(Config{})

        watchCallback := func(event ChangeEvent) </span><span class="cov8" title="1">{
                if !event.IsDelete </span><span class="cov8" title="1">{
                        callback(event.Path)
                }</span>
        }

        <span class="cov8" title="1">if err := watcher.Watch(filePath, watchCallback); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, ErrCodeInvalidConfig, "failed to watch file")
        }</span>

        <span class="cov8" title="1">return watcher, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

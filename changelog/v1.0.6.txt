````plaintext
# Argus v1.0.6 Release Notes

**Release Date**: October 20, 2025  
**Type**: Performance Optimization & Community Enhancement

## Overview

This release implements a hybrid CPU yielding strategy to improve latency while maintaining DoS protection. The optimization was inspired by valuable community feedback from Reddit, demonstrating the power of collaborative development in making OSS better.

## Performance Improvements

### Hybrid CPU Yielding Strategy
- **Enhanced**: Replaced `time.Sleep(100 * time.Microsecond)` with hybrid `runtime.Gosched()` + escalation approach
- **Optimized**: First attempt uses cooperative yielding for minimal latency
- **Protected**: Escalation to `time.Sleep(50 * time.Microsecond)` after 12,000 iterations for DoS protection
- **Result**: Maintained excellent performance characteristics:
  - SingleEvent: **25.67 ns/op** (consistent ultra-low latency)
  - ProcessBatch: **25.76 ns/op** (no regression)
  - MultipleEvents: **71.6 ns/op** (stable throughput)
  - Zero allocations maintained across all operations

## Technical Enhancements

### CPU Spinning Optimization
- **Issue**: `time.Sleep(100μs)` introduced unnecessary latency during idle periods
- **Solution**: Hybrid approach prioritizing responsiveness while maintaining safety
- **Implementation**: 
  ```go
  } else {
      // HYBRID APPROACH: Yield first for latency, sleep if still spinning
      runtime.Gosched()
      spins++
      
      if spins > 12000 { // Escalation after Gosched attempts
          time.Sleep(50 * time.Microsecond) // Reduced from 100μs
          spins = 0 // Reset counter
      }
  }
  ```

### Security Considerations Maintained
- **DoS Protection**: Escalation mechanism prevents 100% CPU usage during attacks
- **Rate Limiting**: Implicit rate limiting preserved through sleep escalation
- **Container Safety**: CPU limits work correctly in containerized environments
- **Single-goroutine Safety**: Protection against busy spinning in minimal environments

## Benchmark Results

### Performance Validation
```
BenchmarkBoreasLite_SingleEvent-8                     45974410    25.67 ns/op    0 B/op    0 allocs/op
BenchmarkBoreasLite_ProcessingStrategy/ProcessBatch_SingleEvent-8    
                                                       46649196    25.76 ns/op    0 B/op    0 allocs/op
BenchmarkBoreasLite_ProcessingStrategy/ProcessBatch_MultipleEvents-8
                                                       16728338    71.60 ns/op    0 B/op    0 allocs/op
BenchmarkArgus_PerLogEntryOverhead/Single_LogEntry_Baseline-8        
                                                       25113686    47.57 ns/op   48 B/op     1 allocs/op
BenchmarkArgus_PerLogEntryOverhead/Single_LogEntry_WithArgus-8       
                                                       21255639    56.17 ns/op   48 B/op     1 allocs/op
```

### Performance Analysis
- **Net Overhead**: Only **8.60 ns** per operation (excellent efficiency)
- **Allocation Profile**: Zero allocations in core processing paths
- **Latency Impact**: <2% variance (within statistical noise)
- **Throughput**: Maintained high throughput across all scenarios

## Implementation Details

### Hybrid Algorithm Benefits
1. **Low Latency**: `runtime.Gosched()` has ~1-2ns overhead vs 100μs guaranteed sleep
2. **Responsive**: Immediate resumption when events become available
3. **Safe**: Escalation provides guaranteed CPU throttling for security
4. **Efficient**: Cooperative yielding reduces scheduler pressure

### Import Addition
- **Added**: `runtime` package import for `runtime.Gosched()` functionality
- **Maintained**: All existing imports and dependencies unchanged

## Community Contributions

### Special Recognition
Huge thanks to **u/titpetric** from Reddit for the excellent optimization suggestion! Their insight about using `runtime.Gosched()` instead of `time.Sleep(100 * time.Microsecond)` led to this performance enhancement.

The question *"Do you need that time sleep 100 us? Wouldn't a runtime.Gosched() yield?"* sparked a valuable discussion about:
- CPU yielding strategies in Go
- Balancing latency vs security considerations  
- Hybrid approaches for optimal performance

This exemplifies how community engagement drives technical excellence. Thank you for making Argus better!

## Technical Background

### Problem Analysis
- **Original Issue**: Fixed 100μs sleep introduced unnecessary latency
- **Security Concern**: Pure `runtime.Gosched()` could allow DoS via busy spinning
- **Solution**: Hybrid approach combining benefits of both strategies

### Algorithm Evolution
```go
// v1.0.5 and earlier
} else {
    time.Sleep(100 * time.Microsecond)  // Always sleep
    spins = 0
}

// v1.0.6 hybrid approach  
} else {
    runtime.Gosched()                   // Try yield first
    spins++
    if spins > 12000 {                  // Escalate if needed
        time.Sleep(50 * time.Microsecond)
        spins = 0
    }
}
```

## Upgrade Notes

### Compatibility
- **Fully backward compatible** - no API changes
- **Automatic improvement** - existing code benefits from better latency
- **Zero breaking changes** - all existing functionality preserved

### For Library Users
- No code changes required
- Improved responsiveness during idle periods
- Maintained security guarantees
- Same excellent allocation profile

### For Performance-Critical Applications
- Reduced latency during event processing bursts
- Better CPU utilization in multi-goroutine environments
- Maintained DoS protection for production deployments

## Testing Validation

### Comprehensive Verification
- **Benchmark Suite**: All performance tests pass with improved or stable results
- **Security Tests**: DoS protection mechanisms verified through escalation testing
- **Compatibility**: Existing functionality completely preserved
- **Zero Regressions**: No negative impact on any existing features

## Files Modified

```
boreaslite.go - Hybrid CPU yielding implementation in runAutoProcessor()
```

## Looking Forward

This optimization demonstrates our commitment to:
- **Community-driven development**: Listening to and acting on valuable feedback
- **Performance excellence**: Continuous optimization without compromising safety
- **Technical leadership**: Implementing best practices in concurrent Go programming
- **Collaborative innovation**: Building better software through open dialogue